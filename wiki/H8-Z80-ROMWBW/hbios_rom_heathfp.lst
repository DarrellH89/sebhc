0001   0000             ;
0002   0000             ;==================================================================================================
0003   0000             ;   HBIOS
0004   0000             ;==================================================================================================
0005   0000             ;
0006   0000             ; THIS FILE CONTAINS THE HBIOS IMAGE THAT IS INTENDED TO RUN IN A DEDICATED RAM BANK.  THE CODE IS
0007   0000             ; CONSTRUCTED SUCH THAT IT CAN BE LAUNCHED IN A VARIETY OF MODES AND INSTALL ITSELF.  A SMALL 512
0008   0000             ; BYTE PROXY IS PLACED AT THE TOP OF CPU MEMORY (FE00H-FFFFH).	THIS PROXY CODE ALLOWS CODE
0009   0000             ; RUNNING FROM ANY BANK TO INVOKE HBIOS FUNCTIONS.  NORMALLY, ANY BANK THAT RUNS CODE WOULD SETUP
0010   0000             ; THE RST 8 VECTOR TO POINT TO THE PROXY INVOKE ENTRY POINT AT FFF0H.  CALLS VIA THE PROXY INVOKE
0011   0000             ; ENTRY POINT TRANSPARENTLY SWAP IN THE HBIOS BANK, PERFORM THE REQUESTED FUNCTION, AND RETURN
0012   0000             ; WITH THE ORIGINAL BANK ACTIVE.  THE CODE USING HBIOS FUNCTIONS DOES NOT NEED TO BE AWARE OF
0013   0000             ; THE BANK SWITCHING THAT OCCURS.
0014   0000             ;
0015   0000             ; THIS FILE CAN BE COMPILED TO BOOT IN ONE OF 3 MODES (ROM, APPLICATION, OR IMAGE) AS DESCRIBED
0016   0000             ; BELOW.  WHEN COMPILED, YOU MUST DEFINE EXACTLY ONE OF THE FOLLOWING MACROS:
0017   0000             ;
0018   0000             ; - ROMBOOT: BOOT FROM A ROM BANK
0019   0000             ;
0020   0000             ;   WHEN ROMBOOT IS DEFINED, THE FILE IS ASSEMBLED TO BE IMBEDDED AT THE START OF A ROM
0021   0000             ;   ASSUMING THAT THE CPU WILL START EXECUTION AT ADDRESS 0.  AFTER PERFORMING MINIMAL
0022   0000             ;   SYSTEM INITIALIZATION, THE IMAGE OF THE RUNNING ROM BANK IS COPIED TO A RAM BANK
0023   0000             ;   CREATING A SHADOW COPY IN RAM.  EXECUTION IS THAN TRANSFERRED TO THE RAM SHADOW COPY.
0024   0000             ;   THIS IS ESSENTIAL BECAUSE THE HBIOS CODE DOES NOT SUPPORT RUNNING IN READ ONLY MEMORY
0025   0000             ;   (EXCEPT FOR THE INITIAL LAUNCHING CODE).  IN THIS MODE, THE HBIOS INITIALIZATION WILL
0026   0000             ;   ALSO COPY THE OS IMAGES BANK IN ROM TO THE USER RAM BANK AND LAUNCH IT AFTER HBIOS
0027   0000             ;   IS INSTALLED.
0028   0000             ;
0029   0000             ; - APPBOOT: BOOT FROM A CP/M STYLE APPLICATION FILE
0030   0000             ;
0031   0000             ;   WHEN APPBOOT IS DEFINED, THE FILE IS ASSEMBLED AS A CP/M APPLICATION ASSUMING
0032   0000             ;   THAT IT WILL BE LOADED AT 100H BY THE CP/M (OR COMPATIBLE) OS.  NOTE THAT IN
0033   0000             ;   THIS CASE IT IS ASSUMED THAT AN OS IMAGES FILE IS APPENDED TO THE END OF THE
0034   0000             ;   HBIOS APPLICATION BINARY.  THE APPENDED OS IMAGES ARE COPIED TO THE USER RAM
0035   0000             ;   BANK AND LAUNCHED AFTER HBIOS HAS INSTALLED ITSELF.
0036   0000             ;
0037   0000             ; - IMGBOOT: BOOT FROM AN IMAGE FILE THAT HAS BEEN PLACED IN THE USER BANK
0038   0000             ;
0039   0000             ;   WHEN IMGBOOT IS DEFINED, THE FILE IS ASSEMBLED SUCH THAT IT CAN BE PRELOADED
0040   0000             ;   INTO THE RAM USER BANK BY AN EXTERNAL PROCESS THAT SUBSEQUENTLY LAUNCHES
0041   0000             ;   THE CODE AT ADDRESS 0.  THE MOST COMMON EXAMPLE OF THIS IS THE UNA FSFAT
0042   0000             ;   TOOL WHICH CAN LOAD AN IMAGE FROM A DOS FAT FILESYSTEM PROVIDING A SIMPLE
0043   0000             ;   WAY TO LOAD A TEST COPY OF HBIOS.  AS IS THE CASE WITH APPBOOT, IT IS ASSUMED
0044   0000             ;   THAT AN OS IMAGES FILE IS APPENDED TO THE END OF THE IMAGE AND IS LAUNCHED
0045   0000             ;   AFTER HBIOS IS INSTALLED.
0046   0000             ;
0047   0000             ; INCLUDE FILE NESTING:
0048   0000             ;
0049   0000             ; hbios.asm
0050   0000             ;  - std.asm
0051   0000             ;    - ver.inc
0052   0000             ;    - hbios.inc
0053   0000             ;    - build.inc
0054   0000             ;      - config/<plt>_<cfg>.asm
0055   0000             ;        - cfg_<plt>.asm
0056   0000             ;      - [z180.inc|z280.inc]
0057   0000             ;      - [eipc.inc]
0058   0000             ;  - <drivers>.asm
0059   0000             ;  - <fonts>.asm
0060   0000             ;  - util.asm
0061   0000             ;  - time.asm
0062   0000             ;  - bcd.asm
0063   0000             ;  - decode.asm
0064   0000             ;  - encode.asm
0065   0000             ;  - [xio|mio].asm
0066   0000             ;  - [dsky.asm|dskyng.asm]
0067   0000             ;  - unlzsa2s.asm
0068   0000             ;
0069   0000             ; INCLUDE GENERIC STUFF
0070   0000             ;
0071   0000             #INCLUDE "std.asm"
0001+  0000             ; The purpose of this file is to define generic symbols and to include
0002+  0000             ; the requested build configuraton file to bring in platform specifics.
0003+  0000             
0004+  0000             ; There are several hardware platforms supported by SBC.
0005+  0000             ; 1.  SBC	Z80 SBC (v1 or v2) w/ ECB interface
0006+  0000             ; 2.  ZETA	Standalone Z80 SBC w/ SBC compatibility
0007+  0000             ; 3.  ZETA2	Second version of ZETA with enhanced memory bank switching
0008+  0000             ; 4.  N8	MSX-ish Z180 SBC w/ onboard video and sound
0009+  0000             ; 5.  MK4	Mark IV Z180 based SBC w/ ECB interface
0010+  0000             ; 6.  UNA	Any Z80/Z180 computer with UNA BIOS
0011+  0000             ; 7.  RCZ80	RCBUS based system with 512K banked RAM/ROM card
0012+  0000             ; 8.  RCZ180	RCBUS based system with Z180 CPU
0013+  0000             ; 9.  EZZ80	Easy Z80, Z80 SBC w/ RCBUS and CTC
0014+  0000             ; 10. SCZ180	Steve Cousins Z180 based system
0015+  0000             ; 11. DYNO	Steve Garcia's Dyno Micro-ATX Motherboard
0016+  0000             ; 12. RCZ280	Z280 CPU on RCBUS or ZZ80MB
0017+  0000             ; 13. MBC	Andrew Lynch's Multi Board Computer
0018+  0000             ; 14. RPH	Andrew Lynch's RHYOPHYRE Graphics Computer
0019+  0000             
0020+  0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0021+  0000             ;
0022+  0000             ; INCLUDE VERSION
0023+  0000             ;
0024+  0000             #INCLUDE "../ver.inc"			; ADD BIOSVER
0001++ 0000             #DEFINE	RMJ	3
0002++ 0000             #DEFINE	RMN	2
0003++ 0000             #DEFINE	RUP	1
0004++ 0000             #DEFINE	RTP	0
0005++ 0000             #DEFINE BIOSVER	"3.2.1"
0006++ 0000             #define rmj	RMJ
0007++ 0000             #define rmn	RMN
0008++ 0000             #define rup	RUP
0009++ 0000             #define rtp	RTP
0025+  0000             ;
0026+  0000             FALSE		.EQU	0
0027+  0000             TRUE		.EQU	~FALSE
0028+  0000             ;
0029+  0000             ; DEBUGGING OPTIONS
0030+  0000             ;
0031+  0000             USENONE		.EQU	0		; NO DEBUG
0032+  0000             USEXIO		.EQU	1		; BASIC SERIAL DRIVER
0033+  0000             USEMIO		.EQU	2		; MEMORY BUFFER DRIVER
0034+  0000             WBWDEBUG	.EQU	USENONE
0035+  0000             ;
0036+  0000             ; DIAGNOSTIC LEVEL OPTIONS
0037+  0000             ;
0038+  0000             DL_NONE		.EQU	0		; HBIOS DISPLAY NO MESSAGES
0039+  0000             DL_CRITICAL	.EQU	4		; HBIOS DISPLAY CRITICAL ERROR MESSAGES
0040+  0000             DL_ERROR	.EQU	8		; HBIOS DISPLAYS ALL ERROR MESSAGES
0041+  0000             DL_WARNING	.EQU	12		; HBIOS DISPLAYS WARNING MESSAGES
0042+  0000             DL_INFO		.EQU	16		; HBIOS DISPLAYS INFORMATIONAL MESSAGES
0043+  0000             DL_DETAIL	.EQU	20		; HBIOS DISPLAYS DETAILED DIAGNOSTIC MESSAGES
0044+  0000             DL_VERBOSE	.EQU	24		; HBIOS DISPLAYS ANYTHING IT KNOWS HOW TO
0045+  0000             ;
0046+  0000             ; CPU TYPES
0047+  0000             ;
0048+  0000             CPU_NONE	.EQU	0		; NO CPU TYPE DEFINED
0049+  0000             CPU_Z80		.EQU	1		; Z80 FAMILY
0050+  0000             CPU_Z180	.EQU	2		; Z180 FAMILY
0051+  0000             CPU_Z280	.EQU	3		; Z280 FAMILY
0052+  0000             ;
0053+  0000             ; BIOS MODE
0054+  0000             ;
0055+  0000             BIOS_NONE	.EQU	0		; NO BIOS TYPE DEFINED
0056+  0000             BIOS_WBW	.EQU	1		; ROMWBW HBIOS
0057+  0000             BIOS_UNA	.EQU	2		; UNA UBIOS
0058+  0000             ;
0059+  0000             ; MEMORY MANAGERS
0060+  0000             ;
0061+  0000             MM_NONE		.EQU	0
0062+  0000             MM_SBC		.EQU	1		; ORIGINAL N8VEM/RBC Z80 SBC BANKED MEMORY
0063+  0000             MM_Z2		.EQU	2		; 16K X 4 BANKED MEMORY INTRODUCED ON ZETA2
0064+  0000             MM_N8		.EQU	3		; Z180 CUSTOMIZED FOR N8 MEMORY EXTENSIONS
0065+  0000             MM_Z180		.EQU	4		; Z180 NATIVE MEMORY MANAGER
0066+  0000             MM_Z280		.EQU	5		; Z280 NATIVE MEMORY MANAGER
0067+  0000             MM_ZRC		.EQU	6		; ZRC BANK SWITCHING
0068+  0000             MM_MBC		.EQU	7		; MBC MEMORY MANAGER
0069+  0000             MM_RPH		.EQU	8		; Z180 WITH RPH EXTENSIONS
0070+  0000             ;
0071+  0000             ; BOOT STYLE
0072+  0000             ;
0073+  0000             BT_MENU		.EQU	1		; WAIT FOR MENU SELECTION AT LOADER PROMPT
0074+  0000             BT_AUTO		.EQU	2		; AUTO SELECT BOOT_DEFAULT AFTER BOOT_TIMEOUT
0075+  0000             ;
0076+  0000             ; BOOT RECOVERY METHODS
0077+  0000             ;
0078+  0000             BT_REC_NONE	.EQU	0		; NO RECOVERY MODE
0079+  0000             BT_REC_FORCE	.EQU	1		; FORCE BOOT RECOVERY MODE
0080+  0000             BT_REC_SBC01	.EQU	2		; ECB-SBCV2 - BIT 1 RTC HIGH
0081+  0000             BT_REC_SBC1B	.EQU	3		; ECB-SBCV2 - 1-BIT IO PORT
0082+  0000             BT_REC_SBCRI	.EQU	4		; ECB-SBCV2 - 16550 UART RING INDICATOR LINE
0083+  0000             ;
0084+  0000             BT_REC_TYPE	.EQU	BT_REC_NONE	; BOOT RECOVERY METHOD TO USE
0085+  0000             ;
0086+  0000             ; FLOPPY DISK MEDIA SELECTIONS (ID'S MUST BE INDEX OF ENTRY IN FCD_TBL)
0087+  0000             ;
0088+  0000             FDM720		.EQU	0		; 3.5" FLOPPY, 720KB, 2 SIDES, 80 TRKS, 9 SECTORS
0089+  0000             FDM144		.EQU	1		; 3.5" FLOPPY, 1.44MB, 2 SIDES, 80 TRKS, 18 SECTORS
0090+  0000             FDM360		.EQU	2		; 5.25" FLOPPY, 360KB, 2 SIDES, 40 TRKS, 9 SECTORS
0091+  0000             FDM120		.EQU	3		; 5.25" FLOPPY, 1.2MB, 2 SIDES, 80 TRKS, 15 SECTORS
0092+  0000             FDM111		.EQU	4		; 8" FLOPPY, 1.11MB, 2 SIDES, 74 TRKS, 15 SECTORS
0093+  0000             ;
0094+  0000             ; ZILOG CTC MODE SELECTIONS
0095+  0000             ;
0096+  0000             CTCMODE_NONE	.EQU	0		; NO CTC
0097+  0000             CTCMODE_CTR	.EQU	1		; CTC COUNTER
0098+  0000             CTCMODE_TIM16	.EQU	2		; CTC TIMER W/ DIV 16
0099+  0000             CTCMODE_TIM256	.EQU	3		; CTC TIMER W/ DIV 256
0100+  0000             ;
0101+  0000             ; DS1302 RTC MODE SELECTIONS
0102+  0000             ;
0103+  0000             DSRTCMODE_NONE	.EQU	0		; NO DSRTC
0104+  0000             DSRTCMODE_STD	.EQU	1		; ORIGINAL DSRTC CIRCUIT (SBC, ZETA, MK4)
0105+  0000             DSRTCMODE_MFPIC	.EQU	2		; MF/PIC VARIANT
0106+  0000             ;
0107+  0000             ; DS1307 RTC MODE SELECTIONS
0108+  0000             ;
0109+  0000             DS7RTCMODE_NONE	.EQU	0		; NO DSRTC
0110+  0000             DS7RTCMODE_PCF	.EQU	1		; PCF8584 I2C
0111+  0000             ;
0112+  0000             ; SIO MODE SELECTIONS
0113+  0000             ;
0114+  0000             SIOMODE_NONE	.EQU	0
0115+  0000             SIOMODE_STD	.EQU	1		; STD SIO REG CFG (EZZ80, KIO)
0116+  0000             SIOMODE_RC	.EQU	2		; RCBUS SIO MODULE (SPENCER OWEN)
0117+  0000             SIOMODE_SMB	.EQU	3		; RCBUS SIO MODULE (SCOTT BAKER)
0118+  0000             SIOMODE_ZP	.EQU	4		; ECB-ZILOG PERIPHERALS BOARD
0119+  0000             ;
0120+  0000             ; TYPE OF CONSOLE BELL TO USE
0121+  0000             ;
0122+  0000             CONBELL_NONE	.EQU	0
0123+  0000             CONBELL_PSG	.EQU	1
0124+  0000             CONBELL_IOBIT	.EQU	2
0125+  0000             ;
0126+  0000             ; LED MODE SELECTIONS
0127+  0000             ;
0128+  0000             LEDMODE_NONE	.EQU	0
0129+  0000             LEDMODE_STD	.EQU	1
0130+  0000             LEDMODE_RTC	.EQU	2
0131+  0000             ;
0132+  0000             ; DSKY MODE SELECTIONS
0133+  0000             ;
0134+  0000             DSKYMODE_NONE	.EQU	0
0135+  0000             DSKYMODE_V1	.EQU	1
0136+  0000             DSKYMODE_NG	.EQU	2
0137+  0000             ;
0138+  0000             ; FD MODE SELECTIONS
0139+  0000             ;
0140+  0000             FDMODE_NONE	.EQU	0
0141+  0000             FDMODE_DIO	.EQU	1		; DISKIO V1
0142+  0000             FDMODE_ZETA	.EQU	2		; ZETA
0143+  0000             FDMODE_ZETA2	.EQU	3		; ZETA V2
0144+  0000             FDMODE_DIDE	.EQU	4		; DUAL IDE
0145+  0000             FDMODE_N8	.EQU	5		; N8
0146+  0000             FDMODE_DIO3	.EQU	6		; DISKIO V3
0147+  0000             FDMODE_RCSMC	.EQU	7		; RCBUS SMC 9266 @ $40 (SCOTT BAKER)
0148+  0000             FDMODE_RCWDC	.EQU	8		; RCBUS WDC 37C65 @ $40 (SCOTT BAKER)
0149+  0000             FDMODE_DYNO	.EQU	9		; DYNO WDC 37C65 @ $84
0150+  0000             FDMODE_EPFDC	.EQU	10		; RCBUS ETCHED PIXELS FDC
0151+  0000             FDMODE_MBC	.EQU	11		; MULTI-BOARD COMPUTER FDC
0152+  0000             ;
0153+  0000             ; IDE MODE SELECTIONS
0154+  0000             ;
0155+  0000             IDEMODE_NONE	.EQU	0
0156+  0000             IDEMODE_DIO	.EQU	1		; DISKIO V1
0157+  0000             IDEMODE_DIDE	.EQU	2		; DUAL IDE
0158+  0000             IDEMODE_MK4	.EQU	3		; MARK IV ONBOARD IDE (8 BIT ONLY)
0159+  0000             IDEMODE_RC	.EQU	4		; RCBUS CF MODULE (8 BIT ONLY)
0160+  0000             ;
0161+  0000             ; PPIDE MODE SELECTIONS
0162+  0000             ;
0163+  0000             PPIDEMODE_NONE	.EQU	0
0164+  0000             PPIDEMODE_SBC	.EQU	1		; STANDARD SBC PARALLEL PORT
0165+  0000             PPIDEMODE_DIO3	.EQU	2		; DISKIO V3 PARALLEL PORT
0166+  0000             PPIDEMODE_MFP	.EQU	3		; MULTIFUNCTION / PIC
0167+  0000             PPIDEMODE_N8	.EQU	4		; MULTIFUNCTION / PIC
0168+  0000             PPIDEMODE_RC	.EQU	5		; RCBUS PPIDE MODULE @ $20 (ED BRINDLEY)
0169+  0000             PPIDEMODE_DYNO	.EQU	6		; DYNO PPIDE @ $4C
0170+  0000             PPIDEMODE_RPH	.EQU	7		; RHYOPHYRE (RPH)
0171+  0000             ;
0172+  0000             ; SD MODE SELECTIONS
0173+  0000             ;
0174+  0000             SDMODE_NONE	.EQU	0
0175+  0000             SDMODE_JUHA	.EQU	1		; JUHA MINI BOARD
0176+  0000             SDMODE_N8	.EQU	2		; N8-2511, UNMODIFIED
0177+  0000             SDMODE_CSIO	.EQU	3		; N8-2312 OR N8-2511 MODIFIED
0178+  0000             SDMODE_PPI	.EQU	4		; PPISD MINI BOARD
0179+  0000             SDMODE_UART	.EQU	5		; SD INTERFACE VIA UART
0180+  0000             SDMODE_DSD	.EQU	6		; DUAL SD
0181+  0000             SDMODE_MK4	.EQU	7		; MARK IV
0182+  0000             SDMODE_SC	.EQU	8		; SC (Steve Cousins)
0183+  0000             SDMODE_MT	.EQU	9		; MT (Shift register SPI WIZNET for RCBUS)
0184+  0000             SDMODE_USR	.EQU	10		; USER DEFINED (in sd.asm) (NOT COMPLETE)
0185+  0000             ;
0186+  0000             ; AY SOUND CHIP MODE SELECTIONS
0187+  0000             ;
0188+  0000             AYMODE_NONE	.EQU	0
0189+  0000             AYMODE_N8	.EQU	1		; N8 BUILT-IN SOUND
0190+  0000             AYMODE_SCG	.EQU	2		; SCG ECB BOARD
0191+  0000             AYMODE_RCZ80	.EQU	3		; RCBUS SOUND MODULE BY ED BRINDLEY ON Z80
0192+  0000             AYMODE_RCZ180	.EQU	4		; RCBUS SOUND MODULE BY ED BRINDLEY ON Z180
0193+  0000             AYMODE_MSX	.EQU	5		; RCBUS SOUND MODULE REV6 BY ED BRINDLEY ON Z80/Z180 AT MSX PORTS
0194+  0000             AYMODE_LINC	.EQU	6		; LINC Z50 AY SOUND CARD
0195+  0000             AYMODE_MBC	.EQU	7		; MBC SOUND BOARD
0196+  0000             ;
0197+  0000             ; SN SOUND CHIP MODE SELECTIONS
0198+  0000             ;
0199+  0000             SNMODE_NONE	.EQU	0
0200+  0000             SNMODE_RC	.EQU	1		; RCBUS SOUND MODULE
0201+  0000             SNMODE_VGM	.EQU	2		; VGM ECB BOARD
0202+  0000             ;
0203+  0000             ; TMS VIDEO MODE SELECTIONS
0204+  0000             ;
0205+  0000             TMSMODE_NONE	.EQU	0
0206+  0000             TMSMODE_SCG	.EQU	1		; SCG ECB BOARD
0207+  0000             TMSMODE_N8	.EQU	2		; N8 BUILT-IN VIDEO
0208+  0000             TMSMODE_MSX	.EQU	3		; MSX PORT MAPPING
0209+  0000             TMSMODE_MSX9958	.EQU	4		; MSX PORTS, V9958 CHIP
0210+  0000             TMSMODE_MSXKBD	.EQU	5		; MSX PORTS + PS2 KEYBOARD
0211+  0000             TMSMODE_MBC	.EQU	6		; MBC V9938/58 VIDEO BOARD
0212+  0000             TMSMODE_COLECO	.EQU	7		; COLECOVISION PORT MAPPING
0213+  0000             ;
0214+  0000             ; CVDU VIDEO MODE SELECTIONS
0215+  0000             ;
0216+  0000             CVDUMODE_NONE	.EQU	0
0217+  0000             CVDUMODE_ECB	.EQU	1		; SCG ECB BOARD
0218+  0000             CVDUMODE_MBC	.EQU	2		; MBC VDC BOARD
0219+  0000             ;
0220+  0000             ; CVDU MONITOR SELECTIONS
0221+  0000             ;
0222+  0000             CVDUMON_NONE	.EQU	0
0223+  0000             CVDUMON_CGA	.EQU	1		; CGA MONITOR TIMING (16.000 MHZ OSC)
0224+  0000             CVDUMON_EGA	.EQU	2		; EGA MONITOR TIMING (16.257 MHZ OSC)
0225+  0000             ;
0226+  0000             ; GDC VIDEO MODE SELECTIONS
0227+  0000             ;
0228+  0000             GDCMODE_NONE	.EQU	0
0229+  0000             GDCMODE_ECB	.EQU	1		; ECB GDC
0230+  0000             GDCMODE_RPH	.EQU	2		; RPH GDC
0231+  0000             ;
0232+  0000             ; GDC MONITOR SELECTIONS
0233+  0000             ;
0234+  0000             GDCMON_NONE	.EQU	0
0235+  0000             GDCMON_CGA	.EQU	1		; CGA MONITOR TIMING (16.000 MHZ OSC)
0236+  0000             GDCMON_EGA	.EQU	2		; EGA MONITOR TIMING (16.257 MHZ OSC)
0237+  0000             ;
0238+  0000             ; DMA MODE SELECTIONS
0239+  0000             ;
0240+  0000             DMAMODE_NONE	.EQU	0
0241+  0000             DMAMODE_ECB	.EQU	1		; ECB-DMA WOLFGANG KABATZKE'S Z80 DMA ECB BOARD
0242+  0000             DMAMODE_Z180	.EQU	2		; Z180 INTEGRATED DMA
0243+  0000             DMAMODE_Z280	.EQU	3		; Z280 INTEGRATED DMA
0244+  0000             DMAMODE_RC	.EQU	4		; RCBUS Z80 DMA
0245+  0000             DMAMODE_MBC	.EQU	5		; MBC
0246+  0000             ;
0247+  0000             ; SERIAL DEVICE CONFIGURATION CONSTANTS
0248+  0000             ;
0249+  0000             SER_DATA5	.EQU	0 << 0
0250+  0000             SER_DATA6	.EQU	1 << 0
0251+  0000             SER_DATA7	.EQU	2 << 0
0252+  0000             SER_DATA8	.EQU	3 << 0
0253+  0000             ;
0254+  0000             SER_PARNONE	.EQU	0 << 3
0255+  0000             SER_PARODD	.EQU	1 << 3
0256+  0000             SER_PAREVEN	.EQU	3 << 3
0257+  0000             SER_PARMARK	.EQU	5 << 3
0258+  0000             SER_PARSPACE	.EQU	7 << 3
0259+  0000             ;
0260+  0000             SER_STOP1	.EQU	0 << 2
0261+  0000             SER_STOP2	.EQU	1 << 2
0262+  0000             ;
0263+  0000             ; SERIAL BAUD RATES ENCODED AS V = 75 * 2^X * 3^Y
0264+  0000             ; AND STORED AS 5 BITS: YXXXX
0265+  0000             ;
0266+  0000             SER_BAUD75	.EQU	$00 << 8
0267+  0000             SER_BAUD150	.EQU	$01 << 8
0268+  0000             SER_BAUD300	.EQU	$02 << 8
0269+  0000             SER_BAUD600	.EQU	$03 << 8
0270+  0000             SER_BAUD1200	.EQU	$04 << 8
0271+  0000             SER_BAUD2400	.EQU	$05 << 8
0272+  0000             SER_BAUD4800	.EQU	$06 << 8
0273+  0000             SER_BAUD9600	.EQU	$07 << 8
0274+  0000             SER_BAUD19200	.EQU	$08 << 8
0275+  0000             SER_BAUD38400	.EQU	$09 << 8
0276+  0000             SER_BAUD76800	.EQU	$0A << 8
0277+  0000             SER_BAUD153600	.EQU	$0B << 8
0278+  0000             SER_BAUD307200	.EQU	$0C << 8
0279+  0000             SER_BAUD614400	.EQU	$0D << 8
0280+  0000             SER_BAUD1228800	.EQU	$0E << 8
0281+  0000             SER_BAUD2457600	.EQU	$0F << 8
0282+  0000             SER_BAUD225	.EQU	$10 << 8
0283+  0000             SER_BAUD450	.EQU	$11 << 8
0284+  0000             SER_BAUD900	.EQU	$12 << 8
0285+  0000             SER_BAUD1800	.EQU	$13 << 8
0286+  0000             SER_BAUD3600	.EQU	$14 << 8
0287+  0000             SER_BAUD7200	.EQU	$15 << 8
0288+  0000             SER_BAUD14400	.EQU	$16 << 8
0289+  0000             SER_BAUD28800	.EQU	$17 << 8
0290+  0000             SER_BAUD57600	.EQU	$18 << 8
0291+  0000             SER_BAUD115200	.EQU	$19 << 8
0292+  0000             SER_BAUD230400	.EQU	$1A << 8
0293+  0000             SER_BAUD460800	.EQU	$1B << 8
0294+  0000             SER_BAUD921600	.EQU	$1C << 8
0295+  0000             SER_BAUD1843200	.EQU	$1D << 8
0296+  0000             SER_BAUD3686400	.EQU	$1E << 8
0297+  0000             SER_BAUD7372800	.EQU	$1F << 8
0298+  0000             ;
0299+  0000             ; UART DIVIDER VALUES
0300+  0000             ; STORED AS 5 BITS: YXXXX
0301+  0000             ;
0302+  0000             DIV_1		.EQU	$00
0303+  0000             DIV_2		.EQU	$01
0304+  0000             DIV_4		.EQU	$02
0305+  0000             DIV_8		.EQU	$03
0306+  0000             DIV_16		.EQU	$04
0307+  0000             DIV_32		.EQU	$05
0308+  0000             DIV_64		.EQU	$06
0309+  0000             DIV_128		.EQU	$07
0310+  0000             DIV_256		.EQU	$08
0311+  0000             DIV_512		.EQU	$09
0312+  0000             DIV_1024	.EQU	$0A
0313+  0000             DIV_2048	.EQU	$0B
0314+  0000             DIV_4096	.EQU	$0C
0315+  0000             DIV_8192	.EQU	$0D
0316+  0000             DIV_16384	.EQU	$0E
0317+  0000             DIV_32768	.EQU	$0F
0318+  0000             DIV_3		.EQU	$10
0319+  0000             DIV_6		.EQU	$11
0320+  0000             DIV_12		.EQU	$12
0321+  0000             DIV_24		.EQU	$13
0322+  0000             DIV_48		.EQU	$14
0323+  0000             DIV_96		.EQU	$15
0324+  0000             DIV_192		.EQU	$16
0325+  0000             DIV_384		.EQU	$17
0326+  0000             DIV_768		.EQU	$18
0327+  0000             DIV_1536	.EQU	$19
0328+  0000             DIV_3072	.EQU	$1A
0329+  0000             DIV_6144	.EQU	$1B
0330+  0000             DIV_12288	.EQU	$1C
0331+  0000             DIV_24576	.EQU	$1D
0332+  0000             DIV_49152	.EQU	$1E
0333+  0000             DIV_98304	.EQU	$1F
0334+  0000             ;
0335+  0000             SER_XON		.EQU	1 << 6
0336+  0000             SER_DTR		.EQU	1 << 7
0337+  0000             SER_RTS		.EQU	1 << 13
0338+  0000             ;
0339+  0000             SER_75_8N1	.EQU	SER_BAUD75 | SER_DATA8 | SER_PARNONE | SER_STOP1
0340+  0000             SER_150_8N1	.EQU	SER_BAUD150 | SER_DATA8 | SER_PARNONE | SER_STOP1
0341+  0000             SER_300_8N1	.EQU	SER_BAUD300 | SER_DATA8 | SER_PARNONE | SER_STOP1
0342+  0000             SER_600_8N1	.EQU	SER_BAUD600 | SER_DATA8 | SER_PARNONE | SER_STOP1
0343+  0000             SER_1200_8N1	.EQU	SER_BAUD1200 | SER_DATA8 | SER_PARNONE | SER_STOP1
0344+  0000             SER_2400_8N1	.EQU	SER_BAUD2400 | SER_DATA8 | SER_PARNONE | SER_STOP1
0345+  0000             SER_4800_8N1	.EQU	SER_BAUD4800 | SER_DATA8 | SER_PARNONE | SER_STOP1
0346+  0000             SER_9600_8N1	.EQU	SER_BAUD9600 | SER_DATA8 | SER_PARNONE | SER_STOP1
0347+  0000             SER_19200_8N1	.EQU	SER_BAUD19200 | SER_DATA8 | SER_PARNONE | SER_STOP1
0348+  0000             SER_38400_8N1	.EQU	SER_BAUD38400 | SER_DATA8 | SER_PARNONE | SER_STOP1
0349+  0000             SER_76800_8N1	.EQU	SER_BAUD76800 | SER_DATA8 | SER_PARNONE | SER_STOP1
0350+  0000             SER_153600_8N1	.EQU	SER_BAUD153600 | SER_DATA8 | SER_PARNONE | SER_STOP1
0351+  0000             SER_307200_8N1	.EQU	SER_BAUD307200 | SER_DATA8 | SER_PARNONE | SER_STOP1
0352+  0000             SER_614400_8N1	.EQU	SER_BAUD614400 | SER_DATA8 | SER_PARNONE | SER_STOP1
0353+  0000             SER_1228800_8N1	.EQU	SER_BAUD1228800 | SER_DATA8 | SER_PARNONE | SER_STOP1
0354+  0000             SER_2457600_8N1	.EQU	SER_BAUD2457600 | SER_DATA8 | SER_PARNONE | SER_STOP1
0355+  0000             SER_225_8N1	.EQU	SER_BAUD225 | SER_DATA8 | SER_PARNONE | SER_STOP1
0356+  0000             SER_450_8N1	.EQU	SER_BAUD450 | SER_DATA8 | SER_PARNONE | SER_STOP1
0357+  0000             SER_900_8N1	.EQU	SER_BAUD900 | SER_DATA8 | SER_PARNONE | SER_STOP1
0358+  0000             SER_1800_8N1	.EQU	SER_BAUD1800 | SER_DATA8 | SER_PARNONE | SER_STOP1
0359+  0000             SER_3600_8N1	.EQU	SER_BAUD3600 | SER_DATA8 | SER_PARNONE | SER_STOP1
0360+  0000             SER_7200_8N1	.EQU	SER_BAUD7200 | SER_DATA8 | SER_PARNONE | SER_STOP1
0361+  0000             SER_14400_8N1	.EQU	SER_BAUD14400 | SER_DATA8 | SER_PARNONE | SER_STOP1
0362+  0000             SER_28800_8N1	.EQU	SER_BAUD28800 | SER_DATA8 | SER_PARNONE | SER_STOP1
0363+  0000             SER_57600_8N1	.EQU	SER_BAUD57600 | SER_DATA8 | SER_PARNONE | SER_STOP1
0364+  0000             SER_115200_8N1	.EQU	SER_BAUD115200 | SER_DATA8 | SER_PARNONE | SER_STOP1
0365+  0000             SER_230400_8N1	.EQU	SER_BAUD230400 | SER_DATA8 | SER_PARNONE | SER_STOP1
0366+  0000             SER_460800_8N1	.EQU	SER_BAUD460800 | SER_DATA8 | SER_PARNONE | SER_STOP1
0367+  0000             SER_921600_8N1	.EQU	SER_BAUD921600 | SER_DATA8 | SER_PARNONE | SER_STOP1
0368+  0000             SER_1843200_8N1	.EQU	SER_BAUD1843200 | SER_DATA8 | SER_PARNONE | SER_STOP1
0369+  0000             SER_3686400_8N1	.EQU	SER_BAUD3686400 | SER_DATA8 | SER_PARNONE | SER_STOP1
0370+  0000             SER_7372800_8N1	.EQU	SER_BAUD7372800 | SER_DATA8 | SER_PARNONE | SER_STOP1
0371+  0000             ;
0372+  0000             ; TERMENABLE CONTROLS INCLUSION OF TERMINAL PSEUDO-DEVICE DRIVER
0373+  0000             ; IT IS SET TO TRUE BY THE INCLUSION OF ANY VDA DRIVER.
0374+  0000             ;
0375+  0000             TERMENABLE	.EQU	FALSE		; TERM PSEUDO DEVICE, WILL AUTO-ENABLE IF A VDA IS ENABLED
0376+  0000             ;
0377+  0000             ; VIDEO MODES
0378+  0000             ;
0379+  0000             V80X24		.EQU	0	; ECB-VDU
0380+  0000             V80X25		.EQU	1	; ECB-VDU, ECB-VGA3
0381+  0000             V80X30		.EQU	2	; ECB-VDU, ECB-VGA3
0382+  0000             V80X25B		.EQU	3	; ECB-VDU
0383+  0000             V80X24B		.EQU	4	; ECB-VDU
0384+  0000             V80X43		.EQU	5	; ECB-VGA3
0385+  0000             V80X60		.EQU	6	; ECB-VGA3
0386+  0000             ;
0387+  0000             ; KEYBOARD LAYOUTS
0388+  0000             ;
0389+  0000             KBD_US		.EQU	0	; US ENGLISH
0390+  0000             KBD_DE		.EQU	1	; GERMAN
0391+  0000             ;
0392+  0000             ; EMULATION TYPES
0393+  0000             ;
0394+  0000             EMUTYP_NONE	.EQU	0		; NONE
0395+  0000             EMUTYP_TTY	.EQU	1		; TTY
0396+  0000             EMUTYP_ANSI	.EQU	2		; ANSI
0397+  0000             ;
0398+  0000             ; WATCHDOG TYPES
0399+  0000             ;
0400+  0000             WDOG_NONE	.EQU	0		; NONE
0401+  0000             WDOG_EZZ80	.EQU	1		; EASY Z80 WATCHDOG
0402+  0000             WDOG_SKZ	.EQU	2		; SK Z80 CPU W/ 512K
0403+  0000             ;
0404+  0000             ; SYSTEM SPEED CAPABILITIES
0405+  0000             ;
0406+  0000             SPD_FIXED	.EQU	0		; PLATFORM SPEED FIXED AND CANNOT CHANGE SPEEDS
0407+  0000             SPD_HILO	.EQU	1		; PLATFORM CAN CHANGE BETWEEN TWO SPEEDS
0408+  0000             ;
0409+  0000             ; SYSTEM SPEED CHARACTERISTICS
0410+  0000             ;
0411+  0000             SPD_UNSUP	.EQU	0		; PLATFORM CAN CHANGE SPEEDS BUT IS UNSUPPORTED
0412+  0000             SPD_HIGH	.EQU	1		; PLATFORM CAN CHANGE SPEED, STARTS HIGH
0413+  0000             SPD_LOW		.EQU	2		; PLATFORM CAN CHANGE SPEED, STARTS LOW
0414+  0000             ;
0415+  0000             #INCLUDE "build.inc"		; INCLUDE USER CONFIG, ADD VARIANT, TIMESTAMP, & ROMSIZE
0001++ 0000             ; RomWBW Configured for HEATH FP, 2023-10-23T21:09:13
0002++ 0000             ;
0003++ 0000             #DEFINE		TIMESTAMP	"2023-10-23"
0004++ 0000             #DEFINE		CONFIG		"HEATH_FP"
0005++ 0000             ;
0006++ 0000             #INCLUDE "Config/HEATH_FP.asm"
0001+++0000             ;
0002+++0000             ;==================================================================================================
0003+++0000             ;   HEATHKIT H8 STANDARD CONFIGURATION
0004+++0000             ;==================================================================================================
0005+++0000             ;
0006+++0000             ; THE COMPLETE SET OF DEFAULT CONFIGURATION SETTINGS FOR THIS PLATFORM ARE FOUND IN THE
0007+++0000             ; CFG_<PLT>.ASM INCLUDED FILE WHICH IS FOUND IN THE PARENT DIRECTORY.  THIS FILE CONTAINS
0008+++0000             ; COMMON CONFIGURATION SETTINGS THAT OVERRIDE THE DEFAULTS.  IT IS INTENDED THAT YOU MAKE
0009+++0000             ; YOUR CUSTOMIZATIONS IN THIS FILE AND JUST INHERIT ALL OTHER SETTINGS FROM THE DEFAULTS.
0010+++0000             ; EVEN BETTER, YOU CAN MAKE A COPY OF THIS FILE WITH A NAME LIKE <PLT>_XXX.ASM AND SPECIFY
0011+++0000             ; YOUR FILE IN THE BUILD PROCESS.
0012+++0000             ;
0013+++0000             ; THE SETTINGS BELOW ARE THE SETTINGS THAT ARE MOST COMMONLY MODIFIED FOR THIS PLATFORM.
0014+++0000             ; MANY OF THEM ARE EQUAL TO THE SETTINGS IN THE INCLUDED FILE, SO THEY DON'T REALLY DO
0015+++0000             ; ANYTHING AS IS.  THEY ARE LISTED HERE TO MAKE IT EASY FOR YOU TO ADJUST THE MOST COMMON
0016+++0000             ; SETTINGS.
0017+++0000             ;
0018+++0000             ; N.B., SINCE THE SETTINGS BELOW ARE REDEFINING VALUES ALREADY SET IN THE INCLUDED FILE,
0019+++0000             ; TASM INSISTS THAT YOU USE THE .SET OPERATOR AND NOT THE .EQU OPERATOR BELOW. ATTEMPTING
0020+++0000             ; TO REDEFINE A VALUE WITH .EQU BELOW WILL CAUSE TASM ERRORS!
0021+++0000             ;
0022+++0000             ; PLEASE REFER TO THE CUSTOM BUILD INSTRUCTIONS (README.TXT) IN THE SOURCE DIRECTORY (TWO
0023+++0000             ; DIRECTORIES ABOVE THIS ONE).
0024+++0000             ;
0025+++0000             #DEFINE	BOOT_DEFAULT	"H"		; DEFAULT BOOT LOADER CMD ON <CR> OR AUTO BOOT
0026+++0000             ;
0027+++0000             #include "cfg_heath.asm"
0001+++0000             ;
0002+++0000             ;==================================================================================================
0003+++0000             ;   ROMWBW 2.X CONFIGURATION MASTER
0004+++0000             ;==================================================================================================
0005+++0000             ;
0006+++0000             ; THIS FILE IS *NOT* A REAL CONFIGURATION FILE.	 IT IS A MASTER TEMPLATE FILE
0007+++0000             ; CONTAINING ALL POSSIBLE CONFIGURATION SETTINGS ACROSS ALL PLATFORMS.	IT IS
0008+++0000             ; USED ONLY AS A REFERENCE TO HELP MANAGE THE FULL SET OF POSSIBLE SETTINGS AND
0009+++0000             ; KEEP THINGS CONSISTENT.
0010+++0000             ;
0011+++0000             #DEFINE PLATFORM_NAME "HEATH", " [", CONFIG, "]"
0012+++0000             ;
0013+++0000             #INCLUDE "hbios.inc"
0001+++0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+++0000             ;
0003+++0000             ; HBIOS FUNCTIONS
0004+++0000             ;
0005+++0000             BF_CIO		.EQU	$00
0006+++0000             BF_CIOIN	.EQU	BF_CIO + 0	; CHARACTER INPUT
0007+++0000             BF_CIOOUT	.EQU	BF_CIO + 1	; CHARACTER OUTPUT
0008+++0000             BF_CIOIST	.EQU	BF_CIO + 2	; CHARACTER INPUT STATUS
0009+++0000             BF_CIOOST	.EQU	BF_CIO + 3	; CHARACTER OUTPUT STATUS
0010+++0000             BF_CIOINIT	.EQU	BF_CIO + 4	; INIT/RESET DEVICE/LINE CONFIG
0011+++0000             BF_CIOQUERY	.EQU	BF_CIO + 5	; REPORT DEVICE/LINE CONFIG
0012+++0000             BF_CIODEVICE	.EQU	BF_CIO + 6	; REPORT DEVICE INFO
0013+++0000             ;
0014+++0000             BF_DIO		.EQU	$10
0015+++0000             BF_DIOSTATUS	.EQU	BF_DIO + 0	; DISK STATUS
0016+++0000             BF_DIORESET	.EQU	BF_DIO + 1	; DISK RESET
0017+++0000             BF_DIOSEEK	.EQU	BF_DIO + 2	; DISK SEEK
0018+++0000             BF_DIOREAD	.EQU	BF_DIO + 3	; DISK READ SECTORS
0019+++0000             BF_DIOWRITE	.EQU	BF_DIO + 4	; DISK WRITE SECTORS
0020+++0000             BF_DIOVERIFY	.EQU	BF_DIO + 5	; DISK VERIFY SECTORS
0021+++0000             BF_DIOFORMAT	.EQU	BF_DIO + 6	; DISK FORMAT TRACK
0022+++0000             BF_DIODEVICE	.EQU	BF_DIO + 7	; DISK DEVICE INFO REPORT
0023+++0000             BF_DIOMEDIA	.EQU	BF_DIO + 8	; DISK MEDIA REPORT
0024+++0000             BF_DIODEFMED	.EQU	BF_DIO + 9	; DEFINE DISK MEDIA
0025+++0000             BF_DIOCAP	.EQU	BF_DIO + 10	; DISK CAPACITY REPORT
0026+++0000             BF_DIOGEOM	.EQU	BF_DIO + 11	; DISK GEOMETRY REPORT
0027+++0000             ;
0028+++0000             BF_RTC		.EQU	$20
0029+++0000             BF_RTCGETTIM	.EQU	BF_RTC + 0	; GET TIME
0030+++0000             BF_RTCSETTIM	.EQU	BF_RTC + 1	; SET TIME
0031+++0000             BF_RTCGETBYT	.EQU	BF_RTC + 2	; GET NVRAM BYTE BY INDEX
0032+++0000             BF_RTCSETBYT	.EQU	BF_RTC + 3	; SET NVRAM BYTE BY INDEX
0033+++0000             BF_RTCGETBLK	.EQU	BF_RTC + 4	; GET NVRAM DATA BLOCK
0034+++0000             BF_RTCSETBLK	.EQU	BF_RTC + 5	; SET NVRAM DATA BLOCK
0035+++0000             BF_RTCGETALM	.EQU	BF_RTC + 6	; GET ALARM
0036+++0000             BF_RTCSETALM	.EQU	BF_RTC + 7	; SET ALARM
0037+++0000             BF_RTCDEVICE	.EQU	BF_RTC + 8	; RTC DEVICE INFO REPORT
0038+++0000             ;
0039+++0000             BF_EMU		.EQU	$30		; DEPRECATED
0040+++0000             ;
0041+++0000             BF_VDA		.EQU	$40
0042+++0000             BF_VDAINI	.EQU	BF_VDA + 0	; INITIALIZE VDU
0043+++0000             BF_VDAQRY	.EQU	BF_VDA + 1	; QUERY VDU STATUS
0044+++0000             BF_VDARES	.EQU	BF_VDA + 2	; SOFT RESET VDU
0045+++0000             BF_VDADEV	.EQU	BF_VDA + 3	; DEVICE INFO
0046+++0000             BF_VDASCS	.EQU	BF_VDA + 4	; SET CURSOR STYLE
0047+++0000             BF_VDASCP	.EQU	BF_VDA + 5	; SET CURSOR POSITION
0048+++0000             BF_VDASAT	.EQU	BF_VDA + 6	; SET CHARACTER ATTRIBUTE
0049+++0000             BF_VDASCO	.EQU	BF_VDA + 7	; SET CHARACTER COLOR
0050+++0000             BF_VDAWRC	.EQU	BF_VDA + 8	; WRITE CHARACTER
0051+++0000             BF_VDAFIL	.EQU	BF_VDA + 9	; FILL
0052+++0000             BF_VDACPY	.EQU	BF_VDA + 10	; COPY
0053+++0000             BF_VDASCR	.EQU	BF_VDA + 11	; SCROLL
0054+++0000             BF_VDAKST	.EQU	BF_VDA + 12	; GET KEYBOARD STATUS
0055+++0000             BF_VDAKFL	.EQU	BF_VDA + 13	; FLUSH KEYBOARD BUFFER
0056+++0000             BF_VDAKRD	.EQU	BF_VDA + 14	; READ KEYBOARD
0057+++0000             BF_VDARDC	.EQU	BF_VDA + 15	; READ CHARACTER
0058+++0000             ;
0059+++0000             BF_SND		.EQU	$50
0060+++0000             BF_SNDRESET	.EQU	BF_SND + 0	; RESET SOUND SYSTEM
0061+++0000             BF_SNDVOL	.EQU	BF_SND + 1	; REQUEST SOUND VOL - L CONTAINS VOLUME (255 MAX, 0 SILENT) - SCALED AS REQUIRED BY DRIVER (EG: MAPS TO JUST 4 BIT RESOLUTION FOR SN76489)
0062+++0000             BF_SNDPRD	.EQU	BF_SND + 2	; REQUEST SOUND PERIOD - HL CONTAINS DRIVER SPECIFIC VALUE
0063+++0000             BF_SNDNOTE	.EQU	BF_SND + 3	; REQUEST NOTE - L CONTAINS NOTE - EACH VALUE IS QUARTER NOTE
0064+++0000             BF_SNDPLAY	.EQU	BF_SND + 4	; INITIATE THE REQUESTED SOUND COMMAND
0065+++0000             BF_SNDQUERY	.EQU	BF_SND + 5	; E IS SUBFUNCTION
0066+++0000             BF_SNDDURATION	.EQU	BF_SND + 6	; REQUEST DURATION HL MILLISECONDS
0067+++0000             BF_SNDDEVICE	.EQU	BF_SND + 7	; SOUND DEVICE INFO REQUEST
0068+++0000             ;
0069+++0000             ; BF_SNDQUERY SUBCOMMANDS
0070+++0000             BF_SNDQ_STATUS		.EQU	0
0071+++0000             BF_SNDQ_CHCNT		.EQU	BF_SNDQ_STATUS + 1	; RETURN COUNT OF CHANNELS
0072+++0000             BF_SNDQ_VOLUME		.EQU	BF_SNDQ_STATUS + 2	; 8 BIT NUMBER
0073+++0000             BF_SNDQ_PERIOD		.EQU	BF_SNDQ_STATUS + 3	; 16 BIT NUMBER
0074+++0000             BF_SNDQ_DEV		.EQU	BF_SNDQ_STATUS + 4	; RETURN DEVICE TYPE CODE AND IO PORTS - TYPE IN B, PORTS IN DE, HL
0075+++0000             ;
0076+++0000             BF_SYS		.EQU	$F0
0077+++0000             BF_SYSRESET	.EQU	BF_SYS + 0	; SOFT RESET HBIOS
0078+++0000             BF_SYSVER	.EQU	BF_SYS + 1	; GET HBIOS VERSION
0079+++0000             BF_SYSSETBNK	.EQU	BF_SYS + 2	; SET CURRENT BANK
0080+++0000             BF_SYSGETBNK	.EQU	BF_SYS + 3	; GET CURRENT BANK
0081+++0000             BF_SYSSETCPY	.EQU	BF_SYS + 4	; BANK MEMORY COPY SETUP
0082+++0000             BF_SYSBNKCPY	.EQU	BF_SYS + 5	; BANK MEMORY COPY
0083+++0000             BF_SYSALLOC	.EQU	BF_SYS + 6	; ALLOC HBIOS HEAP MEMORY
0084+++0000             BF_SYSFREE	.EQU	BF_SYS + 7	; FREE HBIOS HEAP MEMORY
0085+++0000             BF_SYSGET	.EQU	BF_SYS + 8	; GET HBIOS INFO
0086+++0000             BF_SYSSET	.EQU	BF_SYS + 9	; SET HBIOS PARAMETERS
0087+++0000             BF_SYSPEEK	.EQU	BF_SYS + 10	; GET A BYTE VALUE FROM ALT BANK
0088+++0000             BF_SYSPOKE	.EQU	BF_SYS + 11	; SET A BYTE VALUE IN ALT BANK
0089+++0000             BF_SYSINT	.EQU	BF_SYS + 12	; MANAGE INTERRUPT VECTORS
0090+++0000             ;
0091+++0000             BF_SYSRES_INT		.EQU	$00	; RESET HBIOS INTERNAL
0092+++0000             BF_SYSRES_WARM		.EQU	$01	; WARM START (RESTART BOOT LOADER)
0093+++0000             BF_SYSRES_COLD		.EQU	$02	; COLD START
0094+++0000             BF_SYSRES_USER		.EQU	$03	; USER RESET REQUEST
0095+++0000             ;
0096+++0000             BF_SYSGET_CIOCNT	.EQU	$00	; GET CHAR UNIT COUNT
0097+++0000             BF_SYSGET_CIOFN		.EQU	$01	; GET CIO UNIT FN/DATA ADR
0098+++0000             BF_SYSGET_DIOCNT	.EQU	$10	; GET DISK UNIT COUNT
0099+++0000             BF_SYSGET_DIOFN		.EQU	$11	; GET DIO UNIT FN/DATA ADR
0100+++0000             BF_SYSGET_RTCCNT	.EQU	$20	; GET RTC UNIT COUNT
0101+++0000             BF_SYSGET_VDACNT	.EQU	$40	; GET VDA UNIT COUNT
0102+++0000             BF_SYSGET_VDAFN		.EQU	$41	; GET VDA UNIT FN/DATA ADR
0103+++0000             BF_SYSGET_SNDCNT	.EQU	$50	; GET VDA UNIT COUNT
0104+++0000             BF_SYSGET_SNDFN		.EQU	$51	; GET SND UNIT FN/DATA ADR
0105+++0000             BF_SYSGET_TIMER		.EQU	$D0	; GET CURRENT TIMER VALUE
0106+++0000             BF_SYSGET_SECS		.EQU	$D1	; GET CURRENT SECONDS VALUE
0107+++0000             BF_SYSGET_BOOTINFO	.EQU	$E0	; GET BOOT INFORMATION
0108+++0000             BF_SYSGET_CPUINFO	.EQU	$F0	; GET CPU INFORMATION
0109+++0000             BF_SYSGET_MEMINFO	.EQU	$F1	; GET MEMORY CAPACTITY INFO
0110+++0000             BF_SYSGET_BNKINFO	.EQU	$F2	; GET BANK ASSIGNMENT INFO
0111+++0000             BF_SYSGET_CPUSPD	.EQU	$F3	; GET CLOCK SPEED & WAIT STATES
0112+++0000             ;
0113+++0000             BF_SYSSET_TIMER		.EQU	$D0	; SET TIMER VALUE
0114+++0000             BF_SYSSET_SECS		.EQU	$D1	; SET SECONDS VALUE
0115+++0000             BF_SYSSET_BOOTINFO	.EQU	$E0	; SET BOOT INFORMATION
0116+++0000             BF_SYSSET_CPUSPD	.EQU	$F3	; SET CLOCK SPEED & WAIT STATES
0117+++0000             ;
0118+++0000             BF_SYSINT_INFO		.EQU	$00	; GET INTERRUPT SYSTEM INFO
0119+++0000             BF_SYSINT_GET		.EQU	$10	; GET INT VECTOR ADDRESS
0120+++0000             BF_SYSINT_SET		.EQU	$20	; SET INT VECTOR ADDRESS
0121+++0000             ;
0122+++0000             CIO_CONSOLE		.EQU	$80	; CIO UNIT NUM FOR CUR CON
0123+++0000             ;
0124+++0000             ; PRIMARY HARDWARE PLATFORMS
0125+++0000             ;
0126+++0000             PLT_SBC		.EQU	1		; SBC ECB Z80 SBC
0127+++0000             PLT_ZETA	.EQU	2		; ZETA Z80 SBC
0128+++0000             PLT_ZETA2	.EQU	3		; ZETA Z80 V2 SBC
0129+++0000             PLT_N8		.EQU	4		; N8 (HOME COMPUTER) Z180 SBC
0130+++0000             PLT_MK4		.EQU	5		; MARK IV
0131+++0000             PLT_UNA		.EQU	6		; UNA BIOS
0132+++0000             PLT_RCZ80	.EQU	7		; RCBUS W/ Z80
0133+++0000             PLT_RCZ180	.EQU	8		; RCBUS W/ Z180
0134+++0000             PLT_EZZ80	.EQU	9		; EASY Z80
0135+++0000             PLT_SCZ180	.EQU	10		; SCZ180
0136+++0000             PLT_DYNO	.EQU	11		; DYNO MICRO-ATX MOTHERBOARD
0137+++0000             PLT_RCZ280	.EQU	12		; RCBUS W/ Z280
0138+++0000             PLT_MBC		.EQU	13		; MULTI BOARD COMPUTER
0139+++0000             PLT_RPH		.EQU	14		; RHYOPHYRE GRAPHICS COMPUTER
0140+++0000             PLT_HEATH	.EQU	15		; HEATHKIT H8 Z80 COMPUTER
0141+++0000             ;
0142+++0000             ; HBIOS GLOBAL ERROR RETURN VALUES
0143+++0000             ;
0144+++0000             ERR_NONE		.EQU	0	; SUCCESS
0145+++0000             ;
0146+++0000             ERR_UNDEF		.EQU	-1	; UNDEFINED ERROR
0147+++0000             ERR_NOTIMPL		.EQU	-2	; FUNCTION NOT IMPLEMENTED
0148+++0000             ERR_NOFUNC		.EQU	-3	; INVALID FUNCTION
0149+++0000             ERR_NOUNIT		.EQU	-4	; INVALID UNIT NUMBER
0150+++0000             ERR_NOMEM		.EQU	-5	; OUT OF MEMORY
0151+++0000             ERR_RANGE		.EQU	-6	; PARAMETER OUT OF RANGE
0152+++0000             ERR_NOMEDIA		.EQU	-7	; MEDIA NOT PRESENT
0153+++0000             ERR_NOHW		.EQU	-8	; HARDWARE NOT PRESENT
0154+++0000             ERR_IO			.EQU	-9	; I/O ERROR
0155+++0000             ERR_READONLY		.EQU	-10	; WRITE REQUEST TO READ-ONLY MEDIA
0156+++0000             ERR_TIMEOUT		.EQU	-11	; DEVICE TIMEOUT
0157+++0000             ERR_BADCFG		.EQU	-12	; INVALID CONFIGURATION
0158+++0000             ERR_INTERNAL		.EQU	-13	; INTERNAL ERROR
0159+++0000             ;
0160+++0000             ; HBIOS DIAG OPTIONS
0161+++0000             ;
0162+++0000             DIAG_PROG	.EQU	0		; PROGRESS BAR
0163+++0000             DIAG_STEP	.EQU	1		; STEP BAR
0164+++0000             DIAG_ASCII	.EQU	2		; 8-BIT ASCII 30H - 39H
0165+++0000             DIAG_BINARY	.EQU	3		; BINARY 00H - 09H
0166+++0000             DIAG_7SEG	.EQU	4		; 7-SEGMENT
0167+++0000             DIAG_FLASH	.EQU	5		; FLASH
0168+++0000             DIAG_TRIG	.EQU	6		; TRIGGER
0169+++0000             ;
0170+++0000             DIAG_DISP	.EQU	DIAG_PROG	; DEFAULT
0171+++0000             ;
0172+++0000             #IF (DIAG_DISP == DIAG_PROG)
0173+++0000             DIAG_00 .EQU 00000000B	
0174+++0000             DIAG_01 .EQU 00000001B 
0175+++0000             DIAG_02 .EQU 00000011B 
0176+++0000             DIAG_03 .EQU 00000111B 
0177+++0000             DIAG_04 .EQU 00001111B 
0178+++0000             DIAG_05 .EQU 00011111B 
0179+++0000             DIAG_06 .EQU 00111111B 
0180+++0000             DIAG_07 .EQU 01111111B 
0181+++0000             DIAG_08 .EQU 11111111B 
0182+++0000             DIAG_09 .EQU 11111111B   
0183+++0000             #ENDIF
0184+++0000             ;
0185+++0000~            #IF (DIAG_DISP == DIAG_STEP)
0186+++0000~            DIAG_00 .EQU 00000000B	
0187+++0000~            DIAG_01 .EQU 00000001B 
0188+++0000~            DIAG_02 .EQU 00000010B 
0189+++0000~            DIAG_03 .EQU 00000100B 
0190+++0000~            DIAG_04 .EQU 00001000B 
0191+++0000~            DIAG_05 .EQU 00010000B 
0192+++0000~            DIAG_06 .EQU 00100000B 
0193+++0000~            DIAG_07 .EQU 01000000B 
0194+++0000~            DIAG_08 .EQU 10000000B
0195+++0000~            DIAG_09 .EQU 11111111B
0196+++0000             #ENDIF
0197+++0000             ;
0198+++0000~            #IF (DIAG_DISP == DIAG_ASCII)
0199+++0000~            DIAG_00 .EQU '0'	
0200+++0000~            DIAG_01 .EQU '1'
0201+++0000~            DIAG_02 .EQU '2' 
0202+++0000~            DIAG_03 .EQU '3' 
0203+++0000~            DIAG_04 .EQU '4'
0204+++0000~            DIAG_05 .EQU '5'
0205+++0000~            DIAG_06 .EQU '6' 
0206+++0000~            DIAG_07 .EQU '7'
0207+++0000~            DIAG_08 .EQU '8' 
0208+++0000~            DIAG_09 .EQU '9' 
0209+++0000             #ENDIF
0210+++0000             ;
0211+++0000~            #IF (DIAG_DISP == DIAG_BINARY)
0212+++0000~            DIAG_00 .EQU 0	
0213+++0000~            DIAG_01 .EQU 1
0214+++0000~            DIAG_02 .EQU 2
0215+++0000~            DIAG_03 .EQU 3
0216+++0000~            DIAG_04 .EQU 4
0217+++0000~            DIAG_05 .EQU 5
0218+++0000~            DIAG_06 .EQU 6
0219+++0000~            DIAG_07 .EQU 7
0220+++0000~            DIAG_08 .EQU 8
0221+++0000~            DIAG_09 .EQU 9 
0222+++0000             #ENDIF
0223+++0000             ;
0224+++0000~            #IF (DIAG_DISP == DIAG_7SEG)
0225+++0000~            ;             abcdefg
0226+++0000~            DIAG_00 .EQU 00000000B ; BLANK
0227+++0000~            DIAG_01 .EQU 01111110B ; 0
0228+++0000~            DIAG_02 .EQU 00110000B ; 1
0229+++0000~            DIAG_03 .EQU 01101101B ; 2
0230+++0000~            DIAG_04 .EQU 01111001B ; 3 
0231+++0000~            DIAG_05 .EQU 00110011B ; 4
0232+++0000~            DIAG_06 .EQU 01011011B ; 5
0233+++0000~            DIAG_07 .EQU 00011111B ; 6 
0234+++0000~            DIAG_08 .EQU 01110000B ; 7
0235+++0000~            DIAG_09 .EQU 01111111B ; 8
0236+++0000~            DIAG_10 .EQU 01110011B ; 9
0237+++0000             #ENDIF
0238+++0000             ;
0239+++0000~            #IF (DIAG_DISP == DIAG_FLASH)
0240+++0000~            DIAG_00 .EQU 00000000B ; OFF	
0241+++0000~            DIAG_01 .EQU 11111111B ; ON
0242+++0000~            DIAG_02 .EQU 00000000B ; OFF	
0243+++0000~            DIAG_03 .EQU 11111111B ; ON
0244+++0000~            DIAG_04 .EQU 00000000B ; OFF	
0245+++0000~            DIAG_05 .EQU 11111111B ; ON
0246+++0000~            DIAG_06 .EQU 00000000B ; OFF	
0247+++0000~            DIAG_07 .EQU 11111111B ; ON
0248+++0000~            DIAG_08 .EQU 00000000B ; OFF	
0249+++0000~            DIAG_09 .EQU 11111111B ; ON 
0250+++0000             #ENDIF
0251+++0000             ;
0252+++0000~            #IF (DIAG_DISP == DIAG_TRIG)
0253+++0000~            DIAG_00 .EQU 11111111B ; ON	
0254+++0000~            DIAG_01 .EQU 11111111B ; ON
0255+++0000~            DIAG_02 .EQU 11111111B ; ON
0256+++0000~            DIAG_03 .EQU 11111111B ; ON
0257+++0000~            DIAG_04 .EQU 11111111B ; ON
0258+++0000~            DIAG_05 .EQU 11111111B ; ON
0259+++0000~            DIAG_06 .EQU 11111111B ; ON
0260+++0000~            DIAG_07 .EQU 11111111B ; ON
0261+++0000~            DIAG_08 .EQU 11111111B ; ON
0262+++0000~            DIAG_09 .EQU 11111111B ; ON 
0263+++0000             #ENDIF
0264+++0000             ;
0265+++0000             ; MEDIA ID VALUES
0266+++0000             ;
0267+++0000             MID_NONE	.EQU	0
0268+++0000             MID_MDROM	.EQU	1
0269+++0000             MID_MDRAM	.EQU	2
0270+++0000             MID_RF		.EQU	3
0271+++0000             MID_HD		.EQU	4
0272+++0000             MID_FD720	.EQU	5
0273+++0000             MID_FD144	.EQU	6
0274+++0000             MID_FD360	.EQU	7
0275+++0000             MID_FD120	.EQU	8
0276+++0000             MID_FD111	.EQU	9
0277+++0000             MID_HDNEW	.EQU	10
0278+++0000             ;
0279+++0000             ; CHAR DEVICE IDS
0280+++0000             ;
0281+++0000             CIODEV_UART	.EQU	$00
0282+++0000             CIODEV_ASCI	.EQU	$10
0283+++0000             CIODEV_TERM	.EQU	$20
0284+++0000             CIODEV_PRPCON	.EQU	$30
0285+++0000             CIODEV_PPPCON	.EQU	$40
0286+++0000             CIODEV_SIO	.EQU	$50
0287+++0000             CIODEV_ACIA	.EQU	$60
0288+++0000             CIODEV_PIO	.EQU	$70
0289+++0000             CIODEV_UF	.EQU	$80
0290+++0000             CIODEV_DUART	.EQU	$90
0291+++0000             CIODEV_Z2U	.EQU	$A0
0292+++0000             CIODEV_LPT	.EQU	$B0
0293+++0000             ;
0294+++0000             ; SUB TYPES OF CHAR DEVICES
0295+++0000             ;
0296+++0000             ;00 RS-232
0297+++0000             ;01 TERMINAL
0298+++0000             ;02 PARALLEL PORT
0299+++0000             ;03 UNUSED
0300+++0000             ;
0301+++0000             ; DISK DEVICE IDS
0302+++0000             ;
0303+++0000             DIODEV_MD	.EQU	$00
0304+++0000             DIODEV_FD	.EQU	$10
0305+++0000             DIODEV_RF	.EQU	$20
0306+++0000             DIODEV_IDE	.EQU	$30
0307+++0000             DIODEV_ATAPI	.EQU	$40
0308+++0000             DIODEV_PPIDE	.EQU	$50
0309+++0000             DIODEV_SD	.EQU	$60
0310+++0000             DIODEV_PRPSD	.EQU	$70
0311+++0000             DIODEV_PPPSD	.EQU	$80
0312+++0000             DIODEV_HDSK	.EQU	$90
0313+++0000             ;
0314+++0000             ; RTC DEVICE IDS
0315+++0000             ;
0316+++0000             RTCDEV_DS	.EQU	$00		; DS1302
0317+++0000             RTCDEV_BQ	.EQU	$10		; BQ4845P
0318+++0000             RTCDEV_SIMH	.EQU	$20		; SIMH
0319+++0000             RTCDEV_INT	.EQU	$30		; PERIODIC INT TIMER
0320+++0000             RTCDEV_DS7	.EQU	$40		; DS1307 (I2C)
0321+++0000             RTCDEV_RP5	.EQU	$50		; RP5C01
0322+++0000             ;
0323+++0000             ; VIDEO DEVICE IDS
0324+++0000             ;
0325+++0000             VDADEV_VDU	.EQU	$00		; ECB VDU - MOTOROLA 6545
0326+++0000             VDADEV_CVDU	.EQU	$10		; ECB COLOR VDU - MOS 8563
0327+++0000             VDADEV_GDC	.EQU	$20		; GRAPHICS DISPLAY CTLR - UPD7220
0328+++0000             VDADEV_TMS	.EQU	$30		; N8 ONBOARD VDA SUBSYSTEM - TMS 9918
0329+++0000             VDADEV_VGA	.EQU	$40		; ECB VGA3 - HITACHI HD6445
0330+++0000             ;VDADEV_V9958	.EQU	$50		; V9958 VDU
0331+++0000             ;
0332+++0000             ; SOUND DEVICE IDS
0333+++0000             ;
0334+++0000             SNDDEV_SN76489	.EQU	$00
0335+++0000             SNDDEV_AY38910	.EQU	$10
0336+++0000             SNDDEV_BITMODE	.EQU	$20
0337+++0000             SNDDEV_YM2612	.EQU	$30
0338+++0000             ;
0339+++0000             ; HBIOS CONTROL BLOCK OFFSETS
0340+++0000             ; WARNING: THESE OFFSETS WILL CHANGE SIGNIFICANTLY BETWEEN RELEASES
0341+++0000             ;          IT IS STRONGLY RECOMMENDED THAT YOU DO NOT USE THEM!
0342+++0000             ;
0343+++0000             HCB_LOC		.EQU	$100		; LOCATION OF HCB IN HBIOS BANK
0344+++0000             HCB_SIZ		.EQU	$100		; SIZE OF HCB DATA BLOCK
0345+++0000             ;
0346+++0000             HCB_MARKER	.EQU	$03		; MARKER ('W',~'W') (WORD)
0347+++0000             HCB_VERSION	.EQU	$05		; HBIOS VERSION NUM
0348+++0000             HCB_PLATFORM	.EQU	$07		; PLATFORM ID
0349+++0000             HCB_CPUMHZ	.EQU	$08		; CPU SPEED IN MHZ (BYTE)
0350+++0000             HCB_CPUKHZ	.EQU	$09		; CPU SPEED IN KHZ (WORD)
0351+++0000             HCB_RAMBANKS	.EQU	$0B		; TOTAL SIZE OF RAM IN 32K BANKS (BYTE)
0352+++0000             HCB_ROMBANKS	.EQU	$0C		; TOTAL SIZE OF ROM IN 32K BANKS (BYTE)
0353+++0000             HCB_BOOTVOL	.EQU	$0D		; BOOT VOLUME, MSB=DEV/UNIT, LSB=LU (WORD)
0354+++0000             HCB_BOOTBID	.EQU	$0F		; BANK ID OF ROM PAGE BOOTED (BYTE)
0355+++0000             HCB_SERDEV	.EQU	$10		; PRIMARY SERIAL DEVICE/UNIT (BYTE)
0356+++0000             HCB_CRTDEV	.EQU	$11		; CRT DISPLAY DEVICE/UNIT (BYTE)
0357+++0000             HCB_CONDEV	.EQU	$12		; ACTIVE CONSOLE DEVICE/UNIT (BYTE)
0358+++0000             HCB_DIAGLVL	.EQU	$13		; HBIOS DIAGNOSTIC LEVEL (BYTE)
0359+++0000             ;
0360+++0000             HCB_HEAP	.EQU	$20		; DWORD ADDRESS OF START OF HEAP
0361+++0000             HCB_HEAPTOP	.EQU	$22		; DWORD ADDRESS OF TOP OF HEAP
0362+++0000             ;
0363+++0000             ; MEMORY BANK IDS (ONE BYTE EACH)
0364+++0000             HCB_BIDCOM	.EQU	$D8		; COMMON BANK (UPPER 32K)
0365+++0000             HCB_BIDUSR	.EQU	$D9		; USER BANK (TPA)
0366+++0000             HCB_BIDBIOS	.EQU	$DA		; BIOS BANK (HBIOS, UBIOS)
0367+++0000             HCB_BIDAUX	.EQU	$DB		; AUX BANK (BPBIOS)
0368+++0000             HCB_BIDRAMD0	.EQU	$DC		; FIRST BANK OF RAM DRIVE
0369+++0000             HCB_BIDRAMDN	.EQU	$DD		; LAST BANK OF RAM DRIVE
0370+++0000             HCB_BIDROMD0	.EQU	$DE		; FIRST BANK OF ROM DRIVE
0371+++0000             HCB_BIDROMDN	.EQU	$DF		; LAST BANK OF ROM DRIVE
0372+++0000             ;
0373+++0000             ; HBIOS PROXY COMMON DATA BLOCK
0374+++0000             ; EXACTLY 32 BYTES AT $FFE0-$FFFF
0375+++0000             ;
0376+++0000             HBX_XFC		.EQU	$10000 - $20		; HBIOS PROXY INTERFACE AREA, 32 BYTES FIXED
0377+++0000             ;
0378+++0000             HBX_XFCDAT	.EQU	HBX_XFC			; DATA PORTION OF HBIOS PROXY INTERFACE AREA
0379+++0000             HB_CURBNK	.EQU	HBX_XFCDAT + 0		; CURRENTLY ACTIVE LOW MEMORY BANK ID
0380+++0000             HB_INVBNK	.EQU	HBX_XFCDAT + 1		; BANK ACTIVE AT TIME OF HBIOS CALL INVOCATION
0381+++0000             HB_SRCADR	.EQU	HBX_XFCDAT + 2		; BNKCPY: DESTINATION BANK ID
0382+++0000             HB_SRCBNK	.EQU	HBX_XFCDAT + 4		; BNKCPY: SOURCE BANK ID
0383+++0000             HB_DSTADR	.EQU	HBX_XFCDAT + 5		; BNKCPY: DESTINATION ADDRESS
0384+++0000             HB_DSTBNK	.EQU	HBX_XFCDAT + 7		; BNKCPY: SOURCE ADDRESS
0385+++0000             HB_CPYLEN	.EQU	HBX_XFCDAT + 8		; BNKCPY: COPY LENGTH
0386+++0000             HB_RTCVAL	.EQU	HBX_XFCDAT + 14		; RTC LATCH SHADOW VALUE
0387+++0000             HB_LOCK		.EQU	HBX_XFCDAT + 15		; INVOKE: HBIOS MUTEX LOCK
0388+++0000             ;
0389+++0000             HBX_XFCFNS	.EQU	HBX_XFC + $10		; JUMP TABLE PORTION OF HBIOS PROXY INTERFACE AREA
0390+++0000             HB_INVOKE	.EQU	HBX_XFCFNS + (0 * 3)	; INVOKE HBIOS FUNCTION
0391+++0000             HB_BNKSEL	.EQU	HBX_XFCFNS + (1 * 3)	; SELECT LOW MEMORY BANK ID
0392+++0000             HB_BNKCPY	.EQU	HBX_XFCFNS + (2 * 3)	; INTERBANK MEMORY COPY
0393+++0000             HB_BNKCALL	.EQU	HBX_XFCFNS + (3 * 3)	; INTERBANK FUNCTION CALL
0394+++0000             ;HB_LOC		.EQU	HBX_XFCFNS + 12		; ADDRESS OF HBIOS PROXY START (DEPRECATED)
0395+++0000             HB_IDENT	.EQU	HBX_XFCFNS + 14		; POINTER TO HBIOS IDENT DATA BLOCK
0014+++0000             ;
0015+++0000             PLATFORM	.EQU	PLT_HEATH	; PLT_[SBC|ZETA|ZETA2|N8|MK4|UNA|RCZ80|RCZ180|EZZ80|SCZ180|DYNO|RCZ280|MBC|RPH|HEATH]
0016+++0000             CPUFAM		.EQU	CPU_Z80		; CPU FAMILY: CPU_[Z80|Z180|Z280]
0017+++0000             BIOS		.EQU	BIOS_WBW	; HARDWARE BIOS: BIOS_[WBW|UNA]
0018+++0000             BATCOND		.EQU	FALSE		; ENABLE LOW BATTERY WARNING MESSAGE
0019+++0000             HBIOS_MUTEX	.EQU	FALSE		; ENABLE REENTRANT CALLS TO HBIOS (ADDS OVERHEAD)
0020+++0000             USELZSA2	.EQU	TRUE		; ENABLE FONT COMPRESSION
0021+++0000             TICKFREQ	.EQU	50		; DESIRED PERIODIC TIMER INTERRUPT FREQUENCY (HZ)
0022+++0000             ;
0023+++0000             BOOT_TIMEOUT	.EQU	-1		; AUTO BOOT TIMEOUT IN SECONDS, -1 TO DISABLE, 0 FOR IMMEDIATE
0024+++0000             BOOT_DELAY	.EQU	0		; FIXED BOOT DELAY IN SECONDS PRIOR TO CONSOLE OUTPUT
0025+++0000             ;
0026+++0000             CPUSPDCAP	.EQU	SPD_FIXED	; CPU SPEED CHANGE CAPABILITY SPD_FIXED|SPD_HILO
0027+++0000             CPUSPDDEF	.EQU	SPD_HIGH	; CPU SPEED DEFAULT SPD_UNSUP|SPD_HIGH|SPD_LOW
0028+++0000             CPUOSC		.EQU	16384000	; CPU OSC FREQ IN MHZ
0029+++0000             INTMODE		.EQU	1		; INTERRUPTS: 0=NONE, 1=MODE 1, 2=MODE 2, 3=MODE 3 (Z280)
0030+++0000             DEFSERCFG	.EQU	SER_115200_8N1	; DEFAULT SERIAL LINE CONFIG (SEE STD.ASM)
0031+++0000             ;DEFSERCFG	.EQU	SER_9600_8N1	; DEFAULT SERIAL LINE CONFIG (SEE STD.ASM)
0032+++0000             ;
0033+++0000             RAMSIZE		.EQU	512		; SIZE OF RAM IN KB (MUST MATCH YOUR HARDWARE!!!)
0034+++0000             ROMSIZE		.EQU	512		; SIZE OF ROM IN KB (MUST MATCH YOUR HARDWARE!!!)
0035+++0000             ROMSIZE_CHK	.EQU	0		; ROMSIZE VALUE VERIFICATION (0=DISABLED)
0036+++0000             MEMMGR		.EQU	MM_Z2		; MEMORY MANAGER: MM_[SBC|Z2|N8|Z180|Z280|MBC|RPH]
0037+++0000             MPGSEL_0	.EQU	$78		; Z2 MEM MGR BANK 0 PAGE SELECT REG (WRITE ONLY)
0038+++0000             MPGSEL_1	.EQU	$79		; Z2 MEM MGR BANK 1 PAGE SELECT REG (WRITE ONLY)
0039+++0000             MPGSEL_2	.EQU	$7A		; Z2 MEM MGR BANK 2 PAGE SELECT REG (WRITE ONLY)
0040+++0000             MPGSEL_3	.EQU	$7B		; Z2 MEM MGR BANK 3 PAGE SELECT REG (WRITE ONLY)
0041+++0000             MPGENA		.EQU	$7C		; Z2 MEM MGR PAGING ENABLE REGISTER (BIT 0, WRITE ONLY)
0042+++0000             ;
0043+++0000             Z180_BASE	.EQU	$40		; Z180: I/O BASE ADDRESS FOR INTERNAL REGISTERS
0044+++0000             Z180_CLKDIV	.EQU	1		; Z180: CHK DIV: 0=OSC/2, 1=OSC, 2=OSC*2
0045+++0000             Z180_MEMWAIT	.EQU	0		; Z180: MEMORY WAIT STATES (0-3)
0046+++0000             Z180_IOWAIT	.EQU	1		; Z180: I/O WAIT STATES TO ADD ABOVE 1 W/S BUILT-IN (0-3)
0047+++0000             Z180_TIMER	.EQU	FALSE		; Z180: ENABLE Z180 SYSTEM PERIODIC TIMER
0048+++0000             ;
0049+++0000             Z280_MEMLOWAIT	.EQU	0		; Z280: LOW 8MB MEMORY WAIT STATES (0-3)
0050+++0000             Z280_MEMHIWAIT	.EQU	0		; Z280: HIGH 8MB MEMORY WAIT STATES (0-3)
0051+++0000             Z280_IOWAIT	.EQU	1		; Z280: I/O WAIT STATES TO ADD ABOVE 1 W/S BUILT-IN (0-3)
0052+++0000             Z280_INTWAIT	.EQU	0		; Z280: INT ACK WAIT STATUS (0-3)
0053+++0000             Z280_TIMER	.EQU	FALSE		; Z280: ENABLE INTERNAL Z280 SYSTEM PERIODIC TIMER
0054+++0000             ;
0055+++0000             N8_PPI0		.EQU	$80		; N8: FIRST PARALLEL PORT REGISTERS BASE ADR
0056+++0000             N8_PPI1		.EQU	$84		; N8: SECOND PARALLEL PORT REGISTERS BASE ADR
0057+++0000             N8_RTC		.EQU	$88		; N8: RTC LATCH REGISTER ADR
0058+++0000             N8_ACR		.EQU	$94		; N8: AUXILLARY CONTROL REGISTER (ACR) ADR
0059+++0000             N8_RMAP		.EQU	$96		; N8: ROM PAGE REGISTER ADR
0060+++0000             N8_DEFACR	.EQU	$1B		; N8: AUX CTL REGISTER DEFAULT VALUE (QUIESCIENT STATE)
0061+++0000             ;
0062+++0000             RPH_PPI0	.EQU	$88		; RPH: FIRST PARALLEL PORT REGISTERS BASE ADR
0063+++0000             RPH_RTC		.EQU	$84		; RPH: RTC LATCH REGISTER ADR
0064+++0000             RPH_ACR		.EQU	$80		; RPH: AUXILLARY CONTROL REGISTER (ACR) ADR
0065+++0000             RPH_DEFACR	.EQU	$00		; RPH: AUX CTL REGISTER DEFAULT VALUE (QUIESCIENT STATE)
0066+++0000             ;
0067+++0000             MK4_IDE		.EQU	$80		; MK4: IDE REGISTERS BASE ADR
0068+++0000             MK4_XAR		.EQU	$88		; MK4: EXTERNAL ADDRESS REGISTER (XAR) ADR
0069+++0000             MK4_SD		.EQU	$89		; MK4: SD CARD CONTROL REGISTER ADR
0070+++0000             MK4_RTC		.EQU	$8A		; MK4: RTC LATCH REGISTER ADR
0071+++0000             ;
0072+++0000             RTCIO		.EQU	$70		; RTC LATCH REGISTER ADR
0073+++0000             ;
0074+++0000             KIOENABLE	.EQU	FALSE		; ENABLE ZILOG KIO SUPPORT
0075+++0000             KIOBASE		.EQU	$80		; KIO BASE I/O ADDRESS
0076+++0000             ;
0077+++0000             CTCENABLE	.EQU	FALSE		; ENABLE ZILOG CTC SUPPORT
0078+++0000             CTCDEBUG	.EQU	FALSE		; ENABLE CTC DRIVER DEBUG OUTPUT
0079+++0000             CTCBASE		.EQU	$B0		; CTC BASE I/O ADDRESS
0080+++0000             CTCTIMER	.EQU	FALSE		; ENABLE CTC PERIODIC TIMER
0081+++0000             CTCMODE		.EQU	CTCMODE_CTR	; CTC MODE: CTCMODE_[NONE|CTR|TIM16|TIM256]
0082+++0000             CTCPRE		.EQU	256		; PRESCALE CONSTANT (1-256)
0083+++0000             CTCPRECH	.EQU	2		; PRESCALE CHANNEL (0-3)
0084+++0000             CTCTIMCH	.EQU	3		; TIMER CHANNEL (0-3)
0085+++0000             CTCOSC		.EQU	614400		; CTC CLOCK FREQUENCY
0086+++0000             ;
0087+++0000             EIPCENABLE	.EQU	FALSE		; EIPC: ENABLE Z80 EIPC (Z84C15) INITIALIZATION
0088+++0000             ;
0089+++0000             SKZENABLE	.EQU	FALSE		; ENABLE SERGEY'S Z80-512K FEATURES
0090+++0000             SKZDIV		.EQU	DIV_1		; UART CLK (CLK2) DIVIDER FOR Z80-512K
0091+++0000             ;
0092+++0000             WDOGMODE	.EQU	WDOG_NONE	; WATCHDOG MODE: WDOG_[NONE|EZZ80|SKZ]
0093+++0000             WDOGIO		.EQU	$6F		; WATCHDOG REGISTER ADR
0094+++0000             ;
0095+++0000             DIAGENABLE	.EQU	FALSE		; ENABLES OUTPUT TO 8 BIT LED DIAGNOSTIC PORT
0096+++0000             DIAGPORT	.EQU	$00		; DIAGNOSTIC PORT ADDRESS
0097+++0000             DIAGDISKIO	.EQU	TRUE		; ENABLES DISK I/O ACTIVITY ON DIAGNOSTIC LEDS
0098+++0000             DIAGLVL		.EQU	DL_CRITICAL	; ERROR LEVEL REPORTING
0099+++0000             ;
0100+++0000             LEDENABLE	.EQU	FALSE		; ENABLES STATUS LED (SINGLE LED)
0101+++0000             LEDMODE		.EQU	LEDMODE_STD	; LEDMODE_[STD|RTC]
0102+++0000             LEDPORT		.EQU	$0E		; STATUS LED PORT ADDRESS
0103+++0000             LEDDISKIO	.EQU	TRUE		; ENABLES DISK I/O ACTIVITY ON STATUS LED
0104+++0000             ;
0105+++0000             DSKYENABLE	.EQU	FALSE		; ENABLES DSKY
0106+++0000             DSKYMODE	.EQU	DSKYMODE_V1	; DSKY VERSION: DSKYMODE_[V1|NG]
0107+++0000             DSKYPPIBASE	.EQU	$60		; BASE I/O ADDRESS OF DSKY PPI
0108+++0000             DSKYOSC		.EQU	3000000		; OSCILLATOR FREQ FOR DSKYNG (IN HZ)
0109+++0000             ;
0110+++0000             H8FPENABLE	.EQU	FALSE		; ENABLES HEATHKIT H8 FRONT PANEL SUPPORT
0111+++0000             ;
0112+++0000             BOOTCON		.EQU	0		; BOOT CONSOLE DEVICE
0113+++0000             CRTACT		.EQU	FALSE		; ACTIVATE CRT (VDU,CVDU,PROPIO,ETC) AT STARTUP
0114+++0000             VDAEMU		.EQU	EMUTYP_ANSI	; VDA EMULATION: EMUTYP_[TTY|ANSI]
0115+++0000             VDAEMU_SERKBD	.EQU	$FF		; VDA EMULATION: SERIAL KBD UNIT #, OR $FF FOR HW KBD
0116+++0000             ANSITRACE	.EQU	1		; ANSI DRIVER TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0117+++0000             PPKTRACE	.EQU	1		; PPK DRIVER TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0118+++0000             KBDTRACE	.EQU	1		; KBD DRIVER TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0119+++0000             PPKKBLOUT	.EQU	KBD_US		; PPK KEYBOARD LANGUAGE: KBD_[US|DE]
0120+++0000             KBDKBLOUT	.EQU	KBD_US		; KBD KEYBOARD LANGUAGE: KBD_[US|DE]
0121+++0000             MKYENABLE	.EQU	FALSE		; MSX 8255 PPI KEYBOARD COMPATIBLE DRIVER (REQUIRES TMS VDA DRIVER)
0122+++0000             MKYKBLOUT	.EQU	KBD_US		; KBD KEYBOARD LANGUAGE: KBD_[US|DE]
0123+++0000             ;
0124+++0000             DSRTCENABLE	.EQU	FALSE		; DSRTC: ENABLE DS-1302 CLOCK DRIVER (DSRTC.ASM)
0125+++0000             DSRTCMODE	.EQU	DSRTCMODE_STD	; DSRTC: OPERATING MODE: DSRTC_[STD|MFPIC]
0126+++0000             DSRTCCHG	.EQU	FALSE		; DSRTC: FORCE BATTERY CHARGE ON (USE WITH CAUTION!!!)
0127+++0000             ;
0128+++0000             DS1501RTCENABLE	.EQU	FALSE		; DS1501RTC: ENABLE DS-1501 CLOCK DRIVER (DS1501RTC.ASM)
0129+++0000             DS1501RTC_BASE	.EQU	$50		; DS1501RTC: I/O BASE ADDRESS
0130+++0000             ;
0131+++0000             BQRTCENABLE	.EQU	FALSE		; BQRTC: ENABLE BQ4845 CLOCK DRIVER (BQRTC.ASM)
0132+++0000             BQRTC_BASE	.EQU	$50		; BQRTC: I/O BASE ADDRESS
0133+++0000             ;
0134+++0000             INTRTCENABLE	.EQU	FALSE		; ENABLE PERIODIC INTERRUPT CLOCK DRIVER (INTRTC.ASM)
0135+++0000             ;
0136+++0000             RP5RTCENABLE	.EQU	FALSE		; RP5C01 RTC BASED CLOCK (RP5RTC.ASM)
0137+++0000             ;
0138+++0000             HTIMENABLE	.EQU	FALSE		; ENABLE SIMH TIMER SUPPORT
0139+++0000             SIMRTCENABLE	.EQU	FALSE		; ENABLE SIMH CLOCK DRIVER (SIMRTC.ASM)
0140+++0000             ;
0141+++0000             DS7RTCENABLE	.EQU	FALSE		; DS7RTC: ENABLE DS-1307 I2C CLOCK DRIVER (DS7RTC.ASM)
0142+++0000             DS7RTCMODE	.EQU	DS7RTCMODE_PCF	; DS7RTC: OPERATING MODE: DS7RTC_[PCF]
0143+++0000             ;
0144+++0000             DUARTENABLE	.EQU	FALSE		; DUART: ENABLE 2681/2692 SERIAL DRIVER (DUART.ASM)
0145+++0000             DUARTCNT	.EQU	1		; DUART: NUMBER OF CHIPS TO DETECT (1-2)
0146+++0000             DUART0BASE	.EQU	$A0		; DUART 0: BASE ADDRESS OF CHIP
0147+++0000             DUART0ACFG	.EQU	DEFSERCFG	; DUART 0A: SERIAL LINE CONFIG
0148+++0000             DUART0BCFG	.EQU	DEFSERCFG	; DUART 0B: SERIAL LINE CONFIG
0149+++0000             DUART1BASE	.EQU	$40		; DUART 1: BASE ADDRESS OF CHIP
0150+++0000             DUART1ACFG	.EQU	DEFSERCFG	; DUART 1A: SERIAL LINE CONFIG
0151+++0000             DUART1BCFG	.EQU	DEFSERCFG	; DUART 1B: SERIAL LINE CONFIG
0152+++0000             ;
0153+++0000             UARTENABLE	.EQU	TRUE		; UART: ENABLE 8250/16550-LIKE SERIAL DRIVER (UART.ASM)
0154+++0000             UARTOSC		.EQU	1843200		; UART: OSC FREQUENCY IN MHZ
0155+++0000             UARTINTS	.EQU	FALSE		; UART: INCLUDE INTERRUPT SUPPORT UNDER IM1/2/3
0156+++0000             UARTCFG		.EQU	DEFSERCFG	; UART: LINE CONFIG FOR UART PORTS
0157+++0000             UARTCASSPD	.EQU	SER_300_8N1	; UART: ECB CASSETTE UART DEFAULT SPEED
0158+++0000             UARTSBC		.EQU	FALSE		; UART: AUTO-DETECT SBC/ZETA ONBOARD UART
0159+++0000             UARTSBCFORCE	.EQU	FALSE		; UART: FORCE DETECTION OF SBC UART (FOR SIMH)
0160+++0000             UARTCAS		.EQU	FALSE		; UART: AUTO-DETECT ECB CASSETTE UART
0161+++0000             UARTMFP		.EQU	FALSE		; UART: AUTO-DETECT MF/PIC UART
0162+++0000             UART4		.EQU	FALSE		; UART: AUTO-DETECT 4UART UART
0163+++0000             UARTRC		.EQU	FALSE		; UART: AUTO-DETECT RC UART
0164+++0000             UARTDUAL	.EQU	FALSE		; UART: AUTO-DETECT DUAL UART
0165+++0000             UARTHEATH	.EQU	TRUE		; UART: HEATHKIT H8
0166+++0000             ;
0167+++0000             ASCIENABLE	.EQU	FALSE		; ASCI: ENABLE Z180 ASCI SERIAL DRIVER (ASCI.ASM)
0168+++0000             ASCIINTS	.EQU	TRUE		; ASCI: INCLUDE INTERRUPT SUPPORT UNDER IM1/2/3
0169+++0000             ASCISWAP	.EQU	FALSE		; ASCI: SWAP CHANNELS
0170+++0000             ASCIBOOT	.EQU	0		; ASCI: REBOOT ON RCV CHAR (0=DISABLED)
0171+++0000             ASCI0CFG	.EQU	DEFSERCFG	; ASCI 0: SERIAL LINE CONFIG
0172+++0000             ASCI1CFG	.EQU	DEFSERCFG	; ASCI 1: SERIAL LINE CONFIG
0173+++0000             ;
0174+++0000             Z2UENABLE	.EQU	FALSE		; Z2U: ENABLE Z280 UART SERIAL DRIVER (Z2U.ASM)
0175+++0000             Z2UOSC		.EQU	1843200		; Z2U: OSC FREQUENCY IN MHZ
0176+++0000             Z2UOSCEXT	.EQU	TRUE		; Z2U: USE EXTERNAL OSCILLATOR
0177+++0000             Z2U0BASE	.EQU	$10		; Z2U 0: BASE I/O ADDRESS
0178+++0000             Z2U0CFG		.EQU	DEFSERCFG	; Z2U 0: SERIAL LINE CONFIG
0179+++0000             Z2U0HFC		.EQU	FALSE		; Z2U 0: ENABLE HARDWARE FLOW CONTROL
0180+++0000             ;
0181+++0000             ACIAENABLE	.EQU	FALSE		; ACIA: ENABLE MOTOROLA 6850 ACIA DRIVER (ACIA.ASM)
0182+++0000             ACIADEBUG	.EQU	FALSE		; ACIA: ENABLE DEBUG OUTPUT
0183+++0000             ACIACNT		.EQU	1		; ACIA: NUMBER OF CHIPS TO DETECT (1-2)
0184+++0000             ACIA0BASE	.EQU	$80		; ACIA 0: REGISTERS BASE ADR
0185+++0000             ACIA0CLK	.EQU	CPUOSC		; ACIA 0: OSC FREQ IN HZ
0186+++0000             ACIA0DIV	.EQU	1		; ACIA 0: SERIAL CLOCK DIVIDER
0187+++0000             ACIA0CFG	.EQU	DEFSERCFG	; ACIA 0: SERIAL LINE CONFIG  (SEE STD.ASM)
0188+++0000             ACIA1BASE	.EQU	$40		; ACIA 1: REGISTERS BASE ADR
0189+++0000             ACIA1CLK	.EQU	CPUOSC		; ACIA 1: OSC FREQ IN HZ
0190+++0000             ACIA1DIV	.EQU	1		; ACIA 1: SERIAL CLOCK DIVIDER
0191+++0000             ACIA1CFG	.EQU	DEFSERCFG	; ACIA 1: SERIAL LINE CONFIG  (SEE STD.ASM)
0192+++0000             ;
0193+++0000             SIOENABLE	.EQU	FALSE		; SIO: ENABLE ZILOG SIO SERIAL DRIVER (SIO.ASM)
0194+++0000             SIODEBUG	.EQU	FALSE		; SIO: ENABLE DEBUG OUTPUT
0195+++0000             SIOBOOT		.EQU	0		; SIO: REBOOT ON RCV CHAR (0=DISABLED)
0196+++0000             SIOCNT		.EQU	2		; SIO: NUMBER OF CHIPS TO DETECT (1-2), 2 CHANNELS PER CHIP
0197+++0000             SIO0MODE	.EQU	SIOMODE_RC	; SIO 0: CHIP TYPE: SIOMODE_[STD|RC|SMB|ZP]
0198+++0000             SIO0BASE	.EQU	$80		; SIO 0: REGISTERS BASE ADR
0199+++0000             SIO0ACLK	.EQU	CPUOSC		; SIO 0A: OSC FREQ IN HZ, ZP=2457600/4915200, RC/SMB=7372800
0200+++0000             SIO0ACFG	.EQU	DEFSERCFG	; SIO 0A: SERIAL LINE CONFIG
0201+++0000             SIO0ACTCC	.EQU	-1		; SIO 0A: CTC CHANNEL 0=A, 1=B, 2=C, 3=D, -1 FOR NONE
0202+++0000             SIO0BCLK	.EQU	CPUOSC		; SIO 0B: OSC FREQ IN HZ, ZP=2457600/4915200, RC/SMB=7372800
0203+++0000             SIO0BCFG	.EQU	DEFSERCFG	; SIO 0B: SERIAL LINE CONFIG
0204+++0000             SIO0BCTCC	.EQU	-1		; SIO 0B: CTC CHANNEL 0=A, 1=B, 2=C, 3=D, -1 FOR NONE
0205+++0000             SIO1MODE	.EQU	SIOMODE_RC	; SIO 1: CHIP TYPE: SIOMODE_[STD|RC|SMB|ZP]
0206+++0000             SIO1BASE	.EQU	$84		; SIO 1: REGISTERS BASE ADR
0207+++0000             SIO1ACLK	.EQU	CPUOSC		; SIO 1A: OSC FREQ IN HZ, ZP=2457600/4915200, RC/SMB=7372800
0208+++0000             SIO1ACFG	.EQU	DEFSERCFG	; SIO 1A: SERIAL LINE CONFIG
0209+++0000             SIO1ACTCC	.EQU	-1		; SIO 1A: CTC CHANNEL 0=A, 1=B, 2=C, 3=D, -1 FOR NONE
0210+++0000             SIO1BCLK	.EQU	CPUOSC		; SIO 1B: OSC FREQ IN HZ, ZP=2457600/4915200, RC/SMB=7372800
0211+++0000             SIO1BCFG	.EQU	DEFSERCFG	; SIO 1B: SERIAL LINE CONFIG
0212+++0000             SIO1BCTCC	.EQU	-1		; SIO 1B: CTC CHANNEL 0=A, 1=B, 2=C, 3=D, -1 FOR NONE
0213+++0000             ;
0214+++0000             XIOCFG		.EQU	DEFSERCFG	; XIO: SERIAL LINE CONFIG
0215+++0000             ;
0216+++0000             VDUENABLE	.EQU	FALSE		; VDU: ENABLE VDU VIDEO/KBD DRIVER (VDU.ASM)
0217+++0000             VDUSIZ		.EQU	V80X25		; VDU: DISPLAY FORMAT [V80X24|V80X25|V80X30]
0218+++0000             CVDUENABLE	.EQU	FALSE		; CVDU: ENABLE CVDU VIDEO/KBD DRIVER (CVDU.ASM)
0219+++0000             CVDUMODE	.EQU	CVDUMODE_ECB	; CVDU: CVDU MODE: CVDUMODE_[NONE|ECB|MBC]
0220+++0000             CVDUMON		.EQU	CVDUMON_CGA	; CVDU: CVDU MONITOR SETUP: CVDUMON_[NONE|CGA|EGA]
0221+++0000             GDCENABLE	.EQU	FALSE		; GDC: ENABLE 7220 GDC VIDEO/KBD DRIVER (GDC.ASM)
0222+++0000             GDCMODE		.EQU	GDCMODE_RPH	; GDC: GDC MODE: GDCMODE_[NONE|ECB|RPH]
0223+++0000             GDCMON		.EQU	GDCMON_EGA      ; GDC: GDC MONITOR SETUP: GDCMON_[NONE|CGA|EGA]
0224+++0000             TMSENABLE	.EQU	FALSE		; TMS: ENABLE TMS9918 VIDEO/KBD DRIVER (TMS.ASM)
0225+++0000             TMSMODE		.EQU	TMSMODE_MSX	; TMS: DRIVER MODE: TMSMODE_[SCG|N8|MBC|MSX|MSX9958|MSXKBD|COLECO]
0226+++0000             TMSTIMENABLE	.EQU	FALSE		; TMS: ENABLE TIMER INTERRUPTS (REQUIRES IM1)
0227+++0000             VGAENABLE	.EQU	FALSE		; VGA: ENABLE VGA VIDEO/KBD DRIVER (VGA.ASM)
0228+++0000             VGASIZ		.EQU	V80X25		; VGA: DISPLAY FORMAT [V80X25|V80X30|V80X43]
0229+++0000             ;
0230+++0000             MDENABLE	.EQU	TRUE		; MD: ENABLE MEMORY (ROM/RAM) DISK DRIVER (MD.ASM)
0231+++0000             MDROM		.EQU	TRUE		; MD: ENABLE ROM DISK
0232+++0000             MDRAM		.EQU	TRUE		; MD: ENABLE RAM DISK
0233+++0000             MDTRACE		.EQU	1		; MD: TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0234+++0000             MDFFENABLE	.EQU	FALSE		; MD: ENABLE FLASH FILE SYSTEM
0235+++0000             ;
0236+++0000             FDENABLE	.EQU	FALSE		; FD: ENABLE FLOPPY DISK DRIVER (FD.ASM)
0237+++0000             FDMODE		.EQU	FDMODE_NONE	; FD: DRIVER MODE: FDMODE_[DIO|ZETA|ZETA2|DIDE|N8|DIO3|RCSMC|RCWDC|DYNO|EPFDC|MBC]
0238+++0000             FDCNT		.EQU	2		; FD: NUMBER OF FLOPPY DRIVES ON THE INTERFACE (1-2)
0239+++0000             FDTRACE		.EQU	1		; FD: TRACE LEVEL (0=NO,1=FATAL,2=ERRORS,3=ALL)
0240+++0000             FDMEDIA		.EQU	FDM144		; FD: DEFAULT MEDIA FORMAT FDM[720|144|360|120|111]
0241+++0000             FDMEDIAALT	.EQU	FDM720		; FD: ALTERNATE MEDIA FORMAT FDM[720|144|360|120|111]
0242+++0000             FDMAUTO		.EQU	TRUE		; FD: AUTO SELECT DEFAULT/ALTERNATE MEDIA FORMATS
0243+++0000             ;
0244+++0000             RFENABLE	.EQU	FALSE		; RF: ENABLE RAM FLOPPY DRIVER
0245+++0000             RFCNT		.EQU	1		; RF: NUMBER OF RAM FLOPPY UNITS (1-4)
0246+++0000             ;
0247+++0000             IDEENABLE	.EQU	FALSE		; IDE: ENABLE IDE DISK DRIVER (IDE.ASM)
0248+++0000             IDETRACE	.EQU	1		; IDE: TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0249+++0000             IDECNT		.EQU	1		; IDE: NUMBER OF IDE INTERFACES TO DETECT (1-3), 2 DRIVES EACH
0250+++0000             IDE0MODE	.EQU	IDEMODE_NONE	; IDE 0: DRIVER MODE: IDEMODE_[DIO|DIDE|MK4|RC]
0251+++0000             IDE0BASE	.EQU	$20		; IDE 0: IO BASE ADDRESS
0252+++0000             IDE0DATLO	.EQU	$00		; IDE 0: DATA LO PORT FOR 16-BIT I/O
0253+++0000             IDE0DATHI	.EQU	$00		; IDE 0: DATA HI PORT FOR 16-BIT I/O
0254+++0000             IDE0A8BIT	.EQU	TRUE		; IDE 0A (MASTER): 8 BIT XFER
0255+++0000             IDE0B8BIT	.EQU	TRUE		; IDE 0B (MASTER): 8 BIT XFER
0256+++0000             IDE1MODE	.EQU	IDEMODE_NONE	; IDE 1: DRIVER MODE: IDEMODE_[DIO|DIDE|MK4|RC]
0257+++0000             IDE1BASE	.EQU	$00		; IDE 1: IO BASE ADDRESS
0258+++0000             IDE1DATLO	.EQU	$00		; IDE 1: DATA LO PORT FOR 16-BIT I/O
0259+++0000             IDE1DATHI	.EQU	$00		; IDE 1: DATA HI PORT FOR 16-BIT I/O
0260+++0000             IDE1A8BIT	.EQU	TRUE		; IDE 1A (MASTER): 8 BIT XFER
0261+++0000             IDE1B8BIT	.EQU	TRUE		; IDE 1B (MASTER): 8 BIT XFER
0262+++0000             IDE2MODE	.EQU	IDEMODE_NONE	; IDE 2: DRIVER MODE: IDEMODE_[DIO|DIDE|MK4|RC]
0263+++0000             IDE2BASE	.EQU	$00		; IDE 2: IO BASE ADDRESS
0264+++0000             IDE2DATLO	.EQU	$00		; IDE 2: DATA LO PORT FOR 16-BIT I/O
0265+++0000             IDE2DATHI	.EQU	$00		; IDE 2: DATA HI PORT FOR 16-BIT I/O
0266+++0000             IDE2A8BIT	.EQU	TRUE		; IDE 2A (MASTER): 8 BIT XFER
0267+++0000             IDE2B8BIT	.EQU	TRUE		; IDE 2B (MASTER): 8 BIT XFER
0268+++0000             ;
0269+++0000             PPIDEENABLE	.EQU	TRUE		; PPIDE: ENABLE PARALLEL PORT IDE DISK DRIVER (PPIDE.ASM)
0270+++0000             PPIDETRACE	.EQU	1		; PPIDE: TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0271+++0000             PPIDECNT	.EQU	1		; PPIDE: NUMBER OF PPI CHIPS TO DETECT (1-3), 2 DRIVES PER CHIP
0272+++0000             PPIDE0BASE	.EQU	$20		; PPIDE 0: PPI REGISTERS BASE ADR
0273+++0000             PPIDE0A8BIT	.EQU	FALSE		; PPIDE 0A (MASTER): 8 BIT XFER
0274+++0000             PPIDE0B8BIT	.EQU	FALSE		; PPIDE 0B (SLAVE): 8 BIT XFER
0275+++0000             PPIDE1BASE	.EQU	$00		; PPIDE 1: PPI REGISTERS BASE ADR
0276+++0000             PPIDE1A8BIT	.EQU	FALSE		; PPIDE 1A (MASTER): 8 BIT XFER
0277+++0000             PPIDE1B8BIT	.EQU	FALSE		; PPIDE 0B (SLAVE): 8 BIT XFER
0278+++0000             PPIDE2BASE	.EQU	$00		; PPIDE 2: PPI REGISTERS BASE ADR
0279+++0000             PPIDE2A8BIT	.EQU	FALSE		; PPIDE 2A (MASTER): 8 BIT XFER
0280+++0000             PPIDE2B8BIT	.EQU	FALSE		; PPIDE 0B (SLAVE): 8 BIT XFER
0281+++0000             ;
0282+++0000             SDENABLE	.EQU	FALSE		; SD: ENABLE SD CARD DISK DRIVER (SD.ASM)
0283+++0000             SDMODE		.EQU	SDMODE_NONE	; SD: DRIVER MODE: SDMODE_[JUHA|N8|CSIO|PPI|UART|DSD|MK4|SC|MT|USR]
0284+++0000             SDPPIBASE	.EQU	$60		; SD: BASE I/O ADDRESS OF PPI FOR PPI MODDE
0285+++0000             SDCNT		.EQU	1		; SD: NUMBER OF SD CARD DEVICES (1-2), FOR DSD/SC/MT ONLY
0286+++0000             SDTRACE		.EQU	1		; SD: TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0287+++0000             SDCSIOFAST	.EQU	FALSE		; SD: ENABLE TABLE-DRIVEN BIT INVERTER IN CSIO MODE
0288+++0000             SDMTSWAP	.EQU	FALSE		; SD: SWAP THE LOGICAL ORDER OF THE SPI PORTS OF THE MT011
0289+++0000             ;
0290+++0000             PRPENABLE	.EQU	FALSE		; PRP: ENABLE ECB PROPELLER IO BOARD DRIVER (PRP.ASM)
0291+++0000             PRPSDENABLE	.EQU	TRUE		; PRP: ENABLE PROPIO DRIVER SD CARD SUPPORT
0292+++0000             PRPSDTRACE	.EQU	1		; PRP: SD CARD TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0293+++0000             PRPCONENABLE	.EQU	TRUE		; PRP: ENABLE PROPIO DRIVER VIDEO/KBD SUPPORT
0294+++0000             ;
0295+++0000             PPPENABLE	.EQU	FALSE		; PPP: ENABLE ZETA PARALLEL PORT PROPELLER BOARD DRIVER (PPP.ASM)
0296+++0000             PPPBASE		.EQU	$60		; PPP: PPI REGISTERS BASE ADDRESS
0297+++0000             PPPSDENABLE	.EQU	TRUE		; PPP: ENABLE PPP DRIVER SD CARD SUPPORT
0298+++0000             PPPSDTRACE	.EQU	1		; PPP: SD CARD TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0299+++0000             PPPCONENABLE	.EQU	TRUE		; PPP: ENABLE PPP DRIVER VIDEO/KBD SUPPORT
0300+++0000             ;
0301+++0000             HDSKENABLE	.EQU	FALSE		; HDSK: ENABLE SIMH HDSK DISK DRIVER (HDSK.ASM)
0302+++0000             HDSKTRACE	.EQU	1		; HDSK: TRACE LEVEL (0=NO,1=ERRORS,2=ALL)
0303+++0000             ;
0304+++0000             PIOENABLE	.EQU	FALSE		; PIO: ENABLE ZILOG PIO DRIVER (PIO.ASM)
0305+++0000             PIOCNT		.EQU	2		; PIO: NUMBER OF CHIPS TO DETECT (1-2), 2 CHANNELS PER CHIP
0306+++0000             PIO0BASE	.EQU	$B8		; PIO 0: REGISTERS BASE ADR
0307+++0000             PIO1BASE	.EQU	$BC		; PIO 1: REGISTERS BASE ADR
0308+++0000             ;
0309+++0000             LPTENABLE	.EQU	FALSE		; LPT: ENABLE CENTRONICS PRINTER DRIVER (LPT.ASM)
0310+++0000             LPTCNT		.EQU	1		; LPT: NUMBER OF CHIPS TO DETECT (1-2)
0311+++0000             LPT0BASE	.EQU	$E8		; LPT 0: REGISTERS BASE ADR
0312+++0000             LPT1BASE	.EQU	$EC		; LPT 1: REGISTERS BASE ADR
0313+++0000             ;
0314+++0000             PIO_4P		.EQU	FALSE		; PIO: ENABLE PARALLEL PORT DRIVER FOR ECB 4P BOARD
0315+++0000             PIO4BASE	.EQU	$90		; PIO: PIO REGISTERS BASE ADR FOR ECB 4P BOARD
0316+++0000             PIO_ZP		.EQU	FALSE		; PIO: ENABLE PARALLEL PORT DRIVER FOR ECB ZILOG PERIPHERALS BOARD (PIO.ASM)
0317+++0000             PIOZBASE	.EQU	$88		; PIO: PIO REGISTERS BASE ADR FOR ECB ZP BOARD
0318+++0000             PIO_SBC		.EQU	FALSE		; PIO: ENABLE PARALLEL PORT DRIVER FOR 8255 CHIP
0319+++0000             PIOSBASE	.EQU	$60		; PIO: PIO REGISTERS BASE ADR FOR SBC PPI
0320+++0000             ;
0321+++0000             UFENABLE	.EQU	FALSE		; UF: ENABLE ECB USB FIFO DRIVER (UF.ASM)
0322+++0000             UFBASE		.EQU	$0C		; UF: REGISTERS BASE ADR
0323+++0000             ;
0324+++0000             SN76489ENABLE	.EQU	FALSE		; SN: ENABLE SN76489 SOUND DRIVER
0325+++0000             AUDIOTRACE	.EQU	FALSE		; ENABLE TRACING TO CONSOLE OF SOUND DRIVER
0326+++0000             SN7CLK		.EQU	3579545		; SN: PSG CLOCK FREQ, ASSUME MSX STD
0327+++0000             SNMODE		.EQU	SNMODE_NONE	; SN: DRIVER MODE: SNMODE_[NONE|RC|VGM]
0328+++0000             ;
0329+++0000             AY38910ENABLE	.EQU	FALSE		; AY: ENABLE AY-3-8910 / YM2149 SOUND DRIVER
0330+++0000             AY_CLK		.EQU	1789772		; AY: PSG CLOCK FREQ, ASSUME MSX STD
0331+++0000             AYMODE		.EQU	AYMODE_NONE	; AY: DRIVER MODE: AYMODE_[SCG|N8|RCZ80|RCZ180|MSX|LINC|MBC]
0332+++0000             ;
0333+++0000             SPKENABLE	.EQU	FALSE		; SPK: ENABLE RTC LATCH IOBIT SOUND DRIVER (SPK.ASM)
0334+++0000             ;
0335+++0000             DMAENABLE	.EQU	FALSE		; DMA: ENABLE DMA DRIVER (DMA.ASM)
0336+++0000             DMABASE		.EQU	$E0		; DMA: DMA BASE ADDRESS
0337+++0000             DMAMODE		.EQU	DMAMODE_NONE	; DMA: DMA MODE (NONE|ECB|Z180|Z280|RC|MBC)
0338+++0000             ;
0339+++0000             YM2612ENABLE	.EQU	FALSE		; YM2612: ENABLE YM2612 DRIVER (MUTE STUB)
0340+++0000             VGMBASE		.EQU	$C0		; YM2612: BASE ADDRESS FOR VGM BOARD (YM2612/SN76469s/CTC)
0028+++0000             ;
0029+++0000             CPUOSC		.SET	16384000	; CPU OSC FREQ IN MHZ
0030+++0000             H8FPENABLE	.SET	TRUE
0031+++0000             ;
0007++ 0000             ;
0416+  0000             ;
0417+  0000             ; INCLUDE Z180 REGISTER DEFINITIONS
0418+  0000             ;
0419+  0000             #IF (BIOS == BIOS_WBW)
0420+  0000~              #IF (CPUFAM == CPU_Z180)
0421+  0000~                #INCLUDE "z180.inc"
0422+  0000               #ENDIF
0423+  0000~              #IF (CPUFAM == CPU_Z280)
0424+  0000~                #INCLUDE "z280.inc"
0425+  0000               #ENDIF
0426+  0000~              #IF (EIPCENABLE)
0427+  0000~                #INCLUDE "eipc.inc"
0428+  0000               #ENDIF
0429+  0000             #ENDIF
0430+  0000             ;
0431+  0000             ; SETUP DEFAULT CPU SPEED VALUES
0432+  0000             ;
0433+  0000             CPUKHZ		.EQU	CPUOSC / 1000	; CPU FREQ IN KHZ
0434+  0000             ;
0435+  0000             #IF (BIOS == BIOS_WBW)
0436+  0000~              #IF (CPUFAM == CPU_Z180)
0437+  0000~                #IF (Z180_CLKDIV == 0)
0438+  0000~            CPUKHZ		.SET	CPUKHZ / 2	; ADJUST FOR HALF SPEED OPERATION
0439+  0000~                #ENDIF
0440+  0000~                #IF (Z180_CLKDIV == 2)
0441+  0000~            CPUKHZ		.SET	CPUKHZ * 2	; ADJUST FOR DOUBLE SPEED OPERATION
0442+  0000~                #ENDIF
0443+  0000               #ENDIF
0444+  0000~              #IF (CPUFAM == CPU_Z280)
0445+  0000~            CPUKHZ		.SET	CPUKHZ / 2	; Z180 PHI IS ALWAYS 1/2 OSC
0446+  0000               #ENDIF
0447+  0000             #ENDIF
0448+  0000             ;
0449+  0000             CPUMHZ		.EQU	CPUKHZ / 1000	; CPU FREQ IN MHZ
0450+  0000             ;
0451+  0000             ; SYSTEM PERIODIC TIMER MODE
0452+  0000             ;
0453+  0000             #IF (BIOS == BIOS_WBW)
0454+  0000             ;
0455+  0000             TM_NONE	.EQU	0
0456+  0000             TM_CTC	.EQU	1
0457+  0000             TM_TMS	.EQU	2
0458+  0000             TM_SIMH	.EQU	3
0459+  0000             TM_Z180	.EQU	4
0460+  0000             TM_Z280	.EQU	5
0461+  0000             ;
0462+  0000             	.ECHO "SYSTEM TIMER:"
0463+  0000             SYSTIM	.EQU	TM_NONE
0464+  0000             ;
0465+  0000~              #IF (CTCENABLE & (INTMODE == 2))
0466+  0000~                #IF (CTCTIMER)
0467+  0000~            SYSTIM	.SET	TM_CTC
0468+  0000~            	.ECHO	" CTC"
0469+  0000~                #ENDIF
0470+  0000               #ENDIF
0471+  0000             ;
0472+  0000~              #IF (TMSENABLE & (INTMODE == 1))
0473+  0000~                #IF (TMSTIMENABLE)
0474+  0000~            SYSTIM	.SET	TM_TMS
0475+  0000~            	.ECHO	" TMS9918/V9958"
0476+  0000~                #ENDIF
0477+  0000               #ENDIF
0478+  0000             ;
0479+  0000~              #IF ((PLATFORM == PLT_SBC) & (INTMODE == 1))
0480+  0000~                #IF (HTIMENABLE)
0481+  0000~            SYSTIM	.SET	TM_SIMH
0482+  0000~            	.ECHO	" SIMH"
0483+  0000~                #ENDIF
0484+  0000               #ENDIF
0485+  0000             ;
0486+  0000~              #IF ((CPUFAM == CPU_Z180) & (INTMODE == 2))
0487+  0000~                #IF (Z180_TIMER)
0488+  0000~            SYSTIM	.SET	TM_Z180
0489+  0000~            	.ECHO	" Z180"
0490+  0000~                #ENDIF
0491+  0000               #ENDIF
0492+  0000             ;
0493+  0000~              #IF ((CPUFAM == CPU_Z280) & (MEMMGR == MM_Z280))
0494+  0000~                #IF (Z280_TIMER)
0495+  0000~            SYSTIM	.SET	TM_Z280
0496+  0000~            	.ECHO	" Z280"
0497+  0000~                #ENDIF
0498+  0000               #ENDIF
0499+  0000             ;
0500+  0000               #IF SYSTIM == TM_NONE
0501+  0000             	.ECHO " NONE"
0502+  0000               #ENDIF
0503+  0000             ;
0504+  0000             	.ECHO	"\n"
0505+  0000             ;
0506+  0000             #ENDIF
0507+  0000             ;
0508+  0000             ; MEMORY BANK CONFIGURATION
0509+  0000             ;
0510+  0000             WBW_ROM_R	.EQU	128	; 128K			; RESERVED ROM REQUIRED FOR ROMWBW
0511+  0000             WBW_RAM_R	.EQU	256	; 256K			; RESERVED RAM REQUIRED FOR ROMWBW
0512+  0000             TOT_ROM_RB	.EQU	(WBW_ROM_R / 32)		; TOTAL ROM BANKS RESERVED
0513+  0000             TOT_RAM_RB	.EQU	(WBW_RAM_R / 32)		; TOTAL RAM BANKS RESERVED
0514+  0000             ;
0515+  0000~            #IF (BIOS == BIOS_UNA)
0516+  0000~            BID_ROM0	.EQU	$0000
0517+  0000~            BID_RAM0	.EQU	$8000
0518+  0000             #ENDIF
0519+  0000             ;
0520+  0000             #IF (BIOS == BIOS_WBW)
0521+  0000             BID_ROM0	.EQU	$00
0522+  0000             BID_RAM0	.EQU	$80
0523+  0000             #ENDIF
0524+  0000             
0525+  0000             BID_ROMN	.EQU	(BID_ROM0 + ((ROMSIZE / 32) - 1))
0526+  0000             BID_RAMN	.EQU	(BID_RAM0 + ((RAMSIZE / 32) - 1))
0527+  0000             ;
0528+  0000             BID_RAMD0	.EQU	BID_RAM0	; FIRST RAM DRIVE BANK			 ^  RAM
0529+  0000             BID_RAMDN	.EQU	BID_RAMN - TOT_RAM_RB	; LAST RAM DRIVE BANK		 |  DRIVE
0530+  0000             ;					; OS BUFFERS CP/M3?			-+ THESE	CPM3 BNK 5 (BUF)
0531+  0000             ;					; OS BUFFERS CP/M3?			 | MAKE		CPM3 BNK 4 (BUF)
0532+  0000             ;					; OS BUFFERS CP/M3?			 | UP		CPM3 BNK 3 (BUF)
0533+  0000             ;					; OS BUFFERS CP/M3?			 | THE		CPM3 BNK 2 (BUF)
0534+  0000             BID_AUX		.EQU	BID_RAMN - 3	; AUX BANK (BPBIOS, ETC.)		 | 256KB	CPM3 BNK 1 (TPA)
0535+  0000             BID_BIOS	.EQU	BID_RAMN - 2	; BIOS BANK				 | RESERVED
0536+  0000             BID_USR		.EQU	BID_RAMN - 1	; USER BANK (CP/M TPA, ETC.)		 | RAM		CPM3 BNK 0 (OS)
0537+  0000             BID_COM		.EQU	BID_RAMN - 0	; COMMON BANK, UPPER 32K		-+ BANKS
0538+  0000             BID_BOOT	.EQU	BID_ROM0 + 0	; BOOT BANK				-+ THESE MAKE
0539+  0000             BID_IMG0	.EQU	BID_ROM0 + 1	; ROM LOADER AND FIRST IMAGES BANK	 | UP THE 128KB
0540+  0000             BID_IMG1	.EQU	BID_ROM0 + 2	; SECOND IMAGES BANK		 	 | RESERVED
0541+  0000             BID_IMG2	.EQU	BID_ROM0 + 3	; NETWORK BOOT				-+ ROM BANKS
0542+  0000             BID_ROMD0	.EQU	BID_ROM0 + 4	; FIRST ROM DRIVE BANK			 |  ROM
0543+  0000             BID_ROMDN	.EQU	BID_ROMN	; LAST ROM DRIVE BANK			 V  DRIVE
0544+  0000             ;
0545+  0000~            #IF (ROMSIZE == 0)
0546+  0000~            BID_BOOT	.SET	BID_RAM0	; SPECIAL CASE ROM-LESS SYSTEM
0547+  0000             #ENDIF
0548+  0000             ;
0549+  0000             #IF (BIOS == BIOS_WBW)
0550+  0000             ;
0551+  0000~              #IF (!MDRAM)
0552+  0000~            BID_RAMD0	.SET	$FF		; RAM DRIVE DISABLED
0553+  0000~            BID_RAMDN	.SET	$FF		; RAM DRIVE DISABLED
0554+  0000               #ENDIF
0555+  0000             ;
0556+  0000~              #IF (!MDROM)
0557+  0000~            BID_ROMD0	.SET	$FF		; ROM DRIVE DISABLED
0558+  0000~            BID_ROMDN	.SET	$FF		; ROM DRIVE DISABLED
0559+  0000               #ENDIF
0560+  0000             ;
0561+  0000             #ENDIF
0562+  0000             ;
0563+  0000~            #IF FALSE
0564+  0000~            	.ECHO "BID_AUX: " \ .ECHO BID_AUX \ .ECHO "\n"
0564+  0000~            	.ECHO "BID_AUX: " \ .ECHO BID_AUX \ .ECHO "\n"
0564+  0000~            	.ECHO "BID_AUX: " \ .ECHO BID_AUX \ .ECHO "\n"
0565+  0000~            	.ECHO "BID_BIOS: " \ .ECHO BID_BIOS \ .ECHO "\n"
0565+  0000~            	.ECHO "BID_BIOS: " \ .ECHO BID_BIOS \ .ECHO "\n"
0565+  0000~            	.ECHO "BID_BIOS: " \ .ECHO BID_BIOS \ .ECHO "\n"
0566+  0000~            	.ECHO "BID_USR: " \ .ECHO BID_USR \ .ECHO "\n"
0566+  0000~            	.ECHO "BID_USR: " \ .ECHO BID_USR \ .ECHO "\n"
0566+  0000~            	.ECHO "BID_USR: " \ .ECHO BID_USR \ .ECHO "\n"
0567+  0000~            	.ECHO "BID_COM: " \ .ECHO BID_COM \ .ECHO "\n"
0567+  0000~            	.ECHO "BID_COM: " \ .ECHO BID_COM \ .ECHO "\n"
0567+  0000~            	.ECHO "BID_COM: " \ .ECHO BID_COM \ .ECHO "\n"
0568+  0000~            
0569+  0000~            	.ECHO "BID_BOOT: " \ .ECHO BID_BOOT \ .ECHO "\n"
0569+  0000~            	.ECHO "BID_BOOT: " \ .ECHO BID_BOOT \ .ECHO "\n"
0569+  0000~            	.ECHO "BID_BOOT: " \ .ECHO BID_BOOT \ .ECHO "\n"
0570+  0000~            	.ECHO "BID_IMG0: " \ .ECHO BID_IMG0 \ .ECHO "\n"
0570+  0000~            	.ECHO "BID_IMG0: " \ .ECHO BID_IMG0 \ .ECHO "\n"
0570+  0000~            	.ECHO "BID_IMG0: " \ .ECHO BID_IMG0 \ .ECHO "\n"
0571+  0000~            	.ECHO "BID_IMG1: " \ .ECHO BID_IMG1 \ .ECHO "\n"
0571+  0000~            	.ECHO "BID_IMG1: " \ .ECHO BID_IMG1 \ .ECHO "\n"
0571+  0000~            	.ECHO "BID_IMG1: " \ .ECHO BID_IMG1 \ .ECHO "\n"
0572+  0000~            	.ECHO "BID_IMG2: " \ .ECHO BID_IMG2 \ .ECHO "\n"
0572+  0000~            	.ECHO "BID_IMG2: " \ .ECHO BID_IMG2 \ .ECHO "\n"
0572+  0000~            	.ECHO "BID_IMG2: " \ .ECHO BID_IMG2 \ .ECHO "\n"
0573+  0000~            
0574+  0000~            	.ECHO "BID_ROMD0: " \ .ECHO BID_ROMD0 \ .ECHO "\n"
0574+  0000~            	.ECHO "BID_ROMD0: " \ .ECHO BID_ROMD0 \ .ECHO "\n"
0574+  0000~            	.ECHO "BID_ROMD0: " \ .ECHO BID_ROMD0 \ .ECHO "\n"
0575+  0000~            	.ECHO "BID_ROMDN: " \ .ECHO BID_ROMDN \ .ECHO "\n"
0575+  0000~            	.ECHO "BID_ROMDN: " \ .ECHO BID_ROMDN \ .ECHO "\n"
0575+  0000~            	.ECHO "BID_ROMDN: " \ .ECHO BID_ROMDN \ .ECHO "\n"
0576+  0000~            	.ECHO "BID_RAMD0: " \ .ECHO BID_RAMD0 \ .ECHO "\n"
0576+  0000~            	.ECHO "BID_RAMD0: " \ .ECHO BID_RAMD0 \ .ECHO "\n"
0576+  0000~            	.ECHO "BID_RAMD0: " \ .ECHO BID_RAMD0 \ .ECHO "\n"
0577+  0000~            	.ECHO "BID_RAMDN: " \ .ECHO BID_RAMDN \ .ECHO "\n"
0577+  0000~            	.ECHO "BID_RAMDN: " \ .ECHO BID_RAMDN \ .ECHO "\n"
0577+  0000~            	.ECHO "BID_RAMDN: " \ .ECHO BID_RAMDN \ .ECHO "\n"
0578+  0000~            
0579+  0000~            	.ECHO "BID_ROM0: " \ .ECHO BID_ROM0 \ .ECHO "\n"
0579+  0000~            	.ECHO "BID_ROM0: " \ .ECHO BID_ROM0 \ .ECHO "\n"
0579+  0000~            	.ECHO "BID_ROM0: " \ .ECHO BID_ROM0 \ .ECHO "\n"
0580+  0000~            	.ECHO "BID_ROMN: " \ .ECHO BID_ROMN \ .ECHO "\n"
0580+  0000~            	.ECHO "BID_ROMN: " \ .ECHO BID_ROMN \ .ECHO "\n"
0580+  0000~            	.ECHO "BID_ROMN: " \ .ECHO BID_ROMN \ .ECHO "\n"
0581+  0000~            	.ECHO "BID_RAM0: " \ .ECHO BID_RAM0 \ .ECHO "\n"
0581+  0000~            	.ECHO "BID_RAM0: " \ .ECHO BID_RAM0 \ .ECHO "\n"
0581+  0000~            	.ECHO "BID_RAM0: " \ .ECHO BID_RAM0 \ .ECHO "\n"
0582+  0000~            	.ECHO "BID_RAMN: " \ .ECHO BID_RAMN \ .ECHO "\n"
0582+  0000~            	.ECHO "BID_RAMN: " \ .ECHO BID_RAMN \ .ECHO "\n"
0582+  0000~            	.ECHO "BID_RAMN: " \ .ECHO BID_RAMN \ .ECHO "\n"
0583+  0000             #ENDIF
0584+  0000             ;
0585+  0000             ; MEMORY LAYOUT
0586+  0000             ;
0587+  0000             SYS_SIZ		.EQU	$3000			; COMBINED SIZE OF SYSTEM AREA (OS + HBIOS PROXY)
0588+  0000             HBBUF_SIZ	.EQU	1024			; INVARIANT HBIOS PHYSICAL DISK BUFFER, 1K
0589+  0000             HBX_SIZ		.EQU	$200			; HBIOS PROXY SIZE (SUBJECT TO CHANGE)
0590+  0000             CPM_SIZ		.EQU	SYS_SIZ - HBX_SIZ	; NET SIZE OF ALL OS COMPONENTS (EXCLUDING HBIOS PROXY)
0591+  0000             CCP_SIZ		.EQU	$800			; INVARIANT SIZE OF CCP
0592+  0000             BDOS_SIZ	.EQU	$E00			; INVARIANT SIZE OF BDOS
0593+  0000             CBIOS_SIZ	.EQU	CPM_SIZ - CCP_SIZ - BDOS_SIZ	; CBIOS IS THE REMAINDER
0594+  0000             
0595+  0000             MEMTOP		.EQU	$10000			; INVARIANT TOP OF Z80 ADDRESSABLE MEMORY
0596+  0000             BNKTOP		.EQU	$8000			; BANK MEMORY BARRIER
0597+  0000             
0598+  0000             HBX_IMG		.EQU	$200			; LOC OF HBX IMAGE IN HBIOS IMAGE BANK
0599+  0000             
0600+  0000             HBBUF_END	.EQU	BNKTOP			; END OF PHYSICAL DISK BUFFER IN HBIOS
0601+  0000             HBBUF_LOC	.EQU	HBBUF_END - HBBUF_SIZ	; START OF PHYSICAL DISK BUFFER
0602+  0000             HBX_END		.EQU	MEMTOP			; END OF HBIOS PROXY
0603+  0000             HBX_LOC		.EQU	HBX_END - HBX_SIZ	; START OF HBIOS PROXY
0604+  0000             CPM_END		.EQU	HBX_LOC			; END OF CPM COMPONENTS (INCLUDING CBIOS)
0605+  0000             CPM_LOC		.EQU	CPM_END - CPM_SIZ	; START OF CPM COMPONENTS
0606+  0000             CBIOS_END	.EQU	HBX_LOC			; END OF CBIOS
0607+  0000             CBIOS_LOC	.EQU	CBIOS_END - CBIOS_SIZ	; START OF CBIOS
0608+  0000             
0609+  0000             CPM_ENT		.EQU	CBIOS_LOC		; CPM ENTRY POINT (IN CBIOS)
0610+  0000             
0611+  0000             CPM_IMGSIZ	.EQU	$3000
0612+  0000             
0613+  0000             ; ROM BANK 1
0614+  0000             
0615+  0000             LDR_LOC		.EQU	$0000
0616+  0000             LDR_SIZ		.EQU	$1000
0617+  0000             LDR_END		.EQU	LDR_LOC +LDR_SIZ
0618+  0000             LDR_IMGLOC	.EQU	$0000
0619+  0000             
0620+  0000             MON_LOC		.EQU	$EE00			; LOCATION OF MONITOR FOR RUNNING SYSTEM
0621+  0000             MON_SIZ		.EQU	$1000			; SIZE OF MONITOR BINARY IMAGE
0622+  0000             MON_END		.EQU	MON_LOC + MON_SIZ	; END OF MONITOR
0623+  0000             MON_IMGLOC	.EQU	LDR_IMGLOC + LDR_SIZ
0624+  0000             
0625+  0000             ZSYS_IMGLOC	.EQU	MON_IMGLOC + MON_SIZ
0626+  0000             
0627+  0000             CPM_IMGLOC	.EQU	ZSYS_IMGLOC + CPM_IMGSIZ
0628+  0000             
0629+  0000             ; ROM BANK 2
0630+  0000             
0631+  0000             FTH_LOC		.EQU	$0200			; CAMEL FORTH
0632+  0000             FTH_SIZ		.EQU	$1700
0633+  0000             FTH_END		.EQU	FTH_LOC + FTH_SIZ
0634+  0000             FTH_IMGLOC	.EQU	$0000
0635+  0000             
0636+  0000             BAS_LOC		.EQU	$0200			; NASCOM BASIC
0637+  0000             BAS_SIZ		.EQU	$2000
0638+  0000             BAS_END		.EQU	BAS_LOC + BAS_SIZ
0639+  0000             BAS_IMGLOC	.EQU	FTH_IMGLOC + FTH_SIZ
0640+  0000             
0641+  0000             TBC_LOC		.EQU	$0A00			; TASTYBASIC
0642+  0000             TBC_SIZ		.EQU	$0A00
0643+  0000             TBC_END		.EQU	TBC_LOC + TBC_SIZ
0644+  0000             TBC_IMGLOC	.EQU	BAS_IMGLOC + BAS_SIZ
0645+  0000             
0646+  0000             GAM_LOC		.EQU	$0200			; GAME 2048
0647+  0000             GAM_SIZ		.EQU	$0900
0648+  0000             GAM_END		.EQU	GAM_LOC + GAM_SIZ
0649+  0000             GAM_IMGLOC	.EQU	TBC_IMGLOC + TBC_SIZ
0650+  0000             
0651+  0000             EGG_LOC		.EQU	$F000			; EASTER EGG
0652+  0000             EGG_SIZ		.EQU	$0200
0653+  0000             EGG_END		.EQU	EGG_LOC + EGG_SIZ
0654+  0000             EGG_IMGLOC	.EQU	GAM_IMGLOC + GAM_SIZ
0655+  0000             
0656+  0000             NET_LOC		.EQU	$0100			; NETWORK BOOT
0657+  0000             NET_SIZ		.EQU	$1000
0658+  0000             NET_END		.EQU	NET_LOC + NET_SIZ
0659+  0000             NET_IMGLOC	.EQU	EGG_IMGLOC + EGG_SIZ
0660+  0000             
0661+  0000             UPD_LOC		.EQU	$0200			; ROM UPDATER
0662+  0000             UPD_SIZ		.EQU	$0D00
0663+  0000             UPD_END		.EQU	UPD_LOC + UPD_SIZ
0664+  0000             UPD_IMGLOC	.EQU	NET_IMGLOC + NET_SIZ
0665+  0000             
0666+  0000             USR_LOC		.EQU	$0200			; USER
0667+  0000             USR_SIZ		.EQU	BNKTOP - UPD_IMGLOC - UPD_SIZ
0668+  0000             USR_END		.EQU	USR_LOC + USR_SIZ
0669+  0000             USR_IMGLOC	.EQU	UPD_IMGLOC + UPD_SIZ
0670+  0000             
0671+  0000             MON_DSKY	.EQU	MON_LOC + (0 * 3)	; MONITOR ENTRY (DSKY)
0672+  0000             MON_SERIAL	.EQU	MON_LOC + (1 * 3)	; MONITOR ENTRY (SERIAL PORT)
0673+  0000             ;
0674+  0000             ; INTERRUPT MODE 2 SLOT ASSIGNMENTS
0675+  0000             ;
0676+  0000~            #IF ((INTMODE == 2) | (INTMODE == 3))
0677+  0000~            
0678+  0000~              #IF ((CPUFAM == CPU_Z180) | (CPUFAM == CPU_Z280))
0679+  0000~            
0680+  0000~            ; Z180-BASED SYSTEMS
0681+  0000~            
0682+  0000~            INT_INT1	.EQU	0	; Z180 INT 1
0683+  0000~            INT_INT2	.EQU	1	; Z180 INT 2
0684+  0000~            INT_TIM0	.EQU	2	; Z180 TIMER 0
0685+  0000~            INT_TIM1	.EQU	3	; Z180 TIMER 1
0686+  0000~            INT_DMA0	.EQU	4	; Z180 DMA 0
0687+  0000~            INT_DMA1	.EQU	5	; Z180 DMA 1
0688+  0000~            INT_CSIO	.EQU	6	; Z180 CSIO
0689+  0000~            INT_SER0	.EQU	7	; Z180 SERIAL 0
0690+  0000~            INT_SER1	.EQU	8	; Z180 SERIAL 0
0691+  0000~            INT_PIO0A	.EQU	9	; ZILOG PIO 0, CHANNEL A
0692+  0000~            INT_PIO0B	.EQU	10	; ZILOG PIO 0, CHANNEL B
0693+  0000~            INT_PIO1A	.EQU	11	; ZILOG PIO 1, CHANNEL A
0694+  0000~            INT_PIO1B	.EQU	12	; ZILOG PIO 1, CHANNEL B
0695+  0000~            INT_SIO0	.EQU	13	; ZILOG SIO 0, CHANNEL A & B
0696+  0000~            INT_SIO1	.EQU	14	; ZILOG SIO 1, CHANNEL A & B
0697+  0000~            
0698+  0000~              #ELSE
0699+  0000~            
0700+  0000~            ; Z80-BASED SYSTEMS
0701+  0000~            
0702+  0000~            
0703+  0000~                #IF (PLATFORM == PLT_MBC)
0704+  0000~            
0705+  0000~            ;INT_CTC0A	.EQU	0	; ZILOG CTC 0, CHANNEL A
0706+  0000~            ;INT_CTC0B	.EQU	1	; ZILOG CTC 0, CHANNEL B
0707+  0000~            ;INT_CTC0C	.EQU	2	; ZILOG CTC 0, CHANNEL C
0708+  0000~            ;INT_CTC0D	.EQU	3	; ZILOG CTC 0, CHANNEL D
0709+  0000~            INT_UART0	.EQU	4	; MBC UART 0
0710+  0000~            INT_UART1	.EQU	5	; MBC UART 1
0711+  0000~            INT_SIO0	.EQU	8	; ZILOG SIO 0, CHANNEL A & B
0712+  0000~            INT_SIO1	.EQU	9	; ZILOG SIO 1, CHANNEL A & B
0713+  0000~            INT_CTC0A	.EQU	12	; ZILOG CTC 0, CHANNEL A
0714+  0000~            INT_CTC0B	.EQU	13	; ZILOG CTC 0, CHANNEL B
0715+  0000~            INT_CTC0C	.EQU	14	; ZILOG CTC 0, CHANNEL C
0716+  0000~            INT_CTC0D	.EQU	15	; ZILOG CTC 0, CHANNEL D
0717+  0000~            ;INT_PIO0A	.EQU	9	; ZILOG PIO 0, CHANNEL A
0718+  0000~            ;INT_PIO0B	.EQU	10	; ZILOG PIO 0, CHANNEL B
0719+  0000~            ;INT_PIO1A	.EQU	11	; ZILOG PIO 1, CHANNEL A
0720+  0000~            ;INT_PIO1B	.EQU	12	; ZILOG PIO 1, CHANNEL B
0721+  0000~            
0722+  0000~                #ELSE
0723+  0000~            
0724+  0000~            INT_CTC0A	.EQU	0	; ZILOG CTC 0, CHANNEL A
0725+  0000~            INT_CTC0B	.EQU	1	; ZILOG CTC 0, CHANNEL B
0726+  0000~            INT_CTC0C	.EQU	2	; ZILOG CTC 0, CHANNEL C
0727+  0000~            INT_CTC0D	.EQU	3	; ZILOG CTC 0, CHANNEL D
0728+  0000~            INT_UART0	.EQU	4	; MBC UART 0
0729+  0000~            INT_UART1	.EQU	5	; MBC UART 1
0730+  0000~            INT_SIO0	.EQU	7	; ZILOG SIO 0, CHANNEL A & B
0731+  0000~            INT_SIO1	.EQU	8	; ZILOG SIO 1, CHANNEL A & B
0732+  0000~            INT_PIO0A	.EQU	9	; ZILOG PIO 0, CHANNEL A
0733+  0000~            INT_PIO0B	.EQU	10	; ZILOG PIO 0, CHANNEL B
0734+  0000~            INT_PIO1A	.EQU	11	; ZILOG PIO 1, CHANNEL A
0735+  0000~            INT_PIO1B	.EQU	12	; ZILOG PIO 1, CHANNEL B
0736+  0000~            
0737+  0000~                #ENDIF
0738+  0000~            
0739+  0000~              #ENDIF
0740+  0000~            
0741+  0000~            #DEFINE IVT(INTX) HB_IVT+(INTX * 4)+1
0742+  0000~            #DEFINE VEC(INTX) INTX*2
0743+  0000~            
0744+  0000             #ENDIF
0745+  0000             ;
0746+  0000             ; SET DEFAULT CSIO SPEED (INTERNAL CLOCK, SLOW AS POSSIBLE)
0747+  0000             ; DIV 1280, 14KHZ @ 18MHZ CLK
0748+  0000             ;
0749+  0000             #IF (BIOS == BIOS_WBW)
0750+  0000~              #IF (CPUFAM == CPU_Z180)
0751+  0000~            Z180_CNTR_DEF	.EQU	$06	; DEFAULT VALUE FOR Z180 CSIO CONFIG
0752+  0000               #ENDIF
0753+  0000             #ENDIF
0754+  0000             ;
0755+  0000             ; HELPER MACROS
0756+  0000             ;
0757+  0000             #DEFINE	PRTC(C)	CALL PRTCH \ .DB C			; PRINT CHARACTER C TO CONSOLE - PRTC('X')
0758+  0000             #DEFINE	PRTS(S)	CALL PRTSTRD \ .TEXT S			; PRINT STRING S TO CONSOLE - PRTD("HELLO")
0759+  0000             #DEFINE	PRTX(X) CALL PRTSTRI \ .DW X			; PRINT STRING AT ADDRESS X TO CONSOLE - PRTI(STR_HELLO)
0760+  0000             #DEFINE DEBUG(S) CALL PRTSTRD \ .TEXT S \ .TEXT "$"	; $$$$$$ PRINT STRING S TO CONSOLE - PRTD("HELLO") - NO TRAILING $ REQUIRED
0761+  0000             ;
0762+  0000             #DEFINE	XIO_PRTC(C)	CALL XIO_PRTCH \ .DB C		; PRINT CHARACTER C TO CONSOLE - PRTC('X')
0763+  0000             #DEFINE	XIO_PRTS(S)	CALL XIO_PRTSTRD \ .DB S	; PRINT STRING S TO CONSOLE - PRTD("HELLO")
0764+  0000             #DEFINE	XIO_PRTX(X)	CALL XIO_PRTSTRI \ .DW X	; PRINT STRING AT ADDRESS X TO CONSOLE - PRTI(STR_HELLO)
0072   0000             ;
0073   0000             #DEFINE	HBIOS
0074   0000             ;
0075   0000             ; MAKE SURE EXACTLY ONE OF ROMBOOT, APPBOOT, IMGBOOT IS DEFINED.
0076   0000             ;
0077   0000             MODCNT	.EQU	0
0078   0000             #IFDEF ROMBOOT
0079   0000             MODCNT	.SET	MODCNT + 1
0080   0000             #ENDIF
0081   0000~            #IFDEF APPBOOT
0082   0000~            MODCNT	.SET	MODCNT + 1
0083   0000             #ENDIF
0084   0000~            #IFDEF IMGBOOT
0085   0000~            MODCNT	.SET	MODCNT + 1
0086   0000             #ENDIF
0087   0000~            #IF (MODCNT != 1)
0088   0000~            	.ECHO	"*** ERROR: PLEASE DEFINE ONE AND ONLY ONE OF ROMBOOT, APPBOOT, IMGBOOT!!!\n"
0089   0000~            	!!!	; FORCE AN ASSEMBLY ERROR
0090   0000             #ENDIF
0091   0000             ;
0092   0000             ; SOME HARDWARE REQUIRES A SPECIFIC ROMSIZE (NOTABLY ZZRCC) OR THE
0093   0000             ; RESULTING BUILD IMAGES WILL BE CORRUPT.  ROMSIZE_CHK IS SPECIFIED
0094   0000             ; IN THE CONFIG FILE AND IS VERIFIED AGAINST THE ROMSIZE BEING USED
0095   0000             ; BY THE BUILD.  A ROMSIZE_CHK VALUE OF 0 INDICATES THE VERIFICATION
0096   0000             ; IS DISABLED (WHICH IT USUALLY IS).
0097   0000             ;
0098   0000~            #IF (ROMSIZE_CHK != 0) & (ROMSIZE != ROMSIZE_CHK)
0099   0000~            	.ECHO	"*** ERROR: ROMSIZE VALUE VERIFICATION FAILURE.\n"
0100   0000~            	.ECHO	"THIS CONFIGURATION REQUIRES A ROMSIZE OF " \ .ECHO ROMSIZE_CHK \ .ECHO ".\n"
0100   0000~            	.ECHO	"THIS CONFIGURATION REQUIRES A ROMSIZE OF " \ .ECHO ROMSIZE_CHK \ .ECHO ".\n"
0100   0000~            	.ECHO	"THIS CONFIGURATION REQUIRES A ROMSIZE OF " \ .ECHO ROMSIZE_CHK \ .ECHO ".\n"
0101   0000~            	.ECHO	"BUILD IS USING A ROMSIZE OF " \ .ECHO ROMSIZE \ .ECHO ".\n"
0101   0000~            	.ECHO	"BUILD IS USING A ROMSIZE OF " \ .ECHO ROMSIZE \ .ECHO ".\n"
0101   0000~            	.ECHO	"BUILD IS USING A ROMSIZE OF " \ .ECHO ROMSIZE \ .ECHO ".\n"
0102   0000~            	.ECHO	"SEE COMMENTS IN HBIOS.ASM.\n"
0103   0000~            	!!!	; FORCE AN ASSEMBLY ERROR
0104   0000             #ENDIF
0105   0000             ;
0106   0000             ;
0107   0000             ;
0108   0000~            #IF (DIAGENABLE)
0109   0000~            #DEFINE	DIAG(N)	PUSH AF
0110   0000~              #DEFCONT \	LD A,N
0111   0000~              #DEFCONT \	OUT (DIAGPORT),A
0112   0000~              #DEFCONT \	POP AF
0113   0000             #ELSE
0114   0000             #DEFINE	DIAG(N)	\;
0115   0000             #ENDIF
0116   0000             ;
0117   0000             ; SCxxx: LED Port=0x0E, bit 2, inverted, dedicated port
0118   0000             ; TinyZ80: LED Port=0x6E, bit 0, inverted, dedicated port
0119   0000             ; Z80-512K: LED Port=0x6E, bit 0, inverted, dedicated port
0120   0000             ; MBC: LED Port=0x70, bits 1-0, normal, shared w/ RTC port
0121   0000             ; 
0122   0000~            #IF (LEDENABLE)
0123   0000~              #IF (LEDMODE == LEDMODE_STD)
0124   0000~            #DEFINE	LED(N)	PUSH	AF
0125   0000~              #DEFCONT \	LD	A,~N
0126   0000~              #DEFCONT \	OUT	(LEDPORT),A
0127   0000~              #DEFCONT \	POP	AF
0128   0000~              #ENDIF
0129   0000~              #IF (LEDMODE == LEDMODE_RTC)
0130   0000~            #DEFINE LED(N)	PUSH	AF
0131   0000~              #DEFCONT \	LD	A,(HB_RTCVAL)
0132   0000~              #DEFCONT \	AND	%11111100
0133   0000~              #DEFCONT \	OR	(N & %00000011)
0134   0000~              #DEFCONT \	LD	(HB_RTCVAL),A
0135   0000~              #DEFCONT \	OUT	(LEDPORT),A
0136   0000~              #DEFCONT \	POP	AF
0137   0000~              #ENDIF
0138   0000             #ELSE
0139   0000             #DEFINE	LED(N)	\;
0140   0000             #ENDIF
0141   0000             ;
0142   0000             #DEFINE SYSCHKERR(HB_ERR) \
0143   0000               #DEFCONT \	CALL	SYSCHKA
0144   0000               #DEFCONT \	LD	A,HB_ERR
0145   0000               #DEFCONT \	OR	A
0146   0000             ;
0147   0000             ;
0148   0000             ;
0149   0000~            #IF (INTMODE == 0)
0150   0000~            ; NO INTERRUPT HANDLING
0151   0000~            #DEFINE	HB_DI		;
0152   0000~            #DEFINE	HB_EI		;
0153   0000             #ELSE
0154   0000~              #IF (CPUFAM == CPU_Z280)
0155   0000~                #IF (INTMODE == 3)
0156   0000~            ; Z280 MODE 3 INTERRUPT HANDLING (INTA, C/T 0, & UART RCVR ENABLED)
0157   0000~            #DEFINE	HB_DI		DI
0158   0000~            #DEFINE	HB_EI		EI	$0B
0159   0000~                #ELSE
0160   0000~            ; Z280 MODE 1/2 INTERRUPT HANDLING
0161   0000~            #DEFINE	HB_DI		DI
0162   0000~            #DEFINE	HB_EI		EI
0163   0000~                #ENDIF
0164   0000               #ELSE
0165   0000             #DEFINE	HB_DI		DI
0166   0000             #DEFINE	HB_EI		EI
0167   0000               #ENDIF
0168   0000             #ENDIF
0169   0000             ;
0170   0000~            #IF (INTMODE > 3)
0171   0000~            	.ECHO	"*** ERROR: INVALID INTMODE SETTING!!!\n"
0172   0000~            	!!!	; FORCE AN ASSEMBLY ERROR
0173   0000             #ENDIF
0174   0000             ;
0175   0000~            #IF (INTMODE == 3)
0176   0000~              #IF (CPUFAM != CPU_Z280)
0177   0000~            	.ECHO	"*** ERROR: INTMODE 3 REQUIRES Z280 FAMILY CPU!!!\n"
0178   0000~            	!!!	; FORCE AN ASSEMBLY ERROR
0179   0000~              #ENDIF
0180   0000~              #IF (MEMMGR != MM_Z280)
0181   0000~            	.ECHO	"*** ERROR: INTMODE 3 REQUIRES Z280 MEMORY MANAGER!!!\n"
0182   0000~            	!!!	; FORCE AN ASSEMBLY ERROR
0183   0000~              #ENDIF
0184   0000             #ENDIF
0185   0000             ;
0186   0000~            #IF (MEMMGR == MM_Z280)
0187   0000~              #IF (INTMODE != 3)
0188   0000~            	.ECHO	"*** ERROR: Z280 MEMORY MANAGER REQUIRES INTMODE 3!!!\n"
0189   0000~            	!!!	; FORCE AN ASSEMBLY ERROR
0190   0000~              #ENDIF
0191   0000~              #IF (CPUFAM != CPU_Z280)
0192   0000~            	.ECHO	"*** ERROR: Z280 MEMORY MANAGER REQUIRES Z280 FAMILY CPU!!!\n"
0193   0000~            	!!!	; FORCE AN ASSEMBLY ERROR
0194   0000~              #ENDIF
0195   0000             #ENDIF
0196   0000             ;
0197   0000             ;
0198   0000             ;
0199   0000             ; THE RTCDEF EQUATE IS INITIALIZED HERE AND UPDATED BY DRIVER INCLUDES
0200   0000             ; THAT SHARE THE RTC LATCH.  AS EACH DRIVER FILE IS INCLUDED, IT CAN
0201   0000             ; USE .SET TO SET ANY BITS THEY OWN WITHIN THE RTC LATCH BYTE.
0202   0000             ; SINCE RTCDEF IS CHANGED AFTER IT NEEDS TO BE USED BY THE CODE, IT
0203   0000             ; CANNOT BE USED DIRECTLY TO SET THE LATCH.  INSTEAD, THE FINAL VALUE
0204   0000             ; OF RTCDEF IS USED TO INITIALIZE A STORAGE BYTE CALLED RTCDEFVAL AT
0205   0000             ; THE END OF HBIOS.ASM.  SO (RTCDEFVAL) CAN BE USED ANYWHERE IN
0206   0000             ; HBIOS.ASM TO ACCESS THE FINAL RTCDEF VALUE.
0207   0000             ;
0208   0000             RTCDEF		.EQU	0		; ALLOWS DRIVERS TO SET BITS
0209   0000             ;
0210   0000~            #IF (PLATFORM == PLT_SCZ180)
0211   0000~            RTCDEF		.SET	RTCDEF | %00000001	; SC128 I2C SCL BIT
0212   0000             #ENDIF
0213   0000             ;
0214   0000~            #IF ((CPUSPDCAP==SPD_HILO) & (PLATFORM==PLT_MBC))
0215   0000~            RTCDEF		.SET	RTCDEF & ~%00001000	; INITIAL SPEED LOW
0216   0000             #ENDIF
0217   0000             ;
0218   0000~            #IF ((CPUSPDCAP==SPD_HILO) & (PLATFORM==PLT_SBC))
0219   0000~            RTCDEF		.SET	RTCDEF | %00001000	; INITIAL SPEED LOW
0220   0000             #ENDIF
0221   0000             ;
0222   0000             ;
0223   0000             ;
0224   0000             #IFNDEF	APPBOOT
0225   0000             ;
0226   0000             	.ORG	0
0227   0000             ;
0228   0000             ;==================================================================================================
0229   0000             ; NORMAL PAGE ZERO SETUP, RET/RETI/RETN AS APPROPRIATE, LEAVE INTERRUPTS DISABLED
0230   0000             ;==================================================================================================
0231   0000             ;
0232   0000             	.FILL	(000H - $),0FFH		; RST 0
0233   0000 C3 24 05    	JP	HB_START
0234   0003 00          	.DB	0			; SIG PTR STARTS AT $0004
0235   0004 70 00       	.DW	ROM_SIG
0236   0006 FF FF       	.FILL	(008H - $),0FFH		; RST 8
0237   0008 C3 F0 FF    	JP	HB_INVOKE		; INVOKE HBIOS FUNCTION
0238   000B FF FF FF FF 	.FILL	(010H - $),0FFH		; RST 10
0238   000F FF 
0239   0010 C9          	RET
0240   0011 FF FF FF FF 	.FILL	(018H - $),0FFH		; RST 18
0240   0015 FF FF FF 
0241   0018 C9          	RET
0242   0019 FF FF FF FF 	.FILL	(020H - $),0FFH		; RST 20
0242   001D FF FF FF 
0243   0020 C9          	RET
0244   0021 FF FF FF FF 	.FILL	(028H - $),0FFH		; RST 28
0244   0025 FF FF FF 
0245   0028 C9          	RET
0246   0029 FF FF FF FF 	.FILL	(030H - $),0FFH		; RST 30
0246   002D FF FF FF 
0247   0030 C9          	RET
0248   0031 FF FF FF FF 	.FILL	(038H - $),0FFH		; RST 38 / IM1 INT
0248   0035 FF FF FF 
0249   0038               #IF (INTMODE == 1)
0250   0038 C3 00 FF    	JP	INT_IM1			; JP TO INTERRUPT HANDLER IN HI MEM
0251   003B~              #ELSE
0252   003B~            	RET				; RETURN W/ INTS DISABLED
0253   003B               #ENDIF
0254   003B FF FF FF FF 	.FILL	(066H - $),0FFH		; NMI
0254   003F FF FF FF FF 
0254   0043 FF FF FF FF 
0254   0047 FF FF FF FF 
0254   004B FF FF FF FF 
0254   004F FF FF FF FF 
0254   0053 FF FF FF FF 
0254   0057 FF FF FF FF 
0254   005B FF FF FF FF 
0254   005F FF FF FF FF 
0254   0063 FF FF FF 
0255   0066 ED 45       	RETN
0256   0068             ;
0257   0068 FF FF FF FF 	.FILL	(070H - $),0FFH		; SIG STARTS AT $80
0257   006C FF FF FF FF 
0258   0070             ;
0259   0070             ROM_SIG:
0260   0070 76 B5       	.DB	$76, $B5		; 2 SIGNATURE BYTES
0261   0072 01          	.DB	1			; STRUCTURE VERSION NUMBER
0262   0073 07          	.DB	7			; ROM SIZE (IN MULTIPLES OF 4KB, MINUS ONE)
0263   0074 80 00       	.DW	NAME			; POINTER TO HUMAN-READABLE ROM NAME
0264   0076 9A 00       	.DW	AUTH			; POINTER TO AUTHOR INITIALS
0265   0078 9E 00       	.DW	DESC			; POINTER TO LONGER DESCRIPTION OF ROM
0266   007A 00 00 00 00 	.DB	0, 0, 0, 0, 0, 0	; RESERVED FOR FUTURE USE; MUST BE ZERO
0266   007E 00 00 
0267   0080             ;
0268   0080 52 4F 4D 57 NAME	.DB	"ROMWBW v", BIOSVER, ", ", TIMESTAMP, 0
0268   0084 42 57 20 76 
0268   0088 33 2E 32 2E 
0268   008C 31 2C 20 32 
0268   0090 30 32 33 2D 
0268   0094 31 30 2D 32 
0268   0098 33 00 
0269   009A 57 42 57 00 AUTH	.DB	"WBW",0
0270   009E 52 4F 4D 57 DESC	.DB	"ROMWBW v", BIOSVER, ", Copyright (C) 2020, Wayne Warthen, GNU GPL v3", 0
0270   00A2 42 57 20 76 
0270   00A6 33 2E 32 2E 
0270   00AA 31 2C 20 43 
0270   00AE 6F 70 79 72 
0270   00B2 69 67 68 74 
0270   00B6 20 28 43 29 
0270   00BA 20 32 30 32 
0270   00BE 30 2C 20 57 
0270   00C2 61 79 6E 65 
0270   00C6 20 57 61 72 
0270   00CA 74 68 65 6E 
0270   00CE 2C 20 47 4E 
0270   00D2 55 20 47 50 
0270   00D6 4C 20 76 33 
0270   00DA 00 
0271   00DB             ;
0272   00DB FF FF FF FF 	.FILL	($100 - $),$FF		; PAD REMAINDER OF PAGE ZERO
0272   00DF FF FF FF FF 
0272   00E3 FF FF FF FF 
0272   00E7 FF FF FF FF 
0272   00EB FF FF FF FF 
0272   00EF FF FF FF FF 
0272   00F3 FF FF FF FF 
0272   00F7 FF FF FF FF 
0272   00FB FF FF FF FF 
0272   00FF FF 
0273   0100             ;
0274   0100             #ENDIF
0275   0100             ;
0276   0100             ;==================================================================================================
0277   0100             ;   HBIOS CONFIGURATION BLOCK (HCB)
0278   0100             ;==================================================================================================
0279   0100             ;
0280   0100             		.ORG	HCB_LOC
0281   0100             HCB:
0282   0100 C3 24 05    		JP	HB_START
0283   0103             ;
0284   0103 57 A8       CB_MARKER	.DB	'W',~'W'	; MARKER
0285   0105 32          CB_VERSION	.DB	RMJ << 4 | RMN	; FIRST BYTE OF VERSION INFO
0286   0106 10          		.DB	RUP << 4 | RTP	; SECOND BYTE OF VERSION INFO
0287   0107             ;
0288   0107 0F          CB_PLATFORM	.DB	PLATFORM
0289   0108 10          CB_CPUMHZ	.DB	CPUMHZ
0290   0109 00 40       CB_CPUKHZ	.DW	CPUKHZ
0291   010B 10          CB_RAMBANKS	.DB	RAMSIZE / 32
0292   010C 10          CB_ROMBANKS	.DB	ROMSIZE / 32
0293   010D             ;
0294   010D 00 00       CB_BOOTVOL	.DW	0		; BOOT VOLUME IS UNIT/SLICE, SET BY LOADER
0295   010F 00          CB_BOOTBID	.DB	0		; BOOT BANK ID, SET BY LOADER
0296   0110 00          CB_SERDEV	.DB	0		; PRIMARY SERIAL UNIT IS UNIT #0 BY FIAT
0297   0111 FF          CB_CRTDEV	.DB	$FF		; PRIMARY CRT UNIT, $FF UNTIL AFTER HBIOS INIT
0298   0112 FF          CB_CONDEV	.DB	$FF		; CONSOLE UNIT, $FF UNTIL AFTER HBIOS INIT
0299   0113             ;
0300   0113 04          CB_DIAGLVL	.DB	DIAGLVL		; ROMWBW HBIOS DIAGNOSTIC LEVEL
0301   0114             ;
0302   0114             ; MEMORY MANAGEMENT VARIABLES START AT $20
0303   0114             ;
0304   0114 00 00 00 00 		.FILL	(HCB + $20 - $),0
0304   0118 00 00 00 00 
0304   011C 00 00 00 00 
0305   0120             ;
0306   0120 00 00       CB_HEAP		.DW	0
0307   0122 00 00       CB_HEAPTOP	.DW	0
0308   0124             ;
0309   0124             ; STANDARD BANK ID'S START AT $D8. DEFAULT VALUES FOR 512KB SYSTEM WITH NO RESERVED BANKS
0310   0124             ;
0311   0124 00 00 00 00 		.FILL	(HCB + $D8 - $),0
0311   0128 00 00 00 00 
0311   012C 00 00 00 00 
0311   0130 00 00 00 00 
0311   0134 00 00 00 00 
0311   0138 00 00 00 00 
0311   013C 00 00 00 00 
0311   0140 00 00 00 00 
0311   0144 00 00 00 00 
0311   0148 00 00 00 00 
0311   014C 00 00 00 00 
0311   0150 00 00 00 00 
0311   0154 00 00 00 00 
0311   0158 00 00 00 00 
0311   015C 00 00 00 00 
0311   0160 00 00 00 00 
0311   0164 00 00 00 00 
0311   0168 00 00 00 00 
0311   016C 00 00 00 00 
0311   0170 00 00 00 00 
0311   0174 00 00 00 00 
0311   0178 00 00 00 00 
0311   017C 00 00 00 00 
0311   0180 00 00 00 00 
0311   0184 00 00 00 00 
0311   0188 00 00 00 00 
0311   018C 00 00 00 00 
0311   0190 00 00 00 00 
0311   0194 00 00 00 00 
0311   0198 00 00 00 00 
0311   019C 00 00 00 00 
0311   01A0 00 00 00 00 
0311   01A4 00 00 00 00 
0311   01A8 00 00 00 00 
0311   01AC 00 00 00 00 
0311   01B0 00 00 00 00 
0311   01B4 00 00 00 00 
0311   01B8 00 00 00 00 
0311   01BC 00 00 00 00 
0311   01C0 00 00 00 00 
0311   01C4 00 00 00 00 
0311   01C8 00 00 00 00 
0311   01CC 00 00 00 00 
0311   01D0 00 00 00 00 
0311   01D4 00 00 00 00 
0312   01D8             ;
0313   01D8 8F          CB_BIDCOM	.DB	BID_COM
0314   01D9 8E          CB_BIDUSR	.DB	BID_USR
0315   01DA 8D          CB_BIDBIOS	.DB	BID_BIOS
0316   01DB 8C          CB_BIDAUX	.DB	BID_AUX
0317   01DC 80          CB_BIDRAMD0	.DB	BID_RAMD0
0318   01DD 87          CB_BIDRAMDN	.DB	BID_RAMDN
0319   01DE 04          CB_BIDROMD0	.DB	BID_ROMD0
0320   01DF 0F          CB_BIDROMDN	.DB	BID_ROMDN
0321   01E0             ;
0322   01E0 00 00 00 00 	.FILL	(HCB + HCB_SIZ - $),0	; PAD REMAINDER OF HCB
0322   01E4 00 00 00 00 
0322   01E8 00 00 00 00 
0322   01EC 00 00 00 00 
0322   01F0 00 00 00 00 
0322   01F4 00 00 00 00 
0322   01F8 00 00 00 00 
0322   01FC 00 00 00 00 
0323   0200             ;
0324   0200             ;==================================================================================================
0325   0200             ;   HBIOS UPPER MEMORY PROXY (RELOCATED TO RUN IN TOP 2 PAGES OF CPU RAM)
0326   0200             ;==================================================================================================
0327   0200             ;
0328   0200             ; THE FOLLOWING CODE IS RELOCATED TO THE TOP OF MEMORY TO HANDLE INVOCATION DISPATCHING
0329   0200             ;
0330   0200             	.FILL	(HBX_IMG - $)		; FILL TO START OF PROXY IMAGE START
0331   FE00             	.ORG	HBX_LOC			; ADJUST FOR RELOCATION
0332   FE00             ;
0333   FE00             ; MEMORY LAYOUT:
0334   FE00             ;
0335   FE00             ;   HBIOS PROXY CODE		$FE00 (256 BYTES)
0336   FE00             ;   INTERRUPT VECTORS		$FF00 (32 BYTES, 16 ENTRIES)
0337   FE00             ;   INTERRUPT HANDLER STUBS	$FF20 (128 BYTES)
0338   FE00             ;   HBIOS PROXY COPY BUFFER	$FF80 (64 BYTES)
0339   FE00             ;   HBIOS PROXY MGMT BLOCK	$FFE0 (32 BYTES)
0340   FE00             ;
0341   FE00             ; DEFINITIONS
0342   FE00             ;
0343   FE00             HBX_BUFSIZ	.EQU	$40		; INTERBANK COPY BOUNCE BUFFER SIZE
0344   FE00             ;
0345   FE00             ; HBIOS IDENTIFICATION DATA BLOCK
0346   FE00             ;
0347   FE00             HBX_IDENT:
0348   FE00 57 A8       	.DB	'W',~'W'		; MARKER
0349   FE02 32          	.DB	RMJ << 4 | RMN		; FIRST BYTE OF VERSION INFO
0350   FE03 10          	.DB	RUP << 4 | RTP		; SECOND BYTE OF VERSION INFO
0351   FE04             ;
0352   FE04             ;==================================================================================================
0353   FE04             ;   HBIOS ENTRY FOR RST 08 PROCESSING
0354   FE04             ;==================================================================================================
0355   FE04             ;
0356   FE04             ; NOTE: THE SIZE OF HBX_TMPSTK (TYPICALLY 20 BYTES) IS INSUFFICIENT FOR
0357   FE04             ; FREERTOS IF AN INTERRUPT STRIKES WHILE THE TEMPORARY STACK IS ACTIVE.
0358   FE04             ; BELOW, HBX_BUF HAS BEEN USURPED TO PROVIDE A LARGER TEMP STACK TO
0359   FE04             ; ACCOMMODATE FREERTOS.  HBX_BUF IS ONLY USED AS A BOUNCE BUFFER, SO IT'S
0360   FE04             ; USE WILL NEVER OVERLAP WITH BELOW.
0361   FE04             ;
0362   FE04             ; WARNING: HBX_INVOKE IS *NOT* REENTRANT!
0363   FE04             ;
0364   FE04             HBX_INVOKE:
0365   FE04             ;
0366   FE04~            #IF (HBIOS_MUTEX == TRUE)
0367   FE04~            	PUSH	HL			; SAVE HL
0368   FE04~            	LD	HL,HB_LOCK		; POINT TO LOCK
0369   FE04~            	SRA	(HL)			; TEST/ACQUIRE MUTEX LOCK
0370   FE04~            	JR	C,$-2			; KEEP TRYING ON FAILURE
0371   FE04~            	POP	HL			; RESTORE HL
0372   FE04             #ENDIF
0373   FE04             ;
0374   FE04~            #IF (MEMMGR == MM_Z280)
0375   FE04~            ;
0376   FE04~            	LD	A,(HB_CURBNK)		; GET CURRENT BANK
0377   FE04~            	LD	(HB_INVBNK),A		; SAVE INVOCATION BANK
0378   FE04~            ;
0379   FE04~            	LD	A,BID_BIOS		; HBIOS BANK
0380   FE04~            	LD	(HB_CURBNK),A		; SET AS CURRENT BANK
0381   FE04~            ;
0382   FE04~            	SC	HB_DISPATCH
0383   FE04~            ;
0384   FE04~            	PUSH	AF
0385   FE04~            	LD	A,(HB_INVBNK)
0386   FE04~            	LD	(HB_CURBNK),A
0387   FE04~            	POP	AF
0388   FE04~            ;
0389   FE04             #ELSE
0390   FE04             ;
0391   FE04 ED 73 28 FE 	LD	(HBX_INVSP),SP		; SAVE ORIGINAL STACK FRAME
0392   FE08 31 E0 FF    	LD	SP,HBX_BUF_END		; BORROW HBX_BUF FOR TEMP STACK
0393   FE0B             ;
0394   FE0B 3A E0 FF    	LD	A,(HB_CURBNK)		; GET CURRENT BANK
0395   FE0E 32 E1 FF    	LD	(HB_INVBNK),A		; SAVE INVOCATION BANK
0396   FE11             ;
0397   FE11 3E 8D       	LD	A,BID_BIOS		; HBIOS BANK
0398   FE13 CD 2B FE    	CALL	HBX_BNKSEL		; SELECT IT
0399   FE16 31 00 05    	LD	SP,HB_STACK		; NOW USE FULL HBIOS STACK IN HBIOS BANK
0400   FE19             ;
0401   FE19 CD 83 07    	CALL	HB_DISPATCH		; CALL HBIOS FUNCTION DISPATCHER
0402   FE1C             ;
0403   FE1C 31 E0 FF    	LD	SP,HBX_BUF_END		; BORROW HBX_BUF FOR TEMP STACK
0404   FE1F F5          	PUSH	AF			; SAVE AF (FUNCTION RETURN)
0405   FE20             ;
0406   FE20 3A E1 FF    	LD	A,(HB_INVBNK)		; LOAD ORIGINAL BANK
0407   FE23 CD 2B FE    	CALL	HBX_BNKSEL		; SELECT IT
0408   FE26 F1          	POP	AF			; RESTORE AF
0409   FE27 31 00 00    	LD	SP,0			; RESTORE ORIGINAL STACK FRAME
0410   FE2A             HBX_INVSP	.EQU	$ - 2
0411   FE2A             ;
0412   FE2A             #ENDIF
0413   FE2A             ;
0414   FE2A~            #IF (HBIOS_MUTEX == TRUE)
0415   FE2A~            	PUSH	HL			; SAVE HL
0416   FE2A~            	LD	HL,HB_LOCK		; POINT TO LOCK
0417   FE2A~            	LD	(HL),$FE		; RELEASE MUTEX LOCK
0418   FE2A~            	POP	HL			; RESTORE HL
0419   FE2A             #ENDIF
0420   FE2A             ;
0421   FE2A C9          	RET				; RETURN TO CALLER
0422   FE2B             ;
0423   FE2B             ;;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
0424   FE2B             ;; BNKSEL - Switch Memory Bank to Bank in A.
0425   FE2B             ;;   Preserve all Registers including Flags.
0426   FE2B             ;;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
0427   FE2B             ;
0428   FE2B             HBX_BNKSEL:
0429   FE2B             	; IF AN INTERRUPT OCCURS DURING THE BANK SWITCH CODE,
0430   FE2B             	; THE BANK WILL BE SET TO (CURBNK) AS THE INTERRUPT
0431   FE2B             	; RETURNS.  SO, IT IS IMPORTANT THAT (HB_CURBNK) BE
0432   FE2B             	; SET AS THE FIRST STEP TO AVOID ISSUES IF AN INTERRUPT
0433   FE2B             	; OCCURS DURING PROCESSING.
0434   FE2B 32 E0 FF    	LD	(HB_CURBNK),A		; RECORD NEW CURRENT BANK
0435   FE2E             ;
0436   FE2E             HBX_BNKSEL_INT:
0437   FE2E             ;
0438   FE2E~            #IF (MEMMGR == MM_SBC)
0439   FE2E~              #IF (INTMODE == 1)
0440   FE2E~            	; THIS BIT OF ABSURDITY HANDLES A RARE (BUT FATAL) SITUATION
0441   FE2E~            	; WHERE AN IM1 INTERRUPT OCCURS BETWEEN SETTING THE RAM AND
0442   FE2E~            	; ROM SELECTORS.  BRACKETING THE INSTRUCTIONS WITH DI/EI
0443   FE2E~            	; IS CONTRAINDICATED BECAUSE THIS ROUTINE IS CALLED BY
0444   FE2E~            	; OTHER ROUTINES THAT MUST CONTROL INT ENABLE AT A HIGHER
0445   FE2E~            	; LEVEL.  THE FOLLOWING TECHNIQUE ENSURES THAT YOU ALWAYS
0446   FE2E~            	; SWITCH DIRECTLY FROM THE PREVIOUS BANK TO THE TARGET BANK
0447   FE2E~            	; WITHOUT AN "ERRANT" BANK BEING ACTIVE BETWEEN THE TWO
0448   FE2E~            	; BANK SELECTION I/O INSTRUCTIONS.  THE TECHNIQUE IS ONLY
0449   FE2E~            	; NEEDED WHEN USING INT MODE 1 BECAUSE THAT MODE REQUIRES
0450   FE2E~            	; PAGE ONE TO HAVE A VALID INT HANDLER WHENEVER INTS ARE
0451   FE2E~            	; ENABLED.
0452   FE2E~            	;BIT	7,A			; [8] TEST RAM BIT
0453   FE2E~            	;JR	Z,HBX_ROM		; [12/7] IF NOT SET, JUST DO ROM
0454   FE2E~            	OR	A			; [4] SET FLAGS
0455   FE2E~            	JP	P,HBX_ROM		; [10] BIT 7 INDICATES RAM
0456   FE2E~              #ENDIF
0457   FE2E~            	OUT	(MPCL_RAM),A		; SET RAM PAGE SELECTOR
0458   FE2E~            HBX_ROM:
0459   FE2E~            	OUT	(MPCL_ROM),A		; SET ROM PAGE SELECTOR
0460   FE2E~            	RET				; DONE
0461   FE2E             #ENDIF
0462   FE2E             ;
0463   FE2E             #IF (MEMMGR == MM_Z2)
0464   FE2E CB 7F       	BIT	7,A			; BIT 7 SET REQUESTS RAM PAGE
0465   FE30 28 04       	JR	Z,HBX_ROM		; NOT SET, SELECT ROM PAGE
0466   FE32 CB BF       	RES	7,A			; RAM PAGE REQUESTED: CLEAR ROM BIT
0467   FE34 C6 10       	ADD	A,16			; ADD 16 x 32K - RAM STARTS FROM 512K
0468   FE36             ;
0469   FE36             HBX_ROM:
0470   FE36 07          	RLCA				; TIMES 2 - GET 16K PAGE INSTEAD OF 32K
0471   FE37 D3 78       	OUT	(MPGSEL_0),A		; BANK_0: 0K - 16K
0472   FE39 3C          	INC	A			;
0473   FE3A D3 79       	OUT	(MPGSEL_1),A		; BANK_1: 16K - 32K
0474   FE3C~              #IF (CPUFAM == CPU_Z280)
0475   FE3C~            	PCACHE
0476   FE3C               #ENDIF
0477   FE3C C9          	RET				; DONE
0478   FE3D             #ENDIF
0479   FE3D             ;
0480   FE3D~            #IF (MEMMGR == MM_N8)
0481   FE3D~            	BIT	7,A			; TEST BIT 7 FOR RAM VS. ROM
0482   FE3D~            	JR	Z,HBX_ROM		; IF NOT SET, SELECT ROM PAGE
0483   FE3D~            ;
0484   FE3D~            HBX_RAM:
0485   FE3D~            	AND	%00011111		; AVOID WRAPPING BITS
0486   FE3D~            	RLCA				; SCALE SELECTOR TO
0487   FE3D~            	RLCA				; ... GO FROM Z180 4K PAGE SIZE
0488   FE3D~            	RLCA				; ... TO DESIRED 32K PAGE SIZE
0489   FE3D~            	OUT0	(Z180_BBR),A		; WRITE TO BANK BASE
0490   FE3D~            	LD	A,N8_DEFACR | 80H	; SELECT RAM BY SETTING BIT 7
0491   FE3D~            	OUT0	(N8_ACR),A		; ... IN N8 ACR REGISTER
0492   FE3D~            	RET				; DONE
0493   FE3D~            ;
0494   FE3D~            HBX_ROM:
0495   FE3D~            	OUT0	(N8_RMAP),A		; BANK INDEX TO N8 RMAP REGISTER
0496   FE3D~            	XOR	A			; ZERO ACCUM
0497   FE3D~            	OUT0	(Z180_BBR),A		; ZERO BANK BASE
0498   FE3D~            	LD	A,N8_DEFACR		; SELECT ROM  BY CLEARING BIT 7
0499   FE3D~            	OUT0	(N8_ACR),A		; ... IN N8 ACR REGISTER
0500   FE3D~            	RET				; DONE
0501   FE3D             #ENDIF
0502   FE3D             ;
0503   FE3D~            #IF (MEMMGR == MM_Z180)
0504   FE3D~            	RLCA				; RAM FLAG TO CARRY FLAG AND BIT 0
0505   FE3D~            	JR	NC,HBX_BNKSEL1		; IF NC, WANT ROM PAGE, SKIP AHEAD
0506   FE3D~            	XOR	%00100001		; SET BIT FOR HI 512K, CLR BIT 0
0507   FE3D~            HBX_BNKSEL1:
0508   FE3D~            	AND	%00111111		; AVOID WRAPPING BITS
0509   FE3D~            	RLCA				; CONTINUE SHIFTING TO SCALE SELECTOR
0510   FE3D~            	RLCA				; FOR Z180 4K PAGE -> DESIRED 32K PAGE
0511   FE3D~            	OUT0	(Z180_BBR),A		; WRITE TO BANK BASE
0512   FE3D~            	RET				; DONE
0513   FE3D             #ENDIF
0514   FE3D             ;
0515   FE3D~            #IF (MEMMGR == MM_Z280)
0516   FE3D~            	PUSH	BC			; SAVE BC
0517   FE3D~            	PUSH	HL			; SAVE HL
0518   FE3D~            	LD	B,$00			; FIRST USER PDR
0519   FE3D~            	SC	Z280_BNKSEL		; SYSCALL
0520   FE3D~            	POP	HL			; RESTORE HL
0521   FE3D~            	POP	BC			; RESTORE BC
0522   FE3D~            	RET				; DONE
0523   FE3D             #ENDIF
0524   FE3D             ;
0525   FE3D~            #IF (MEMMGR == MM_ZRC)
0526   FE3D~            	BIT	7,A			; BIT 7 SET REQUESTS RAM PAGE
0527   FE3D~            	JR	Z,HBX_ROM		; NOT SET, SELECT ROM PAGE
0528   FE3D~            	RES	7,A			; RAM PAGE REQUESTED: CLEAR ROM BIT
0529   FE3D~            	ADD	A,ROMSIZE / 32		; STARTING RAM BANK NUMBER OFFSET
0530   FE3D~            ;
0531   FE3D~            HBX_ROM:
0532   FE3D~            	OUT	($1F),A			; HCS WRITE TO THE BANK CONTROL REGISTER
0533   FE3D~            	RET				; DONE
0534   FE3D             #ENDIF
0535   FE3D             ;
0536   FE3D~            #IF (MEMMGR == MM_MBC)
0537   FE3D~            ;
0538   FE3D~              #IF (INTMODE == 1)
0539   FE3D~            	LD	(HBX_MMA),A		; SAVE ACCUM
0540   FE3D~            	LD	A,I			; GET INT CTL REG
0541   FE3D~            	HB_DI				; DISABLE INTS
0542   FE3D~            	PUSH	AF			; SAVE INT CTL REG
0543   FE3D~            	LD	A,(HBX_MMA)		; RESTORE ACCUM
0544   FE3D~              #ENDIF
0545   FE3D~            ;
0546   FE3D~                    OR      A                       ; SET FLAGS
0547   FE3D~                    JP      P,HBX_ROM               ; BIT 7 INDICATES RAM
0548   FE3D~                    OUT     (MPCL_ROM),A            ; ENSURE ROM PAGE OUT OF MEMORY BEFORE SWITCH
0549   FE3D~            	; SEE MBC RUNTIME MEMORY SIZE ADJUSTMENT
0550   FE3D~            HBX_MBCMSK .EQU	$+1			; FORCE TOP 32K		; MASK POPULATED
0551   FE3D~            	XOR	%00000000		; TO BE IN FIRST CHIP	; DURING INITIALIZATION
0552   FE3D~                    OUT     (MPCL_RAM),A            ; SET RAM PAGE SELECTOR
0553   FE3D~            	JR	HBX_RAMX
0554   FE3D~            HBX_ROM:
0555   FE3D~                    OUT     (MPCL_RAM),A            ; ENSURE RAM PAGE OUT OF MEMORY BEFORE SWITCH
0556   FE3D~                    OUT     (MPCL_ROM),A            ; SET ROM PAGE SELECTOR
0557   FE3D~            ;
0558   FE3D~            HBX_RAMX:
0559   FE3D~            ;
0560   FE3D~              #IF (INTMODE == 1)
0561   FE3D~            	POP	AF			; RESTORE INT CTL REG
0562   FE3D~            	JP	PO,$+4			; WERE INTS DISABLED AT ENTRY?
0563   FE3D~            	EI				; *** DO NOT USE HB_EI HERE ***
0564   FE3D~            	LD	A,(HBX_MMA)		; RESTORE INCOMING ACCUM
0565   FE3D~              #ENDIF
0566   FE3D~            ;
0567   FE3D~            	RET
0568   FE3D~            ;
0569   FE3D~            HBX_MMA	.DB	0			; TEMPORARY STORAGE FOR REG A
0570   FE3D             #ENDIF
0571   FE3D             ;
0572   FE3D~            #IF (MEMMGR == MM_RPH)
0573   FE3D~            	BIT	7,A			; TEST BIT 7 FOR RAM VS. ROM
0574   FE3D~            	JR	Z,HBX_ROM		; IF NOT SET, SELECT ROM PAGE
0575   FE3D~            ;
0576   FE3D~            HBX_RAM:
0577   FE3D~            	AND	%00011111		; AVOID WRAPPING BITS
0578   FE3D~            	RLCA				; SCALE SELECTOR TO
0579   FE3D~            	RLCA				; ... GO FROM Z180 4K PAGE SIZE
0580   FE3D~            	RLCA				; ... TO DESIRED 32K PAGE SIZE
0581   FE3D~            	OUT0	(Z180_BBR),A		; WRITE TO BANK BASE
0582   FE3D~            	LD	A,RPH_DEFACR | 80H	; SELECT RAM BY SETTING BIT 7
0583   FE3D~            	OUT0	(RPH_ACR),A		; ... IN RPH ACR REGISTER
0584   FE3D~            	RET				; DONE
0585   FE3D~            ;
0586   FE3D~            HBX_ROM:
0587   FE3D~            	OR	RPH_DEFACR		; COMBINE WITH DEFAULT BITS
0588   FE3D~            	OUT0	(RPH_ACR),A		; BANK INDEX TO RPH ACR REGISTER
0589   FE3D~            	XOR	A			; ZERO ACCUM
0590   FE3D~            	OUT0	(Z180_BBR),A		; ZERO BANK BASE
0591   FE3D~            	RET				; DONE
0592   FE3D             #ENDIF
0593   FE3D             ;
0594   FE3D             ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
0595   FE3D             ; Copy Data - Possibly between banks.  This resembles CP/M 3, but
0596   FE3D             ;  usage of the HL and DE registers is reversed.
0597   FE3D             ; Caller MUST preset HBX_SRCBNK and HBX_DSTBNK.
0598   FE3D             ; IM1/IM2 interrupts are disabled during HBX_BNKCPY.
0599   FE3D             ; Enter:
0600   FE3D             ;	 HL = Source Address
0601   FE3D             ;	 DE = Destination Address
0602   FE3D             ;	 BC = Number of bytes to copy
0603   FE3D             ; Exit : None
0604   FE3D             ; Uses : AF,BC,DE,HL
0605   FE3D             ;
0606   FE3D             ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
0607   FE3D             ;
0608   FE3D             HBX_BNKCPY:
0609   FE3D~            #IF (MEMMGR == MM_Z280)
0610   FE3D~            	SC	Z280_BNKCPYX		; SYSCALL TO BNKCPYX
0611   FE3D~            	RET
0612   FE3D~            ;
0613   FE3D~            IOPRSAV	.DW	0			; TEMP STORAGE FOR IOPR
0614   FE3D~            ;
0615   FE3D             #ELSE
0616   FE3D~              #IF (CPUFAM == CPU_Z280)
0617   FE3D~            	PUSH	HL
0618   FE3D~            	PUSH	BC
0619   FE3D~            	LD	C,Z280_MSR
0620   FE3D~            	LDCTL	HL,(C)
0621   FE3D~            	POP	BC
0622   FE3D~            	EX	(SP),HL
0623   FE3D~            	HB_DI
0624   FE3D               #ELSE
0625   FE3D ED 57       	LD	A,I
0626   FE3F F3          	HB_DI
0627   FE40 F5          	PUSH	AF
0628   FE41               #ENDIF
0629   FE41 ED 73 69 FE 	LD	(HBX_BC_SP),SP		; PUT STACK
0630   FE45 31 A0 FF    	LD	SP,HBX_TMPSTK		; ... IN HI MEM
0631   FE48             
0632   FE48 3A E0 FF    	LD	A,(HB_CURBNK)		; GET CURRENT BANK
0633   FE4B F5          	PUSH	AF			; AND SAVE TO RESTORE LATER
0634   FE4C C5          	PUSH	BC			; CUR LEN -> (SP)
0635   FE4D             ;
0636   FE4D             HBX_BC_LOOP:
0637   FE4D E3          	EX	(SP),HL			; HL := CUR LEN, (SP) := CUR SRC
0638   FE4E 01 40 00    	LD	BC,HBX_BUFSIZ		; SET BC TO BOUNCE BUFFER SIZE
0639   FE51 B7          	OR	A			; CLEAR CARRY FLAG
0640   FE52 ED 42       	SBC	HL,BC			; CUR LEN := CUR LEN - BBUF SIZE
0641   FE54 38 06       	JR	C,HBX_BC_LAST		; END GAME, LESS THAN BBUF BYTES LEFT
0642   FE56 E3          	EX	(SP),HL			; HL := CUR SRC, (SP) := REM LEN
0643   FE57 CD 71 FE    	CALL	HBX_BC_ITER		; DO A FULL BBUF SIZE CHUNK
0644   FE5A 18 F1       	JR	HBX_BC_LOOP		; AND REPEAT TILL DONE
0645   FE5C             ;
0646   FE5C             HBX_BC_LAST:
0647   FE5C             	; HL IS BETWEEN -(BBUF SIZE) AND -1, BC = BBUF SIZE
0648   FE5C B7          	OR	A			; CLEAR CARRY
0649   FE5D ED 4A       	ADC	HL,BC			; HL := REM LEN (0 - 127)
0650   FE5F E3          	EX	(SP),HL			; HL := CUR SRC, (SP) := REM LEN
0651   FE60 C1          	POP	BC			; BC := REM LEN
0652   FE61 C4 71 FE    	CALL	NZ,HBX_BC_ITER		; DO FINAL CHUNK, IFF > 0 BYTES
0653   FE64 F1          	POP	AF			; RECOVER ORIGINAL BANK
0654   FE65 CD 2B FE    	CALL	HBX_BNKSEL		; SWITCH
0655   FE68             
0656   FE68 31 FF FF    	LD	SP,$FFFF		; RESTORE STACK
0657   FE6B             HBX_BC_SP	.EQU	$ - 2		; ... TO ORIGINAL VALUE
0658   FE6B~              #IF (CPUFAM == CPU_Z280)
0659   FE6B~            	EX	(SP),HL			; SAVE HL, RECOVER MSR
0660   FE6B~            	PUSH	BC			; SAVE BC
0661   FE6B~            	LD	C,Z280_MSR
0662   FE6B~            	LDCTL	(C),HL
0663   FE6B~            	POP	BC			; RECOVER BC
0664   FE6B~            	POP	HL			; RECOVER HL
0665   FE6B               #ELSE
0666   FE6B F1          	POP	AF
0667   FE6C E2 70 FE    	JP	PO,$+4
0668   FE6F FB          	EI				; *** DO NOT USE HB_EI HERE ***
0669   FE70               #ENDIF
0670   FE70 C9          	RET
0671   FE71             ;
0672   FE71             HBX_BC_ITER:
0673   FE71             	; HL = SRC ADR, DE = DEST ADR, BC = LEN
0674   FE71 C5          	PUSH	BC			; SAVE COPY LEN
0675   FE72 D5          	PUSH	DE			; FINAL DEST ON STACK
0676   FE73 11 A0 FF    	LD	DE,HBX_BUF		; SET DEST TO BUF
0677   FE76 3A E4 FF    	LD	A,(HB_SRCBNK)		; GET SOURCE BANK
0678   FE79 CD 2B FE    	CALL	HBX_BNKSEL		; SWITCH TO SOURCE BANK
0679   FE7C ED B0       	LDIR				; HL -> BUF (DE), BC BYTES, HL UPDATED SRC ADR
0680   FE7E D1          	POP	DE			; DE := FINAL DEST
0681   FE7F C1          	POP	BC			; GET LEN BACK IN BC
0682   FE80 E5          	PUSH	HL			; SAVE UPDATED SRC ADR
0683   FE81 21 A0 FF    	LD	HL,HBX_BUF		; SET SRC ADR TO BUF
0684   FE84 3A E7 FF    	LD	A,(HB_DSTBNK)		; GET DEST BANK
0685   FE87 CD 2B FE    	CALL	HBX_BNKSEL		; SWITCH TO DEST BANK
0686   FE8A ED B0       	LDIR				; BUF (HL) -> DE, BC BYTES, DE UPDATED DEST ADR
0687   FE8C E1          	POP	HL			; RECOVER UPDATED SRC ADR
0688   FE8D             	; HL = UPDATED SRC, DE = UPDATED DEST, BC = 0
0689   FE8D C9          	RET
0690   FE8E             #ENDIF
0691   FE8E             ;
0692   FE8E             ; CALL A ROUTINE IN ANOTHER BANK.
0693   FE8E             ; CALLER MUST ENSURE STACK IS ALREADY IN HIGH MEMORY AND HAS ADEQUATE SPACE.
0694   FE8E             ; IF IM1 INTERRUPTS ARE POSSIBLE, CALLER MUST EITHER DISABLE THEM PRIOR TO
0695   FE8E             ; BNKCALL OR MAKE SURE THAT PAGE ZERO IN TARGET BANK IS PREPARED FOR THEM.
0696   FE8E             ; ON INPUT A=TARGET BANK, IX=TARGET ADDRESS
0697   FE8E             ;
0698   FE8E             HBX_BNKCALL:
0699   FE8E             ;
0700   FE8E~            #IF (MEMMGR == MM_Z280)
0701   FE8E~            	CP	BID_BIOS		; CALLING HBIOS?
0702   FE8E~            	JR	NZ,HBX_BNKCALL3		; NOPE, DO NORMAL PROCESSING
0703   FE8E~            	SC	HBX_BNKCALL2		; SYSCALL TO BNKCALL2
0704   FE8E~            	RET				; THEN RETURN
0705   FE8E~            ;
0706   FE8E~            HBX_BNKCALL2:
0707   FE8E~            	HB_EI				; INTS ARE OK
0708   FE8E~            	LD	(HBX_BNKCALL_GO+1),IX	; SETUP DEST ADR
0709   FE8E~            	PCACHE				; CRITICAL!!!
0710   FE8E~            HBX_BNKCALL_GO:
0711   FE8E~            	JP	$FFFF			; DO THE REAL WORK AND RETURN
0712   FE8E             #ENDIF
0713   FE8E             ;
0714   FE8E             HBX_BNKCALL3:
0715   FE8E 32 9A FE    	LD	(HBX_BNKCALL_BNK+1),A	; STUFF TARGET BANK TO CALL INTO CODE BELOW
0716   FE91 DD 22 9F FE 	LD	(HBX_BNKCALL_ADR+1),IX	; STUFF ADDRESS TO CALL INTO CODE BELOW
0717   FE95 3A E0 FF    	LD	A,(HB_CURBNK)		; GET CURRENT BANK
0718   FE98 F5          	PUSH	AF			; SAVE FOR RETURN
0719   FE99             HBX_BNKCALL_BNK:
0720   FE99 3E FF       	LD	A,$FF			; LOAD BANK TO CALL ($FF OVERLAID AT ENTRY)
0721   FE9B CD 2B FE    	CALL	HBX_BNKSEL		; ACTIVATE THE NEW BANK
0722   FE9E             HBX_BNKCALL_ADR:
0723   FE9E CD FF FF    	CALL	$FFFF			; CALL ROUTINE ($FFFF IS OVERLAID ABOVE)
0724   FEA1 E3          	EX	(SP),HL			; SAVE HL AND GET BANK TO RESTORE IN HL
0725   FEA2 F5          	PUSH	AF			; SAVE AF
0726   FEA3 7C          	LD	A,H			; BANK TO RESTORE TO A
0727   FEA4 CD 2B FE    	CALL	HBX_BNKSEL		; RESTORE IT
0728   FEA7 F1          	POP	AF			; RECOVER AF
0729   FEA8 E1          	POP	HL			; RECOVER HL
0730   FEA9 C9          	RET
0731   FEAA             ;
0732   FEAA             ; PEEK & POKE ROUTINES
0733   FEAA             ;   ADDRESS IN HL, BANK IN D, VALUE IN/OUT IN E, A IS TRASHED
0734   FEAA             ;
0735   FEAA             ; THESE ROUTINES ARE NOT INTENDED TO BE CALLED DIRECTLY -- THEY ARE
0736   FEAA             ; HELPERS FOR THE HBIOS API AND ARE CALLED BY HBIOS BANK CODE.  THE
0737   FEAA             ; HBIOS BANK CODE BRACKETS THE USE OF THESE ROUTINES WITH DI/EI IF
0738   FEAA             ; NECESSARY FOR THE CURRENT INTERRUPT MODE.
0739   FEAA             ;
0740   FEAA             ; NOTE: THE SIZE OF HBX_TMPSTK (TYPICALLY 20 BYTES) IS INSUFFICIENT FOR
0741   FEAA             ; FREERTOS IF AN INTERRUPT STRIKES WHILE THE TEMPORARY STACK IS ACTIVE.
0742   FEAA             ; BELOW, HBX_BUF HAS BEEN USURPED TO PROVIDE A LARGER TEMP STACK TO
0743   FEAA             ; ACCOMMODATE FREERTOS.  HBX_BUF IS ONLY USED AS A BOUNCE BUFFER, SO IT'S
0744   FEAA             ; USE WILL NEVER OVERLAP WITH BELOW.
0745   FEAA             ;
0746   FEAA             HBX_PEEK:
0747   FEAA ED 73 D1 FE 	LD	(HBX_PPSP),SP		; SAVE ORIGINAL STACK FRAME
0748   FEAE 31 E0 FF    	LD	SP,HBX_BUF_END		; BORROW HBX_BUF FOR TEMP STACK
0749   FEB1 3A E0 FF    	LD	A,(HB_CURBNK)
0750   FEB4 F5          	PUSH	AF
0751   FEB5 7A          	LD	A,D
0752   FEB6 CD 2B FE    	CALL	HBX_BNKSEL
0753   FEB9 5E          	LD	E,(HL)
0754   FEBA 18 10       	JR	HBX_PPRET
0755   FEBC             ;
0756   FEBC             HBX_POKE:
0757   FEBC ED 73 D1 FE 	LD	(HBX_PPSP),SP		; SAVE ORIGINAL STACK FRAME
0758   FEC0 31 E0 FF    	LD	SP,HBX_BUF_END		; BORROW HBX_BUF FOR TEMP STACK
0759   FEC3 3A E0 FF    	LD	A,(HB_CURBNK)
0760   FEC6 F5          	PUSH	AF
0761   FEC7 7A          	LD	A,D
0762   FEC8 CD 2B FE    	CALL	HBX_BNKSEL
0763   FECB 73          	LD	(HL),E
0764   FECC             ;
0765   FECC             HBX_PPRET:
0766   FECC F1          	POP	AF
0767   FECD~            #IF (MEMMGR == MM_Z280)
0768   FECD~            	LD	A,(HB_INVBNK)		; SPECIAL CASE FOR Z280 MEM MGR
0769   FECD             #ENDIF
0770   FECD CD 2B FE    	CALL	HBX_BNKSEL
0771   FED0 31 00 00    	LD	SP,0			; RESTORE ORIGINAL STACK FRAME
0772   FED3             HBX_PPSP	.EQU	$ - 2
0773   FED3 C9          	RET
0774   FED4             ;
0775   FED4             ; SPECIAL ROUTINE IN HIGH MEMORY TO PERFORM A COLD START ON Z280
0776   FED4             ; THIS REQUIRES US TO REMAP LOW MEMORY, THEN JUMP TO ZERO
0777   FED4             ;
0778   FED4~            #IF (MEMMGR == MM_Z280)
0779   FED4~            ;
0780   FED4~            Z280_RESTART:
0781   FED4~            	DI				; KILL INTERRUPTS
0782   FED4~            	LD	SP,HBX_LOC		; STACK IN HIGH MEMORY
0783   FED4~            ;
0784   FED4~            	; COPY Z280 BANK SELECT ROUTINE TO HIGH MEMORY
0785   FED4~            	LD	HL,Z280_BNKSEL
0786   FED4~            	LD	DE,$8000
0787   FED4~            	LD	BC,Z280_BNKSEL_LEN
0788   FED4~            	LDIR
0789   FED4~            ;
0790   FED4~            	; MAKE ROM BOOT BANK ACTIVE IN LOW SYS MEM
0791   FED4~            	LD	A,BID_BOOT
0792   FED4~            	LD	B,$10			; FIRST SYS PDR
0793   FED4~            	CALL	$8000			; DO IT
0794   FED4~            ;
0795   FED4~            	; NOW JUST JUMP TO START OF ROM BOOT CODE
0796   FED4~            	JP	0
0797   FED4             #ENDIF
0798   FED4             ;
0799   FED4             ; PRIVATE STACK AT END OF HBIOS CODE
0800   FED4             ; OCCUPIES SPACE BEFORE IVT
0801   FED4             ;
0802   FED4             HBX_INTSTKSIZ	.EQU	$FF00 - $
0803   FED4             		.ECHO	"HBIOS INT STACK space: "
0804   FED4             		.ECHO	HBX_INTSTKSIZ
0805   FED4             		.ECHO	" bytes.\n"
0806   FED4 FF FF FF FF 		.FILL	HBX_INTSTKSIZ,$FF
0806   FED8 FF FF FF FF 
0806   FEDC FF FF FF FF 
0806   FEE0 FF FF FF FF 
0806   FEE4 FF FF FF FF 
0806   FEE8 FF FF FF FF 
0806   FEEC FF FF FF FF 
0806   FEF0 FF FF FF FF 
0806   FEF4 FF FF FF FF 
0806   FEF8 FF FF FF FF 
0806   FEFC FF FF FF FF 
0807   FF00             HBX_INTSTK	.EQU	$
0808   FF00             ;
0809   FF00             ;#IF (HBX_INTSTKSIZ < 24)
0810   FF00~            #IF (HBX_INTSTKSIZ < 22)
0811   FF00~            	.ECHO	"*** ERROR: INTERRUPT STACK IS TOO SMALL!!!\n"
0812   FF00~            	!!!	; FORCE AN ASSEMBLY ERROR
0813   FF00             #ENDIF
0814   FF00             ;
0815   FF00~            #IF ((INTMODE == 2) | (INTMODE == 3))
0816   FF00~            ;
0817   FF00~            ; HBIOS INTERRUPT SLOT ASSIGNMENTS
0818   FF00~            ;
0819   FF00~            ; #	Z80		Z180
0820   FF00~            ; ---	--------------	--------------
0821   FF00~            ; 0	CTC0A		INT1 -+
0822   FF00~            ; 1	CTC0B		INT2  |
0823   FF00~            ; 2	CTC0C		TIM0  |
0824   FF00~            ; 3	CTC0D		TIM1  |
0825   FF00~            ; 4	UART0		DMA0  +- Z180 INTERNAL
0826   FF00~            ; 5	UART1		DMA1  |
0827   FF00~            ; 6			CSIO  |
0828   FF00~            ; 7	SIO0		SER0  |
0829   FF00~            ; 8	SIO1		SER1 -+
0830   FF00~            ; 9	PIO0A		PIO0A
0831   FF00~            ; 10	PIO0B		PIO0B
0832   FF00~            ; 11	PIO1A		PIO1A
0833   FF00~            ; 12	PIO1B		PIO1B
0834   FF00~            ; 13			SIO0
0835   FF00~            ; 14			SIO1
0836   FF00~            ; 15
0837   FF00~            ;
0838   FF00~            HBX_IVT:
0839   FF00~            	.DW	HBX_IV00
0840   FF00~            	.DW	HBX_IV01
0841   FF00~            	.DW	HBX_IV02
0842   FF00~            	.DW	HBX_IV03
0843   FF00~            	.DW	HBX_IV04
0844   FF00~            	.DW	HBX_IV05
0845   FF00~            	.DW	HBX_IV06
0846   FF00~            	.DW	HBX_IV07
0847   FF00~            	.DW	HBX_IV08
0848   FF00~            	.DW	HBX_IV09
0849   FF00~            	.DW	HBX_IV0A
0850   FF00~            	.DW	HBX_IV0B
0851   FF00~            	.DW	HBX_IV0C
0852   FF00~            	.DW	HBX_IV0D
0853   FF00~            	.DW	HBX_IV0E
0854   FF00~            	.DW	HBX_IV0F
0855   FF00~            ;
0856   FF00~            HBX_IVTCNT	.EQU	($ - HBX_IVT) / 2
0857   FF00~            ;
0858   FF00~            HBX_IV00:	CALL HBX_INT \ .DB $00 << 2
0858   FF00~            HBX_IV00:	CALL HBX_INT \ .DB $00 << 2
0859   FF00~            HBX_IV01:	CALL HBX_INT \ .DB $01 << 2
0859   FF00~            HBX_IV01:	CALL HBX_INT \ .DB $01 << 2
0860   FF00~            HBX_IV02:	CALL HBX_INT \ .DB $02 << 2
0860   FF00~            HBX_IV02:	CALL HBX_INT \ .DB $02 << 2
0861   FF00~            HBX_IV03:	CALL HBX_INT \ .DB $03 << 2
0861   FF00~            HBX_IV03:	CALL HBX_INT \ .DB $03 << 2
0862   FF00~            HBX_IV04:	CALL HBX_INT \ .DB $04 << 2
0862   FF00~            HBX_IV04:	CALL HBX_INT \ .DB $04 << 2
0863   FF00~            HBX_IV05:	CALL HBX_INT \ .DB $05 << 2
0863   FF00~            HBX_IV05:	CALL HBX_INT \ .DB $05 << 2
0864   FF00~            HBX_IV06:	CALL HBX_INT \ .DB $06 << 2
0864   FF00~            HBX_IV06:	CALL HBX_INT \ .DB $06 << 2
0865   FF00~            HBX_IV07:	CALL HBX_INT \ .DB $07 << 2
0865   FF00~            HBX_IV07:	CALL HBX_INT \ .DB $07 << 2
0866   FF00~            HBX_IV08:	CALL HBX_INT \ .DB $08 << 2
0866   FF00~            HBX_IV08:	CALL HBX_INT \ .DB $08 << 2
0867   FF00~            HBX_IV09:	CALL HBX_INT \ .DB $09 << 2
0867   FF00~            HBX_IV09:	CALL HBX_INT \ .DB $09 << 2
0868   FF00~            HBX_IV0A:	CALL HBX_INT \ .DB $0A << 2
0868   FF00~            HBX_IV0A:	CALL HBX_INT \ .DB $0A << 2
0869   FF00~            HBX_IV0B:	CALL HBX_INT \ .DB $0B << 2
0869   FF00~            HBX_IV0B:	CALL HBX_INT \ .DB $0B << 2
0870   FF00~            HBX_IV0C:	CALL HBX_INT \ .DB $0C << 2
0870   FF00~            HBX_IV0C:	CALL HBX_INT \ .DB $0C << 2
0871   FF00~            HBX_IV0D:	CALL HBX_INT \ .DB $0D << 2
0871   FF00~            HBX_IV0D:	CALL HBX_INT \ .DB $0D << 2
0872   FF00~            HBX_IV0E:	CALL HBX_INT \ .DB $0E << 2
0872   FF00~            HBX_IV0E:	CALL HBX_INT \ .DB $0E << 2
0873   FF00~            HBX_IV0F:	CALL HBX_INT \ .DB $0F << 2
0873   FF00~            HBX_IV0F:	CALL HBX_INT \ .DB $0F << 2
0874   FF00~            ;
0875   FF00             #ENDIF
0876   FF00             ;
0877   FF00             INT_IM1:
0878   FF00             #IF (INTMODE == 1)
0879   FF00 CD 04 FF    	CALL	HBX_INT
0880   FF03 00          	.DB	$00
0881   FF04~            #ELSE
0882   FF04~            	RETI				; UNEXPECTED INT, RET W/ INTS LEFT DISABLED
0883   FF04             #ENDIF
0884   FF04             ;
0885   FF04             #IF (INTMODE > 0)
0886   FF04             ;
0887   FF04             HBX_INT:	; COMMON INTERRUPT ROUTING CODE
0888   FF04             ;
0889   FF04~              #IF (MEMMGR == MM_Z280)
0890   FF04~            ;
0891   FF04~            ; THIS CODE ASSUMES Z280 IM 3.  IM 1 AND IM 2 ON Z280
0892   FF04~            ; DO NOT SAVE MSR AT INTERRUPT MAKING IT VIRTUALLY IMPOSSIBLE
0893   FF04~            ; TO RETURN FROM THE INTERRUPT TO THE CORRECT MODE (SYSTEM
0894   FF04~            ; OR USER).  THIS IS BECAUSE THERE IS NO WAY TO KNOW WHETHER
0895   FF04~            ; SYSTEM OR USER MODE WAS ACTIVE AT THE TIME OF THE INTERRUPT.
0896   FF04~            ;
0897   FF04~            	EX	(SP),HL			; SAVE HL AND GET INT JP TABLE OFFSET
0898   FF04~            
0899   FF04~            	; SAVE STATE (HL SAVED PREVIOUSLY ON ORIGINAL STACK FRAME)
0900   FF04~            	PUSH	AF			; SAVE AF
0901   FF04~            	PUSH	BC			; SAVE BC
0902   FF04~            	PUSH	DE			; SAVE DE
0903   FF04~            	PUSH	IY			; SAVE IY
0904   FF04~            ;
0905   FF04~            	; HANDLE INT VIA JP TABLE IN HBIOS
0906   FF04~            	LD	L,(HL)			; OFFSET INTO JP TABLE FOR THIS INT
0907   FF04~            	LD	H,HB_IVT >> 8		; MSB OF HBIOS INT JP TABLE
0908   FF04~            	CALL	JPHL			; CALL HANDLER VIA INT JP TABLE
0909   FF04~            ;
0910   FF04~            	; RESTORE STATE
0911   FF04~            	POP	IY			; RESTORE IY
0912   FF04~            	POP	DE			; RESTORE DE
0913   FF04~            	POP	BC			; RESTORE BC
0914   FF04~            	POP	AF			; RESTORE AF
0915   FF04~            	POP	HL			; RESTORE HL
0916   FF04~            ;
0917   FF04~            	; BURN THE REASON CODE
0918   FF04~            	EX	(SP),HL			; HL TO STK, RC TO HL
0919   FF04~            	POP	HL			; RESTORE HL
0920   FF04~            ;
0921   FF04~            	CALL	HBX_RETI		; RETI FOR Z80 PERIPHERALS
0922   FF04~            	RETIL
0923   FF04~            ;
0924   FF04~            HBX_RETI:
0925   FF04~            	RETI
0926   FF04~            ;
0927   FF04               #ELSE
0928   FF04             ;
0929   FF04             ; COMMON INTERRUPT DISPATCHING CODE
0930   FF04             ; SETUP AND CALL HANDLER IN BIOS BANK
0931   FF04             ;
0932   FF04 E3          	EX	(SP),HL			; SAVE HL AND GET INT JP TABLE OFFSET
0933   FF05             ;
0934   FF05 ED 73 28 FF 	LD	(HBX_INT_SP),SP		; SAVE ORIGINAL STACK FRAME
0935   FF09 31 00 FF    	LD	SP,HBX_INTSTK		; USE DEDICATED INT STACK FRAME IN HI MEM
0936   FF0C             ;
0937   FF0C             	; SAVE STATE (HL SAVED PREVIOUSLY ON ORIGINAL STACK FRAME)
0938   FF0C F5          	PUSH	AF			; SAVE AF
0939   FF0D C5          	PUSH	BC			; SAVE BC
0940   FF0E D5          	PUSH	DE			; SAVE DE
0941   FF0F FD E5       	PUSH	IY			; SAVE IY
0942   FF11             ;
0943   FF11 3E 8D       	LD	A,BID_BIOS		; HBIOS BANK
0944   FF13 CD 2E FE    	CALL	HBX_BNKSEL_INT		; SELECT IT
0945   FF16             ;
0946   FF16 6E          	LD	L,(HL)			; OFFSET INTO JP TABLE FOR THIS INT
0947   FF17 26 05       	LD	H,HB_IVT >> 8		; MSB OF HBIOS INT JP TABLE
0948   FF19             ;
0949   FF19 CD CD 1A    	CALL	JPHL			; CALL HANDLER VIA INT JP TABLE
0950   FF1C             ;
0951   FF1C 3A E0 FF    	LD	A,(HB_CURBNK)		; GET PRE-INT BANK
0952   FF1F CD 2B FE    	CALL	HBX_BNKSEL		; SELECT IT
0953   FF22             ;
0954   FF22             	; RESTORE STATE
0955   FF22 FD E1       	POP	IY			; RESTORE IY
0956   FF24 D1          	POP	DE			; RESTORE DE
0957   FF25 C1          	POP	BC			; RESTORE BC
0958   FF26 F1          	POP	AF			; RESTORE AF
0959   FF27             ;
0960   FF27 31 FF FF    	LD	SP,$FFFF		; RESTORE ORIGINAL STACK FRAME
0961   FF2A             HBX_INT_SP	.EQU	$ - 2
0962   FF2A             ;
0963   FF2A E1          	POP	HL			; RESTORE HL
0964   FF2B             ;
0965   FF2B FB          	HB_EI				; ENABLE INTERRUPTS
0966   FF2C ED 4D       	RETI				; AND RETURN
0967   FF2E             ;
0968   FF2E               #ENDIF
0969   FF2E             
0970   FF2E             #ENDIF
0971   FF2E             ;
0972   FF2E             ; SMALL TEMPORARY STACK FOR USE BY HBX_BNKCPY
0973   FF2E             ;
0974   FF2E             HBX_TMPSTKSIZ	.EQU	(HBX_XFC - HBX_BUFSIZ - $)
0975   FF2E             		.ECHO	"HBIOS TEMP STACK space: "
0976   FF2E             		.ECHO	HBX_TMPSTKSIZ
0977   FF2E             		.ECHO	" bytes.\n"
0978   FF2E CC CC CC CC 		.FILL	HBX_TMPSTKSIZ,$CC
0978   FF32 CC CC CC CC 
0978   FF36 CC CC CC CC 
0978   FF3A CC CC CC CC 
0978   FF3E CC CC CC CC 
0978   FF42 CC CC CC CC 
0978   FF46 CC CC CC CC 
0978   FF4A CC CC CC CC 
0978   FF4E CC CC CC CC 
0978   FF52 CC CC CC CC 
0978   FF56 CC CC CC CC 
0978   FF5A CC CC CC CC 
0978   FF5E CC CC CC CC 
0978   FF62 CC CC CC CC 
0978   FF66 CC CC CC CC 
0978   FF6A CC CC CC CC 
0978   FF6E CC CC CC CC 
0978   FF72 CC CC CC CC 
0978   FF76 CC CC CC CC 
0978   FF7A CC CC CC CC 
0978   FF7E CC CC CC CC 
0978   FF82 CC CC CC CC 
0978   FF86 CC CC CC CC 
0978   FF8A CC CC CC CC 
0978   FF8E CC CC CC CC 
0978   FF92 CC CC CC CC 
0978   FF96 CC CC CC CC 
0978   FF9A CC CC CC CC 
0978   FF9E CC CC 
0979   FFA0             HBX_TMPSTK	.EQU	$
0980   FFA0             ;
0981   FFA0             ; INTERBANK COPY BOUNCE BUFFER (64 BYTES)
0982   FFA0             ;
0983   FFA0             ; N.B., THIS BUFFER IS ALSO USED AS A TEMPORARY STACK BY INVOKE, PEEK, AND POKE.
0984   FFA0             ; THEREFORE, THIS BUFFER *CANNOT* BE USED TO PASS DATA OUTSIDE OF
0985   FFA0             ; HBIOS FUNCTION CALLS.
0986   FFA0             ;
0987   FFA0 00 00 00 00 HBX_BUF		.FILL	HBX_BUFSIZ,0
0987   FFA4 00 00 00 00 
0987   FFA8 00 00 00 00 
0987   FFAC 00 00 00 00 
0987   FFB0 00 00 00 00 
0987   FFB4 00 00 00 00 
0987   FFB8 00 00 00 00 
0987   FFBC 00 00 00 00 
0987   FFC0 00 00 00 00 
0987   FFC4 00 00 00 00 
0987   FFC8 00 00 00 00 
0987   FFCC 00 00 00 00 
0987   FFD0 00 00 00 00 
0987   FFD4 00 00 00 00 
0987   FFD8 00 00 00 00 
0987   FFDC 00 00 00 00 
0988   FFE0             HBX_BUF_END	.EQU	$
0989   FFE0             ;
0990   FFE0             ; HBIOS PROXY MGMT BLOCK (TOP 32 BYTES)
0991   FFE0             ;
0992   FFE0             #IFDEF ROMBOOT
0993   FFE0 00          	.DB	BID_BOOT		; HB_CURBNK: CURRENTLY ACTIVE LOW MEMORY BANK ID
0994   FFE1~            #ELSE
0995   FFE1~            	.DB	BID_USR			; HB_CURBNK: CURRENTLY ACTIVE LOW MEMORY BANK ID
0996   FFE1             #ENDIF
0997   FFE1 FF          	.DB	$FF			; HB_INVBNK: BANK ACTIVE AT TIME OF HBIOS CALL INVOCATION
0998   FFE2 00 00       	.DW	0			; HB_SRCADR: BNKCPY SOURCE ADDRESS
0999   FFE4 8E          	.DB	BID_USR			; HB_SRCBNK: BNKCPY SOURCE BANK ID
1000   FFE5 00 00       	.DW	0			; HB_DSTADR: BNKCPY DESTINATION ADDRESS
1001   FFE7 8E          	.DB	BID_USR			; HB_DSTBNK: BNKCPY DESTINATION BANK ID
1002   FFE8 00 00       	.DW	0			; HB_CPYLEN: BNKCPY LENGTH
1003   FFEA 00 00 00 00 	.FILL	4,0			; FILLER, RESERVED FOR FUTURE HBIOS USE
1004   FFEE 00          	.DB	0			; SHADOW VALUE FOR RTC LATCH PORT
1005   FFEF FE          	.DB	$FE			; HB_LOCK: HBIOS MUTEX LOCK
1006   FFF0 C3 04 FE    	JP	HBX_INVOKE		; HB_INVOKE: FIXED ADR ENTRY FOR HBX_INVOKE (ALT FOR RST 08)
1007   FFF3 C3 2B FE    	JP	HBX_BNKSEL		; HB_BNKSEL: FIXED ADR ENTRY FOR HBX_BNKSEL
1008   FFF6 C3 3D FE    	JP	HBX_BNKCPY		; HB_BNKCPY: FIXED ADR ENTRY FOR HBX_BNKCPY
1009   FFF9 C3 8E FE    	JP	HBX_BNKCALL		; HB_BNKCALL: FIXED ADR ENTRY FOR HBX_BNKCALL
1010   FFFC 00 FE       	.DW	HBX_IDENT		; ADDRESS OF HBIOS PROXY START (DEPRECATED)
1011   FFFE 00 FE       	.DW	HBX_IDENT		; HB_IDENT: ADDRESS OF HBIOS IDENT INFO DATA BLOCK
1012   10000             ;
1013   10000             	.FILL	MEMTOP - $		; FILL TO END OF MEMORY (AS NEEDED)
1014   0400             	.ORG	HBX_IMG + HBX_SIZ	; RESET ORG
1015   0400             ;
1016   0400             ;==================================================================================================
1017   0400             ;   HBIOS CORE
1018   0400             ;==================================================================================================
1019   0400             ;
1020   0400             ;==================================================================================================
1021   0400             ;   ENTRY VECTORS (JUMP TABLE) AND INTERNAL PROCESSING STACK
1022   0400             ;==================================================================================================
1023   0400             ;
1024   0400             HB_ENTRYTBL	.EQU	$
1025   0400             ;
1026   0400 C3 24 05    	JP	HB_START		; HBIOS INITIALIZATION
1027   0403 C3 83 07    	JP	HB_DISPATCH		; VECTOR TO DISPATCHER
1028   0406 C3 F2 23    	JP	PRTSUM
1029   0409             	; !!! DO NOT ADD ADDTIONAL VECTORS HERE WITHOUT
1030   0409             	; CHECKING W/ WAYNE !!!
1031   0409             ;
1032   0409             HB_STKSIZ	.EQU	$100 - ($ & $FF)
1033   0409             ;
1034   0409 FF FF FF FF 		.FILL	HB_STKSIZ,$FF	; USE REMAINDER OF PAGE FOR HBIOS STACK
1034   040D FF FF FF FF 
1034   0411 FF FF FF FF 
1034   0415 FF FF FF FF 
1034   0419 FF FF FF FF 
1034   041D FF FF FF FF 
1034   0421 FF FF FF FF 
1034   0425 FF FF FF FF 
1034   0429 FF FF FF FF 
1034   042D FF FF FF FF 
1034   0431 FF FF FF FF 
1034   0435 FF FF FF FF 
1034   0439 FF FF FF FF 
1034   043D FF FF FF FF 
1034   0441 FF FF FF FF 
1034   0445 FF FF FF FF 
1034   0449 FF FF FF FF 
1034   044D FF FF FF FF 
1034   0451 FF FF FF FF 
1034   0455 FF FF FF FF 
1034   0459 FF FF FF FF 
1034   045D FF FF FF FF 
1034   0461 FF FF FF FF 
1034   0465 FF FF FF FF 
1034   0469 FF FF FF FF 
1034   046D FF FF FF FF 
1034   0471 FF FF FF FF 
1034   0475 FF FF FF FF 
1034   0479 FF FF FF FF 
1034   047D FF FF FF FF 
1034   0481 FF FF FF FF 
1034   0485 FF FF FF FF 
1034   0489 FF FF FF FF 
1034   048D FF FF FF FF 
1034   0491 FF FF FF FF 
1034   0495 FF FF FF FF 
1034   0499 FF FF FF FF 
1034   049D FF FF FF FF 
1034   04A1 FF FF FF FF 
1034   04A5 FF FF FF FF 
1034   04A9 FF FF FF FF 
1034   04AD FF FF FF FF 
1034   04B1 FF FF FF FF 
1034   04B5 FF FF FF FF 
1034   04B9 FF FF FF FF 
1034   04BD FF FF FF FF 
1034   04C1 FF FF FF FF 
1034   04C5 FF FF FF FF 
1034   04C9 FF FF FF FF 
1034   04CD FF FF FF FF 
1034   04D1 FF FF FF FF 
1034   04D5 FF FF FF FF 
1034   04D9 FF FF FF FF 
1034   04DD FF FF FF FF 
1034   04E1 FF FF FF FF 
1034   04E5 FF FF FF FF 
1034   04E9 FF FF FF FF 
1034   04ED FF FF FF FF 
1034   04F1 FF FF FF FF 
1034   04F5 FF FF FF FF 
1034   04F9 FF FF FF FF 
1034   04FD FF FF FF 
1035   0500             HB_STACK	.EQU	$		; TOP OF HBIOS STACK
1036   0500             ;
1037   0500             ;==================================================================================================
1038   0500             ;   INTERRUPT VECTOR TABLE (MUST START AT PAGE BOUNDARY!!!)
1039   0500             ;==================================================================================================
1040   0500             ;
1041   0500             ; IM1 INTERRUPTS ARRIVE HERE AFTER BANK SWITCH TO HBIOS BANK
1042   0500             ; LIST OF IM1 INT CALLS IS BUILT DYNAMICALLY BELOW
1043   0500             ; SEE HB_ADDIM1 ROUTINE
1044   0500             ; EACH ENTRY WILL LOOK LIKE:
1045   0500             ;	CALL	XXXX			; CALL INT HANDLER
1046   0500             ;	RET	NZ			; RETURN IF HANDLED
1047   0500             ;
1048   0500             ; NOTE THAT THE LIST IS INITIALLY FILLED WITH CALLS TO HB_BADINT.
1049   0500             ; AS THE TABLE IS POPULATED, THE ADDRESS OF HB_BADINT IS OVERLAID
1050   0500             ; WITH THE ADDRESS OF A REAL INTERRUPT HANDLER.
1051   0500             ;
1052   0500             ; THERE IS ROOM FOR 8 ENTRIES PLUS A FINAL CALL TO HB_BADINT.
1053   0500             ;
1054   0500             #IF (INTMODE < 2)
1055   0500             ;
1056   0500             HB_IVT:
1057   0500 CD CF 0C    	CALL HB_BADINT \ RET NZ
1057   0503 C0          
1058   0504 CD CF 0C    	CALL HB_BADINT \ RET NZ
1058   0507 C0          
1059   0508 CD CF 0C    	CALL HB_BADINT \ RET NZ
1059   050B C0          
1060   050C CD CF 0C    	CALL HB_BADINT \ RET NZ
1060   050F C0          
1061   0510 CD CF 0C    	CALL HB_BADINT \ RET NZ
1061   0513 C0          
1062   0514 CD CF 0C    	CALL HB_BADINT \ RET NZ
1062   0517 C0          
1063   0518 CD CF 0C    	CALL HB_BADINT \ RET NZ
1063   051B C0          
1064   051C CD CF 0C    	CALL HB_BADINT \ RET NZ
1064   051F C0          
1065   0520 CD CF 0C    	CALL HB_BADINT \ RET NZ
1065   0523 C0          
1066   0524             ;
1067   0524             #ENDIF
1068   0524             ;
1069   0524             ; IM2 INTERRUPTS ARRIVE HERE AFTER BANK SWITCH TO HBIOS BANK
1070   0524             ; THE LIST OF JP TABLE ENTRIES MATCHES THE IM2 VECTORS ONE FOR
1071   0524             ; ONE.  ANY CALL TO THE PRIMARY IVT (HBX_IVT) WILL BE MAPPED TO
1072   0524             ; THE CORRESPONDING JP TABLE ENTRY BELOW AFTER THE BANK SWITCH.
1073   0524             ;
1074   0524             ; NOTE THAT THE LIST IS INITIALLY FILLED WITH CALLS TO HB_BADINT.
1075   0524             ; IT IS INTENDED THAT HARDWARE DRIVERS WILL DYNAMICALLY OVERLAY
1076   0524             ; THE ADDRESS PORTION OF THE APPROPRIATE JP TO POINT TO THE
1077   0524             ; DESIRED INTERRUPT HANDLER DURING THE DRIVERS INITIALIZATION.
1078   0524             ;
1079   0524             ; NOTE THAT EACH ENTRY HAS A FILLER BYTE OF VALUE ZERO.  THIS BYTE
1080   0524             ; HAS NO FUNCTION.  IT IS JUST USED TO MAKE ENTRIES AN EVEN 4 BYTES.
1081   0524             ;
1082   0524~            #IF ((INTMODE == 2) | (INTMODE == 3))
1083   0524~            ;
1084   0524~            HB_IVT:
1085   0524~            HB_IVT00:	JP	HB_BADINT \ .DB 0
1085   0524~            HB_IVT00:	JP	HB_BADINT \ .DB 0
1086   0524~            HB_IVT01:	JP	HB_BADINT \ .DB 0
1086   0524~            HB_IVT01:	JP	HB_BADINT \ .DB 0
1087   0524~            HB_IVT02:	JP	HB_BADINT \ .DB 0
1087   0524~            HB_IVT02:	JP	HB_BADINT \ .DB 0
1088   0524~            HB_IVT03:	JP	HB_BADINT \ .DB 0
1088   0524~            HB_IVT03:	JP	HB_BADINT \ .DB 0
1089   0524~            HB_IVT04:	JP	HB_BADINT \ .DB 0
1089   0524~            HB_IVT04:	JP	HB_BADINT \ .DB 0
1090   0524~            HB_IVT05:	JP	HB_BADINT \ .DB 0
1090   0524~            HB_IVT05:	JP	HB_BADINT \ .DB 0
1091   0524~            HB_IVT06:	JP	HB_BADINT \ .DB 0
1091   0524~            HB_IVT06:	JP	HB_BADINT \ .DB 0
1092   0524~            HB_IVT07:	JP	HB_BADINT \ .DB 0
1092   0524~            HB_IVT07:	JP	HB_BADINT \ .DB 0
1093   0524~            HB_IVT08:	JP	HB_BADINT \ .DB 0
1093   0524~            HB_IVT08:	JP	HB_BADINT \ .DB 0
1094   0524~            HB_IVT09:	JP	HB_BADINT \ .DB 0
1094   0524~            HB_IVT09:	JP	HB_BADINT \ .DB 0
1095   0524~            HB_IVT0A:	JP	HB_BADINT \ .DB 0
1095   0524~            HB_IVT0A:	JP	HB_BADINT \ .DB 0
1096   0524~            HB_IVT0B:	JP	HB_BADINT \ .DB 0
1096   0524~            HB_IVT0B:	JP	HB_BADINT \ .DB 0
1097   0524~            HB_IVT0C:	JP	HB_BADINT \ .DB 0
1097   0524~            HB_IVT0C:	JP	HB_BADINT \ .DB 0
1098   0524~            HB_IVT0D:	JP	HB_BADINT \ .DB 0
1098   0524~            HB_IVT0D:	JP	HB_BADINT \ .DB 0
1099   0524~            HB_IVT0E:	JP	HB_BADINT \ .DB 0
1099   0524~            HB_IVT0E:	JP	HB_BADINT \ .DB 0
1100   0524~            HB_IVT0F:	JP	HB_BADINT \ .DB 0
1100   0524~            HB_IVT0F:	JP	HB_BADINT \ .DB 0
1101   0524~            ;
1102   0524             #ENDIF
1103   0524             ;
1104   0524             ;==================================================================================================
1105   0524             ;   SYSTEM INITIALIZATION
1106   0524             ;==================================================================================================
1107   0524             ;
1108   0524             HB_START:
1109   0524             ;
1110   0524~            #IFDEF APPBOOT
1111   0524~              #IF (MEMMGR == MM_Z280)
1112   0524~            	LD	A,DIAG_01
1113   0524~            	OUT	(DIAGPORT),A
1114   0524~            	LD	DE,Z280_BOOTERR
1115   0524~            	LD	C,9
1116   0524~            	LD	A,DIAG_02
1117   0524~            	OUT	(DIAGPORT),A
1118   0524~            	CALL	$0005
1119   0524~            	LD	A,DIAG_04
1120   0524~            	OUT	(DIAGPORT),A
1121   0524~            	RET
1122   0524~            ;
1123   0524~            Z280_BOOTERR	.TEXT	"\r\n\r\n*** Application mode boot not supported under Z280 native memory management!!!\r\n\r\n$"
1124   0524~              #ENDIF
1125   0524             #ENDIF
1126   0524             ;
1127   0524 F3          	DI				; NO INTERRUPTS
1128   0525 ED 56       	IM	1			; INTERRUPT MODE 1
1129   0527             
1130   0527             ;#IF ((PLATFORM == PLT_MBC) | (PLATFORM == PLT_SBC))
1131   0527             	; INITIALIZE RTC LATCH BYTE
1132   0527             	; FOR SOME PLATFORMS THIS CONTROLS HI/LO SPEED CIRCUIT
1133   0527 3A 6A 29    	LD	A,(RTCDEFVAL)		; GET DEFAULT VALUE
1134   052A D3 70       	OUT	(RTCIO),A		; SET IT
1135   052C             ;#ENDIF
1136   052C             ;
1137   052C~            #IF (PLATFORM == PLT_N8)
1138   052C~            	LD	A,N8_DEFACR		; ENSURE N8 ACR
1139   052C~            	OUT0	(N8_ACR),A		; ... REGISTER IS INITIALIZED
1140   052C             #ENDIF
1141   052C             ;
1142   052C~            #IF (PLATFORM == PLT_RPH)
1143   052C~            	LD	A,RPH_DEFACR		; ENSURE RPH ACR
1144   052C~            	OUT0	(RPH_ACR),A		; ... REGISTER IS INITIALIZED
1145   052C             #ENDIF
1146   052C             ;
1147   052C~            #IF (DIAGENABLE)
1148   052C~            	LD	A,DIAG_01
1149   052C~            	OUT	(DIAGPORT),A
1150   052C             #ENDIF
1151   052C~            #IF (LEDENABLE)
1152   052C~              #IF (LEDMODE == LEDMODE_STD)
1153   052C~            	XOR	A			; LED IS INVERTED, TURN IT ON
1154   052C~              #ENDIF
1155   052C~              #IF (LEDMODE == LEDMODE_RTC)
1156   052C~            	LD	A,(RTCDEFVAL)		; DEFAULT LATCH VALUE
1157   052C~            	OR	%00000001		; LED 0 ON
1158   052C~              #ENDIF
1159   052C~            	OUT	(LEDPORT),A
1160   052C             #ENDIF
1161   052C             ;
1162   052C             	; WARNING: ALTHOUGH WE ARE INITIALIZING SP HERE, IT IS NOT YET
1163   052C             	; SAFE TO PUSH VALUES TO THE STACK BECAUSE SOME PLATFORMS WILL
1164   052C             	; NOT YET HAVE RAM MAPPED TO THE UPPER 32K YET!
1165   052C 31 00 FE    	LD	SP,HBX_LOC		; SETUP INITIAL STACK JUST BELOW HBIOS PROXY
1166   052F             ;
1167   052F~            #IF (CPUFAM == CPU_Z280)
1168   052F~            	; SET MAXIMUM I/O WAIT STATES FOR NOW
1169   052F~            	LD	C,Z280_BTCR		; BUS TIMING AND CONTROL REGISTER
1170   052F~            	LD	HL,$0033		; 3 I/O WAIT STATES ADDED
1171   052F~            	LDCTL	(C),HL
1172   052F~            ;
1173   052F~            	; START BY SELECTING I/O PAGE $FF
1174   052F~            	LD	L,$FF			; MMU AND DMA PAGE I/O REG IS $FF
1175   052F~            	LD	C,Z280_IOPR		; REG C POINTS TO I/O PAGE REGISTER
1176   052F~            	LDCTL	(C),HL
1177   052F~            ;
1178   052F~              #IF (MEMMGR == MM_Z280)
1179   052F~            ;
1180   052F~            	; INITIALIZE ALL OF THE SYSTEM PAGE DESCRIPTORS WITH BLOCK MOVE
1181   052F~            	XOR	A			; FIRST USER PDR
1182   052F~            	OUT	(Z280_MMUPDRPTR),A	; SET THE PDR POINTER
1183   052F~            	LD	HL,Z280_BOOTPDRTBL	; START OF PDR VALUES TABLE
1184   052F~            	LD	C,Z280_MMUBLKMOV	; PDR BLOCK MOVE PORT
1185   052F~            	LD	B,16			; PROGRAM 16 PDRS
1186   052F~            	OTIRW				; OTIRW
1187   052F~            ;
1188   052F~            	; INITIALIZE ALL OF THE USER PAGE DESCRIPTORS WITH BLOCK MOVE
1189   052F~            	LD	A,$10			; FIRST SYSTEM PDR
1190   052F~            	OUT	(Z280_MMUPDRPTR),A	; SET THE PDR POINTER
1191   052F~            	LD	HL,Z280_BOOTPDRTBL	; START OF PDR VALUES TABLE
1192   052F~            	LD	C,Z280_MMUBLKMOV	; PDR BLOCK MOVE PORT
1193   052F~            	LD	B,16			; PROGRAM 16 PDRS
1194   052F~            	OTIRW				; OTIRW
1195   052F~            ;
1196   052F~            	; ENABLE MMU (SYSTEM AND USER TRANSLATION)
1197   052F~            	LD	C,Z280_MMUMCR		; MMU MASTER CONTROL REGISTER
1198   052F~            	LD	HL,$BBFF		; ENABLE USER & SYSTEM TRANSLATE
1199   052F~            	OUTW	(C),HL
1200   052F~            ;
1201   052F~            	; DISABLE MEMORY REFRESH CYCLES
1202   052F~            	LD	A,$08			; DISABLED
1203   052F~            	OUT	(Z280_RRR),A		; SET REFRESH RATE REGISTER
1204   052F~            ;
1205   052F~            	; CONFIGURE Z280 INT/TRAP VECTOR TABLE POINTER REGISTER
1206   052F~            	; WILL POINT TO ROM COPY FOR NOW, UPDATED TO RAM LATER ON
1207   052F~            	LD	C,Z280_VPR
1208   052F~            	LD	HL,Z280_IVT >> 8	; TOP 16 BITS OF PHYSICAL ADR OF IVT
1209   052F~            	LDCTL	(C),HL
1210   052F~            ;
1211   052F~            	JR	Z280_INITZ		; JUMP TO CODE CONTINUATION
1212   052F~            ;
1213   052F~                #IF (($ % 2) == 1)
1214   052F~            	; WORD ALIGN THE TABLE
1215   052F~            	.DB	0
1216   052F~                #ENDIF
1217   052F~            ;
1218   052F~            Z280_BOOTPDRTBL:
1219   052F~            	; LOWER 32 K (BANKED)
1220   052F~            	.DW	($000 << 4) | $A
1221   052F~            	.DW	($001 << 4) | $A
1222   052F~            	.DW	($002 << 4) | $A
1223   052F~            	.DW	($003 << 4) | $A
1224   052F~            	.DW	($004 << 4) | $A
1225   052F~            	.DW	($005 << 4) | $A
1226   052F~            	.DW	($006 << 4) | $A
1227   052F~            	.DW	($007 << 4) | $A
1228   052F~            	; UPPER 32 K (COMMON)
1229   052F~            	.DW	(((((BID_COM & $7F) * 8) + 0) + (1 << (RAMLOC - 12))) << 4) | $A
1230   052F~            	.DW	(((((BID_COM & $7F) * 8) + 1) + (1 << (RAMLOC - 12))) << 4) | $A
1231   052F~            	.DW	(((((BID_COM & $7F) * 8) + 2) + (1 << (RAMLOC - 12))) << 4) | $A
1232   052F~            	.DW	(((((BID_COM & $7F) * 8) + 3) + (1 << (RAMLOC - 12))) << 4) | $A
1233   052F~            	.DW	(((((BID_COM & $7F) * 8) + 4) + (1 << (RAMLOC - 12))) << 4) | $A
1234   052F~            	.DW	(((((BID_COM & $7F) * 8) + 5) + (1 << (RAMLOC - 12))) << 4) | $A
1235   052F~            	.DW	(((((BID_COM & $7F) * 8) + 6) + (1 << (RAMLOC - 12))) << 4) | $A
1236   052F~            	.DW	(((((BID_COM & $7F) * 8) + 7) + (1 << (RAMLOC - 12))) << 4) | $A
1237   052F~            ;
1238   052F~            Z280_INITZ:
1239   052F~            ;
1240   052F~              #ENDIF
1241   052F~            ;
1242   052F~            	; RESTORE I/O PAGE TO $00
1243   052F~            	LD	L,$00			; NORMAL I/O REG IS $00
1244   052F~            	LD	C,Z280_IOPR		; REG C POINTS TO I/O PAGE REGISTER
1245   052F~            	LDCTL	(C),HL
1246   052F~            ;
1247   052F             #ENDIF
1248   052F             ;
1249   052F~            #IF (CPUFAM == CPU_Z180)
1250   052F~            	; SET BASE FOR CPU IO REGISTERS
1251   052F~            	; DO NOT USE Z180_ICR FROM Z180.INC BECAUSE THE ICR
1252   052F~            	; IS NOT YET AT THE RUNNING LOCATION.  AT RESET, THE Z180
1253   052F~            	; REGISTER BASE I/O ADDRESS IS ZERO, SO INITIALLY, ICR IS
1254   052F~            	; AT $3F.
1255   052F~            	LD	A,Z180_BASE
1256   052F~            	OUT0	($3F),A		; AT RESET, ICR IS AT $3F
1257   052F~            
1258   052F~            	DIAG(DIAG_02)
1258   052F~            	DIAG(DIAG_02)
1259   052F~            
1260   052F~            	; DISABLE REFRESH
1261   052F~            	XOR	A
1262   052F~            	OUT0	(Z180_RCR),A
1263   052F~            
1264   052F~            	; MASK OFF TIMER INTERRUPTS
1265   052F~            	XOR	A
1266   052F~            	OUT0	(Z180_TCR),A
1267   052F~            	OUT0	(Z180_ITC),A
1268   052F~            
1269   052F~            	; SET DEFAULT CPU CLOCK MULTIPLIERS (XTAL / 2)
1270   052F~            	;
1271   052F~            	; IT HAS BEEN REPORTED THAT CMR NEEDS TO BE SET PRIOR TO CCR
1272   052F~            	; WHEN USING AN INPUT FREQUENCY THAT IS XTAL / 2.
1273   052F~            	; I NEVER EXPERIENCED A PROBLEM RELATED TO ORDER, BUT JUST
1274   052F~            	; FOR GOOD MEASURE, CMR IS SET PRIOR TO CCR BELOW.
1275   052F~            	; https://www.retrobrewcomputers.org/forum/index.php?t=msg&th=316&#msg_5045
1276   052F~            	XOR	A
1277   052F~            	OUT0	(Z180_CMR),A
1278   052F~            	OUT0	(Z180_CCR),A
1279   052F~            
1280   052F~            	; SET DEFAULT WAIT STATES
1281   052F~            	LD	A,$F0
1282   052F~            	OUT0	(Z180_DCNTL),A
1283   052F~            
1284   052F~              #IF ((MEMMGR == MM_Z180) | (MEMMGR == MM_N8) | (MEMMGR == MM_RPH))
1285   052F~            	; Z180 MMU SETUP
1286   052F~            	LD	A,$80
1287   052F~            	OUT0	(Z180_CBAR),A		; SETUP FOR 32K/32K BANK CONFIG
1288   052F~            ;#IFDEF ROMBOOT
1289   052F~            ;	XOR	A
1290   052F~            ;	OUT0	(Z180_BBR),A		; BANK BASE = 0
1291   052F~            ;#ENDIF
1292   052F~            	LD	A,(RAMSIZE + RAMBIAS - 64) >> 2
1293   052F~            	OUT0	(Z180_CBR),A		; COMMON BASE = LAST (TOP) BANK
1294   052F~            ;
1295   052F~            	; SET DEFAULT CSIO SPEED (INTERNAL CLOCK, SLOW AS POSSIBLE)
1296   052F~            	LD	A,Z180_CNTR_DEF		; DIV 1280, 14KHZ @ 18MHZ CLK
1297   052F~            	OUT0	(Z180_CNTR),A
1298   052F~              #ENDIF
1299   052F~            ;
1300   052F             #ENDIF
1301   052F             ;
1302   052F~            #IF (EIPCENABLE)
1303   052F~            	LD	A,(EIPC_WDT_CONST | EIPC_HALT_RUN | EIPC_WDT_P2_22)
1304   052F~            	OUT	(EIPC_WDTMR),A		; CLEAR WDTE BIT (DISABLE WATCHDOG)
1305   052F~            	LD	A,EIPC_DIS_WDT		; DISABLE WDT - SECOND KEY
1306   052F~            	OUT 	(EIPC_WDTCR),A
1307   052F~            	LD	A,EIPC_WCR		; SET SYSTEM CONTROL REGISTER POINTER
1308   052F~            					; (SCRP) TO POINT TO WAIT STATE
1309   052F~            	OUT	(EIPC_SCRP),A		; CONTROL REGISTER (WCR)
1310   052F~            	LD	A,(EIPC_IO_0WS | EIPC_MEM_OWS | EIPC_OCF_0WS | EIPC_INT_0WS | EIPC_CHAIN_0WS)
1311   052F~            	OUT	(EIPC_SCDP),A		; NO WAIT STATES
1312   052F~            	LD	A,EIPC_MCR		; SET SCRP TO POINT TO MISCELLANEOUS
1313   052F~            	OUT	(EIPC_SCRP),A		; CONTROL REGISTER (MCR)
1314   052F~            	LD	A,EIPC_CLKDIV1		; DIVIDE CLOCK BY 1, /CS0 DISABLE
1315   052F~            	OUT	(EIPC_SCDP),A		; SET SYSTEM CONTROL DATA PORT (SCDP)
1316   052F             #ENDIF
1317   052F             ;
1318   052F~            #IF ((MEMMGR == MM_SBC) | (MEMMGR == MM_MBC))
1319   052F~            	; SET PAGING REGISTERS
1320   052F~              #IFDEF ROMBOOT
1321   052F~            	XOR	A
1322   052F~            	OUT	(MPCL_RAM),A		; REMOVE RAM FIRST!
1323   052F~            	OUT	(MPCL_ROM),A		; SELECT ROM PAGE 0
1324   052F~              #ENDIF
1325   052F             #ENDIF
1326   052F             ;
1327   052F             #IF (MEMMGR == MM_Z2)
1328   052F             	; SET PAGING REGISTERS
1329   052F               #IFDEF ROMBOOT
1330   052F AF          	XOR	A
1331   0530 D3 78       	OUT	(MPGSEL_0),A
1332   0532 3C          	INC	A
1333   0533 D3 79       	OUT	(MPGSEL_1),A
1334   0535               #ENDIF
1335   0535 3E 3E       	LD	A,62
1336   0537 D3 7A       	OUT	(MPGSEL_2),A
1337   0539 3C          	INC	A
1338   053A D3 7B       	OUT	(MPGSEL_3),A
1339   053C             	; ENABLE PAGING
1340   053C 3E 01       	LD	A,1
1341   053E D3 7C       	OUT	(MPGENA),A
1342   0540             #ENDIF
1343   0540             ;
1344   0540             ; AT THIS POINT, RAM SHOULD BE AVAILABLE IN THE COMMON BANK
1345   0540             ; (TOP 32K).
1346   0540             ;
1347   0540             ; NOTIFICATION THAT WE HAVE MADE THE JUMP TO RAM BANK!
1348   0540             ; THE DIAG() MACRO IS NOT USED BECAUSE IT USES THE STACK AND WE DO
1349   0540             ; NOT WANT TO EFFECT RAM UNTIL AFTER THE BACKUP BATTERY STATUS CHECK
1350   0540             ; IS PERFORMED NEXT.
1351   0540             ;
1352   0540~            #IF (DIAGENABLE)
1353   0540~            	LD	A,DIAG_02
1354   0540~            	OUT	(DIAGPORT),A
1355   0540             #ENDIF
1356   0540             ;
1357   0540             ; WE USE THE TWO BYTES IMMEDIATELY BELOW THE PROXY TO STORE A COUPLE
1358   0540             ; VALUES TEMPORARILY BECAUSE WE MAY BE OPERATING IN ROM AT THIS POINT.
1359   0540             ; (HBX_LOC - 1) = BATCOND, (HBX_LOC - 2) = APPBANK
1360   0540             ; THERE IS NOTHING ON THE STACK AT THIS POINT SO, HERE, WE JUST RESET
1361   0540             ; THE STACK TO HBX_LOC - 2.
1362   0540             ;
1363   0540 31 FE FD    	LD	SP,HBX_LOC - 2
1364   0543             ;
1365   0543             ; CHECK BATTERY BACKUP STATUS BEFORE WE TOUCH RAM (UPPER MEMORY)
1366   0543             ;
1367   0543             ; IF A DS1210 POWER CONTROLLER IS INSTALLED AND BATTERY BACKUP IS NOT INSTALLED
1368   0543             ; OR IS LESS THAN 2V THEN THE DS1210 WILL BLOCK THE SECOND RAM ACCESS.
1369   0543             ; FAILURE TO COMPLETE TWO RAM ACCESSES BEFORE INSTALLING PROXY WILL RESULT
1370   0543             ; IN THE ROM ID BYTES NOT BEING COPIED CORRECTLY AND CP/M APPLICATIONS
1371   0543             ; WILL NOT START CORRECTLY WHEN THEY CHECK THE ROM ID VERSION BYTES.
1372   0543             ; THE BATTERY CONDITION VALUE IS TEMPORARILY STORED AT HBX_LOC - 1
1373   0543             ; BECAUSE WE ARE CURRENTLY RUNNING IN ROM.  AFTER WE TRANSITION HBIOS
1374   0543             ; TO RAM, THE VALUE IS MOVED TO IT'S REAL LOCATION AT HB_BATCOND.
1375   0543             ; IF THERE IS NO DS1210 IN THE SYSTEM, THE CODE BELOW DOES NO HARM.
1376   0543             ;
1377   0543 21 FF FD    	LD	HL,HBX_LOC - 1		; POINT TO BYTE
1378   0546 AF          	XOR	A			; ZERO MEANS LOW BAT
1379   0547 77          	LD	(HL),A	
1380   0548 3C          	INC	A			; 1 MEANS BAT OK
1381   0549 77          	LD	(HL),A
1382   054A             ;
1383   054A             ; INSTALL PROXY IN UPPER MEMORY
1384   054A             ; THE HB_CURBNK MUST BE PRESERVED IF THIS IS AN APPBOOT.
1385   054A             ;
1386   054A 3A E0 FF    	LD	A,(HB_CURBNK)		; SAVE EXISTING HB_CURBNK
1387   054D 11 00 FE    	LD	DE,HBX_LOC		; AS PER ABOVE
1388   0550 21 00 02    	LD	HL,HBX_IMG
1389   0553 01 00 02    	LD	BC,HBX_SIZ
1390   0556 ED B0       	LDIR
1391   0558             ;
1392   0558~            #IFDEF APPBOOT
1393   0558~            	LD	(HB_CURBNK),A		; RESTORE HB_CURBNK
1394   0558             #ENDIF
1395   0558             ;
1396   0558             ; SAVE CURRENT BANKID
1397   0558             ;
1398   0558             ; THIS IS NOT GOING TO WORK IF THE APP BOOT IMAGE IS LOADED
1399   0558             ; USING THE UNA FAT32 LOADER.  SHOULD PROBABLY CHECK THAT THERE
1400   0558             ; IS A VALID ROMWBW PROXY IN MEMORY BEFORE DOING THIS.  HOWEVER,
1401   0558             ; THIS USE CASE IS PROBABLY NON-EXISTENT.  THE IMG BOOT IMAGE
1402   0558             ; SHOULD WORK FINE WITH THE UNA FAT32 LOADER.
1403   0558             ;
1404   0558             ; THIS VALUE IS TEMPORARILY STORED AT HBX_LOC - 2
1405   0558             ; BECAUSE WE ARE CURRENTLY RUNNING IN ROM.  AFTER WE TRANSITION HBIOS
1406   0558             ; TO RAM, THE VALUE IS MOVED TO IT'S REAL LCOATION AT HB_APPBNK.
1407   0558             ;
1408   0558 3A E0 FF    	LD	A,(HB_CURBNK)		; GET HB_CURBNK
1409   055B 32 FE FD    	LD	(HBX_LOC - 2),A		; ... AND SAVE TEMP FOR APPBNK
1410   055E             ;
1411   055E             ; THE RTCVAL FIELD OF THE PROXY DATA NEEDS TO BE INITIALIZED HERE
1412   055E             ; BECAUSE IT CANNOT BE PRE-INITIALIZED (SEE COMMENTS ABOVE WHERE
1413   055E             ; RTCVAL EQUATE IS DEFINED).
1414   055E             ;
1415   055E 3A 6A 29    	LD	A,(RTCDEFVAL)
1416   0561 32 EE FF    	LD	(HB_RTCVAL),A
1417   0564             ;
1418   0564~            #IFDEF TESTING
1419   0564~            ;
1420   0564~            ; THIS IS WHERE WE PROBE FOR THE ACTUAL NUMBER OF RAM
1421   0564~            ; BANKS AVAILABLE IN THE SYSTEM.  THE PROBE CODE NEEDS
1422   0564~            ; TO BE COPIED TO AND RUN FROM THE COMMON RAM BANK.
1423   0564~            ;
1424   0564~            	LD	DE,$F000
1425   0564~            	LD	HL,RS_IMAGE
1426   0564~            	LD	BC,RS_LEN
1427   0564~            	LDIR
1428   0564~            	CALL	RS_START
1429   0564~            	JP	RS_IMAGE + RS_LEN
1430   0564~            ;
1431   0564~            ; CODE THAT IS COPIED TO $F000 TO PERFORM RAM SIZE DETECTION
1432   0564~            ;
1433   0564~            RS_IMAGE:
1434   0564~            	.ORG	$F000
1435   0564~            RS_START:
1436   0564~            	LD	A,(HB_CURBNK)		; GET CURRENT BANK
1437   0564~            	PUSH	AF			; SAVE IT
1438   0564~            	
1439   0564~            	LD	C,0			; RUNNING BANK COUNT
1440   0564~            	LD	HL,$7FFF		; BYTE TEST ADDRESS
1441   0564~            	LD	IX,RS_ARY		; ORIG BYTE STORAGE ARRAY PTR
1442   0564~            RS_LOOP1:
1443   0564~            	LD	A,C
1444   0564~            	ADD	A,$80			; OFFSET BY START OF RAM BANKS
1445   0564~            	CALL	HBX_BNKSEL		; SELECT THE BANK
1446   0564~            
1447   0564~            	LD	A,(HL)			; GET ORIGINAL VALUE
1448   0564~            	LD	(IX),A			; SAVE IT TO RESTORE LATER
1449   0564~            	INC	IX			; BUMP IX
1450   0564~            
1451   0564~            	LD	A,$AA			; TEST LOC WITH $AA
1452   0564~            	LD	(HL),A			; AVOID PROBLEMS WITH
1453   0564~            	LD	(HL),A			; ... DS1210
1454   0564~            	LD	(HL),A
1455   0564~            	LD	A,(HL)
1456   0564~            	CP	$AA
1457   0564~            	JR	NZ,RS_DONE
1458   0564~            
1459   0564~            	LD	A,$55			; TEST LOC WITH $55
1460   0564~            	LD	(HL),A
1461   0564~            	LD	A,(HL)
1462   0564~            	CP	$55
1463   0564~            	JR	NZ,RS_DONE
1464   0564~            
1465   0564~            	; STORE A UNIQUE VALUE
1466   0564~            	LD	A,C
1467   0564~            	LD	(HL),A
1468   0564~            	OR	A			; ZERO?
1469   0564~            	JR	Z,RS_NEXT		; SKIP STORED VALUE CHECK
1470   0564~            	
1471   0564~            	; VERIFY ALL STORED VALUES
1472   0564~            	LD	B,C			; INIT LOOP COUNTER
1473   0564~            	LD	E,0			; INIT BANK ID
1474   0564~            RS_LOOP3:
1475   0564~            	LD	A,E
1476   0564~            	ADD	A,$80
1477   0564~            	CALL	HBX_BNKSEL
1478   0564~            	LD	A,(HL)
1479   0564~            	CP	E			; VERIFY
1480   0564~            	JR	NZ,RS_DONE		; ABORT IF MISCOMPARE
1481   0564~            	INC	E			; NEXT BANK
1482   0564~            	DJNZ	RS_LOOP3
1483   0564~            ;
1484   0564~            RS_NEXT:
1485   0564~            	INC	C			; ADD 1 TO RAM BANK COUNT
1486   0564~            	JR	RS_LOOP1		; AND LOOP TILL DONE
1487   0564~            ;	
1488   0564~            RS_DONE:
1489   0564~            	LD	E,C			; FINAL BANK COUNT TO E
1490   0564~            	LD	A,C
1491   0564~            	OR	A
1492   0564~            	JR	Z,RS_LOOPZ
1493   0564~            	; RESTORE SAVED VALUES
1494   0564~            	LD	IX,RS_ARY
1495   0564~            	LD	B,C			; LOOP COUNT
1496   0564~            	LD	C,$80			; BANK ID
1497   0564~            RS_LOOP2:
1498   0564~            	LD	A,C
1499   0564~            	CALL	HBX_BNKSEL
1500   0564~            	INC	C
1501   0564~            	LD	A,(IX)			; GET VALUE
1502   0564~            	LD	(HL),A			; RESTORE IT
1503   0564~            	INC	IX
1504   0564~            	DJNZ	RS_LOOP2		; ALL BANKS
1505   0564~            RS_LOOPZ:
1506   0564~            ;
1507   0564~            ; MBC RUNTIME MEMORY SIZE ADJUSTMENT
1508   0564~            ;
1509   0564~            ; THE MBC RAM BOARD CAN CONTAIN 1 OR 2 RAM CHIPS.  THEY CAN BE
1510   0564~            ; EITHER 128K OR 512K EACH.  SO THE MBC RAM BOARD CAN HAVE A
1511   0564~            ; TOTAL OF 128K, 256K, 512K, OR 1024K.  THE COMMON (HIMEM) RAM
1512   0564~            ; IS ALWAYS MAPPED TO THE LAST 32K OF THE FIRST CHIP ON THE BOARD.
1513   0564~            ; IF THERE ARE TWO CHIPS ON THE BOARD, THIS MEANS THE COMMON
1514   0564~            ; BANK WILL APPEAR IN THE "MIDDLE" OF THE PHYSICAL RAM BANKS.
1515   0564~            ; ROMWBW NEEDS THE COMMON BANK TO BE AT THE LAST BANK OF PHYSICAL
1516   0564~            ; RAM IN ORDER TO HAVE SEQUENTIAL RAM BANKS AVAILABLE FOR THE
1517   0564~            ; RAM DISK.  TO WORK AROUND THIS, WE FLIP THE HIGH BIT OF THE
1518   0564~            ; BANK ID FOR AN MBC SYSTEM IFF IT HAS 2 CHIPS (256K OR 1024K).
1519   0564~            ; THE CODE BELOW GENERATES THE CORRECT MASK TO ACCOMPLISH THIS
1520   0564~            ; AND THEN POKES THE MASK INTO AN XOR INSTRUCTION IN THE MBC
1521   0564~            ; MEMORY MANAGER.
1522   0564~            ;
1523   0564~              #IF (MEMMGR == MM_MBC)
1524   0564~            ;
1525   0564~            	;LD	HL,CB_RAMBANKS		; IN NUMBER OF RAMBANKS DETECTED FOR MBC
1526   0564~            	LD	A,%11101011		; IS 4 (128KB) OR 16 (512KB) THEN
1527   0564~            	;AND	(HL)			; ZERO THE LAST BANK MASK OTHERWISE
1528   0564~            	AND	E			; ZERO THE LAST BANK MASK OTHERWISE
1529   0564~            	JR	Z,MBC_SINGLE		; CALCULATE THE LAST BANK MASK (BANKS/2)
1530   0564~            	RRA				; 256K = %00000100, 1024K = %00010000
1531   0564~            MBC_SINGLE:
1532   0564~            	LD	(HBX_MBCMSK),A		
1533   0564~            ;
1534   0564~              #ENDIF
1535   0564~            ;
1536   0564~            	; RETURN TO ORIGINAL BANK
1537   0564~            	POP	AF
1538   0564~            	CALL	HBX_BNKSEL
1539   0564~            	LD	A,E			; RETURN BANK COUNT
1540   0564~            	LD	($FFEA),A		; STASH HERE FOR A BIT
1541   0564~            	RET
1542   0564~            ;
1543   0564~            RS_ARY	.EQU	$
1544   0564~            ;
1545   0564~            RS_LEN	.EQU	$ - RS_START
1546   0564~            	.ORG	RS_IMAGE + RS_LEN
1547   0564~            ;
1548   0564             #ELSE
1549   0564             ;
1550   0564             ; MBC RUNTIME MEMORY SIZE ADJUSTMENT
1551   0564             ;
1552   0564             ; THE MBC RAM BOARD CAN CONTAIN 1 OR 2 RAM CHIPS.  THEY CAN BE
1553   0564             ; EITHER 128K OR 512K EACH.  SO THE MBC RAM BOARD CAN HAVE A
1554   0564             ; TOTAL OF 128K, 256K, 512K, OR 1024K.  THE COMMON (HIMEM) RAM
1555   0564             ; IS ALWAYS MAPPED TO THE LAST 32K OF THE FIRST CHIP ON THE BOARD.
1556   0564             ; IF THERE ARE TWO CHIPS ON THE BOARD, THIS MEANS THE COMMON
1557   0564             ; BANK WILL APPEAR IN THE "MIDDLE" OF THE PHYSICAL RAM BANKS.
1558   0564             ; ROMWBW NEEDS THE COMMON BANK TO BE AT THE LAST BANK OF PHYSICAL
1559   0564             ; RAM IN ORDER TO HAVE SEQUENTIAL RAM BANKS AVAILABLE FOR THE
1560   0564             ; RAM DISK.  TO WORK AROUND THIS, WE FLIP THE HIGH BIT OF THE
1561   0564             ; BANK ID FOR AN MBC SYSTEM IFF IT HAS 2 CHIPS (256K OR 1024K).
1562   0564             ; THE CODE BELOW GENERATES THE CORRECT MASK TO ACCOMPLISH THIS
1563   0564             ; AND THEN POKES THE MASK INTO AN XOR INSTRUCTION IN THE MBC
1564   0564             ; MEMORY MANAGER.
1565   0564             ;
1566   0564~              #IF (MEMMGR == MM_MBC)
1567   0564~            	LD	HL,CB_RAMBANKS		; IF NUMBER OF RAMBANKS DETECTED FOR MBC
1568   0564~            	LD	A,%11101011		; IS 4 (128KB) OR 16 (512KB) THEN
1569   0564~            	AND	(HL)			; ZERO THE LAST BANK MASK OTHERWISE
1570   0564~            	JR	Z,MBC_SINGLE		; CALCULATE THE LAST BANK MASK (BANKS/2)
1571   0564~            	RRA				; 256K = %00000100, 1024K = %00010000
1572   0564~            MBC_SINGLE:
1573   0564~            	LD	(HBX_MBCMSK),A		
1574   0564               #ENDIF
1575   0564             ;
1576   0564             #ENDIF
1577   0564             ;
1578   0564             ; IF THIS IS A ROM-LESS SYSTEM, THEN WE NEED TO COPY THE PAYLOAD
1579   0564             ; (LOADER, MONITOR, ZSDOS) THAT HAS BEEN LOADED TO PHYSICAL RAM
1580   0564             ; BANKS 0 AND 1 TO THE USER TPA BANK TO RUN AFTER BOOT.
1581   0564             ; IT IS DONE PRIOR TO COPYING HBIOS TO IT'S FINAL BANK BECAUSE
1582   0564             ; THE PAYLOAD MAY EXTEND INTO THE HBIOS OPERATING BANK.  THIS
1583   0564             ; HAPPENS PRIMARILY IN THE CASE WHERE THE
1584   0564             ; SYSTEM HAS THE MINIMUM 128KB OF RAM.
1585   0564             ;
1586   0564             #IFDEF ROMBOOT
1587   0564~              #IF (ROMSIZE == 0)
1588   0564~             ; 
1589   0564~            	; THE PAYLOAD IS LIKELY TO CROSS OVER THE RAM BANK 0/1
1590   0564~            	; BOUNDARY.  BNKCPY DOES NOT HANDLE THIS BECAUSE IT ASSUMES
1591   0564~            	; THE COMMON BANK IS USED AFTER PASSING OVER THE BANK
1592   0564~            	; BOUNDARY.  WE WORK AROUND THAT HERE BY DOING TWO COPIES.
1593   0564~            	; THE FIRST ONE HANDLES THE PORTION OF THE PAYLOAD FROM THE
1594   0564~            	; END OF HBIOS TO THE BANK BOUNDARY ($8000).  THE SECOND
1595   0564~            	; ONE HANDLES THE PORTION THAT EXTENDS INTO THE SECOND
1596   0564~            	; PHYSICAL RAM BANK.
1597   0564~            ;
1598   0564~            	; COPY PORTION OF PAYLOAD FOLLOWING HBIOS TO THE BANK
1599   0564~            	; BOUNDARY AT $8000 INTO START OF TPA.
1600   0564~            	LD	A,BID_RAM0
1601   0564~            	LD	(HB_SRCBNK),A
1602   0564~            	LD	A,BID_USR
1603   0564~            	LD	(HB_DSTBNK),A
1604   0564~            	LD	HL,HB_END
1605   0564~            	LD	DE,0
1606   0564~            	LD	BC,$8000-HB_END
1607   0564~            ;
1608   0564~                #IF (MEMMGR == MM_Z280)
1609   0564~            	CALL	Z280_BNKCPY
1610   0564~                #ELSE
1611   0564~            	CALL	HBX_BNKCPY
1612   0564~                #ENDIF
1613   0564~            ;
1614   0564~            	; COPY REMAINDER OF PAYLOAD EXTENDING INTO THE SECOND PHYSICAL
1615   0564~            	; RAM BANK.  NOTE THAT THE DESTINATION ADDRESS (DE) IS
1616   0564~            	; ALREADY CORRECT FROM THE PRIOR COPY.
1617   0564~            	LD	A,BID_RAM0+1
1618   0564~            	LD	(HB_SRCBNK),A
1619   0564~            	LD	HL,$0000
1620   0564~            	; DE IS ALREADY CORRECT
1621   0564~            	LD	BC,$8000-($8000-HB_END)
1622   0564~            ;
1623   0564~                #IF (MEMMGR == MM_Z280)
1624   0564~            	CALL	Z280_BNKCPY
1625   0564~                #ELSE
1626   0564~            	CALL	HBX_BNKCPY
1627   0564~                #ENDIF
1628   0564~            ;
1629   0564               #ENDIF
1630   0564             ;
1631   0564             #ENDIF
1632   0564             ;
1633   0564             ; IF ALREADY EXECUTING IN RAM, BYPASS RAM BANK INSTALLATION
1634   0564             ;
1635   0564 3A 8B 05    	LD	A,(HB_RAMFLAG)
1636   0567 B7          	OR	A
1637   0568 20 22       	JR	NZ,HB_START1
1638   056A             ;
1639   056A             ; INSTALL HBIOS IN RAM BANK
1640   056A             ;
1641   056A 3A E0 FF    	LD	A,(HB_CURBNK)
1642   056D 32 E4 FF    	LD	(HB_SRCBNK),A
1643   0570 3E 8D       	LD	A,BID_BIOS
1644   0572 32 E7 FF    	LD	(HB_DSTBNK),A
1645   0575 21 00 00    	LD	HL,0
1646   0578 11 00 00    	LD	DE,0
1647   057B 01 00 80    	LD	BC,$8000
1648   057E~            #IF (MEMMGR == MM_Z280)
1649   057E~            	CALL	Z280_BNKCPY
1650   057E             #ELSE
1651   057E CD 3D FE    	CALL	HBX_BNKCPY
1652   0581             #ENDIF
1653   0581             ;
1654   0581             ; TRANSITION TO HBIOS IN RAM BANK
1655   0581             ;
1656   0581~            #IF (MEMMGR == MM_Z280)
1657   0581~            	LD	A,BID_BIOS
1658   0581~            	LD	B,$10			; FIRST SYSTEM PDR
1659   0581~            	CALL	Z280_BNKSEL
1660   0581~            	JR	HB_START1
1661   0581             #ELSE
1662   0581 3E 8D       	LD	A,BID_BIOS		; BIOS BANK ID
1663   0583 DD 21 8C 05 	LD	IX,HB_START1		; EXECUTION RESUMES HERE
1664   0587 CD 8E FE    	CALL	HBX_BNKCALL		; CONTINUE IN RAM BANK, DO NOT RETURN
1665   058A 76          	HALT				; WE SHOULD NOT COME BACK HERE!
1666   058B             #ENDIF
1667   058B             ;
1668   058B 00          HB_RAMFLAG	.DB	FALSE		; INITIALLY FALSE, SET TO TRUE BELOW AFTER RAM TRANSITION
1669   058C             ;
1670   058C             ; EXECUTION RESUMES HERE AFTER SWITCH TO RAM BANK
1671   058C             ;
1672   058C             HB_START1:				; BNKCALL ARRIVES HERE, BUT NOW RUNNING IN RAM BANK
1673   058C             ;
1674   058C             	; WE RESET THE STACK HERE BECAUSE WE ARE NOT GOING TO RETURN
1675   058C             	; FROM THE BNKCALL.  REMEMBER THAT WE STORED A COUPLE BYTES
1676   058C             	; RIGHT BELOW HBX_LOC, SO THE STACK IS SET TO START JUST BELOW
1677   058C             	; THAT.
1678   058C 31 FE FD    	LD	SP,HBX_LOC - 2		; RESET STACK
1679   058F             ;
1680   058F             	; NOTIFY THAT WE MADE THE TRANSITION!
1681   058F             	DIAG(DIAG_03)
1681   058F             
1682   058F             	LED(%00000010)
1682   058F             
1683   058F             ;
1684   058F             	; SET THE IN-RAM FLAG
1685   058F 3E FF       	LD	A,TRUE			; ACCUM := TRUE
1686   0591 32 8B 05    	LD	(HB_RAMFLAG),A		; SET RAMFLAG
1687   0594             ;
1688   0594             	; RECOVER DATA PASSED PRIOR TO RAM TRANSITION
1689   0594             	; (HBX_LOC - 1) = BATCOND, (HBX_LOC - 2) = APPBNK
1690   0594 E1          	POP	HL			; POP 2 BYTES
1691   0595 7C          	LD	A,H			; GET FIRST BYTE PUSHED
1692   0596 32 69 29    	LD	(HB_BATCOND),A		; ... AND SAVE AS BAT COND
1693   0599             ;
1694   0599~            #IFDEF APPBOOT
1695   0599~            	LD	A,L			; GET SECOND BYTE PUSHED
1696   0599~            	LD	(HB_APPBNK),A		; ... AND SAVE AS APPBNK
1697   0599             #ENDIF
1698   0599             ;
1699   0599~            #IF (MEMMGR == MM_Z280)
1700   0599~            	; NOW POINT TO RAM COPY OF Z280 INT/TRAP TABLE
1701   0599~            	; HL IS TOP 16 BITS OF PHYSICAL ADDRESS OF IVT
1702   0599~            	; IVT *MUST* BE ON A 4K BOUNDARY
1703   0599~            	LD	C,Z280_VPR
1704   0599~            	LD	HL,0 + ((((BID_BIOS & $7F) * 8) + (1 << (RAMLOC - 12))) << 4) + (Z280_IVT >> 8)
1705   0599~            	LDCTL	(C),HL
1706   0599             #ENDIF
1707   0599             ;
1708   0599             ; IF APPBOOT, WE NEED TO FIX UP A FEW THINGS IN PAGE ZERO
1709   0599             ;
1710   0599~            #IFDEF APPBOOT
1711   0599~            ;
1712   0599~            	; MAKE SURE RST 08 VECTOR IS RIGHT
1713   0599~            	LD	A,$C3
1714   0599~            	LD	($0008),A
1715   0599~            	LD	HL,HB_INVOKE
1716   0599~            	LD	($0009),HL
1717   0599~            ;
1718   0599~            	; MAKE SURE IM1 INT VECTOR IS RIGHT
1719   0599~              #IF (INTMODE == 1)
1720   0599~            	; JP INT_IM1 IF INTERRUPT MODE ACTIVE
1721   0599~            	LD	A,$C3
1722   0599~            	LD	($0038),A
1723   0599~            	LD	HL,INT_IM1
1724   0599~            	LD	($0039),HL
1725   0599~              #ELSE
1726   0599~            	; RETI ($ED, $4D) IF NON-INTERRUPT MODE
1727   0599~            	LD	HL,$0038
1728   0599~            	LD	(HL),$ED
1729   0599~            	INC	HL
1730   0599~            	LD	(HL),$4D
1731   0599~              #ENDIF
1732   0599             #ENDIF
1733   0599             ;
1734   0599~            #IF FALSE
1735   0599~            ;
1736   0599~            ; POPULATE THE CRITICAL RAM BANK NUMBERS.
1737   0599~            ;
1738   0599~            ; ASSUME THAT CB_RAMBANKS IS THE NUMBER OF 32K RAM BANKS THAT HAS BEEN SET EITHER
1739   0599~            ; AT ASSEMBLY TIME OR BY PROBING THE ACTUAL AVAILABLE MEMORY (NOT IMPLEMENTED YET).
1740   0599~            ;
1741   0599~            	LD	A,(CB_RAMBANKS)			; CALCULATE TOP RAMBANK
1742   0599~            	ADD	A,BID_RAM0			; AS FIRST RAMBANK +
1743   0599~            	DEC	A				; #RAMBANKS - 1
1744   0599~            ;
1745   0599~            	LD	HL,CB_BIDCOM
1746   0599~            	LD	B,4
1747   0599~            CB_IDS:	LD	(HL),A				; POPULATE CB_BIDCOM
1748   0599~            	INC	HL				; POPULATE CB_BIDUSR
1749   0599~            	DEC	A				; POPULATE CB_BIDBIOS
1750   0599~            	DJNZ	CB_IDS				; POPULATE CB_BIDAUX
1751   0599~            ;
1752   0599~            	LD	A,(CB_BIDUSR)
1753   0599~            	LD	(HB_SRCBNK),A			; POPULATE HB_SRCBNK
1754   0599~            	LD	(HB_DSTBNK),A			; POPULATE HB_DSTBNK		
1755   0599~            ;
1756   0599~            	LD	A,BID_RAM0			; POPULATE CB_BIDRAMD0	; START RAMBANK
1757   0599~            	LD	(HL),A
1758   0599~            	INC	HL
1759   0599~            ;
1760   0599~            	LD	A,(CB_RAMBANKS)			; POPULATE CB_BIDRAMDN	; END RAMBANK
1761   0599~            	DEC	A
1762   0599~            	SUB	TOT_RAM_RB
1763   0599~            	LD	(HL),A
1764   0599~            ;
1765   0599             #ENDIF
1766   0599             ;
1767   0599             ;==================================================================================================
1768   0599             ;	RECOVERY MODE
1769   0599             ;==================================================================================================
1770   0599             ;
1771   0599             ;	PLATFORM SPECIFIC CODE FOR DETECTING RECOVERY MODE SWITCH
1772   0599             ;
1773   0599~            #IF (BT_REC_TYPE != BT_REC_NONE)
1774   0599~              #IF (BT_REC_TYPE == BT_REC_FORCE)
1775   0599~            	LD	A,1			; SET FOR RECOVERY MODE
1776   0599~            	LD	(HB_BOOT_REC),A		; SAVE FOR LATER
1777   0599~              #ENDIF
1778   0599~              #IF ((PLATFORM == PLT_SBC) | (PLATFORM == PLT_MBC))
1779   0599~                #IF (BT_REC_TYPE == BT_REC_SBC01)
1780   0599~            	LD	A,%00100000		; DISABLE RTC AND
1781   0599~            	OUT	(RTCIO),A		; DRQ DRIVER READ
1782   0599~            	IN	A,(RTCIO)		; BIT 0 (DRQ).
1783   0599~            	CPL				; PULLED HIGH
1784   0599~            	AND	1			; IS RECOVERY MODE
1785   0599~            	LD	(HB_BOOT_REC),A		; SAVE FOR LATER
1786   0599~                #ENDIF
1787   0599~                #IF (BT_REC_TYPE == BT_REC_SBC1B)
1788   0599~            	IN	A,(RTCIO)		; RTC PORT, BIT 6 HAS THE
1789   0599~            	BIT	6,A			; STATE OF CONFIG JUMPER
1790   0599~            	LD	A,1			; JUMPER INSTALLED
1791   0599~            	JR	Z,SAVE_REC_M		; IS RECOVERY MODE
1792   0599~            	LD	A,0
1793   0599~            SAVE_REC_M:
1794   0599~            	LD	(HB_BOOT_REC),A		; SAVE FOR LATER
1795   0599~                #ENDIF
1796   0599~                #IF (BT_REC_TYPE == BT_REC_SBCRI)
1797   0599~            	IN	A,($68 + 6)		; UART_MSR MODEM
1798   0599~            	BIT	6,A			; STATUS REGISTER
1799   0599~            	LD	A,0			; BIT 6
1800   0599~            	JR	Z,SAVE_REC_M		; IS RECOVERY MODE
1801   0599~            	LD	A,1
1802   0599~            SAVE_REC_M:
1803   0599~            	LD	(HB_BOOT_REC),A		; SAVE FOR LATER
1804   0599~                #ENDIF
1805   0599~              #ENDIF
1806   0599             #ENDIF
1807   0599             ;
1808   0599             	DIAG(DIAG_04)
1808   0599             
1809   0599             ;
1810   0599~            #IF (WBWDEBUG == USEMIO)		; BUFFER OUTPUT UNTIL
1811   0599~            	CALL	MIO_INIT		; WE GET TO BOOT MESSAGE
1812   0599             #ENDIF
1813   0599             ;
1814   0599~            #IF FALSE
1815   0599~            ;
1816   0599~            ; TEST DEBUG ***************************************************************************************
1817   0599~            ;
1818   0599~            	PRTS("DEBUG-IVT$")
1818   0599~            	PRTS("DEBUG-IVT$")
1819   0599~            	LD	DE,HB_IVT
1820   0599~            	CALL	DUMP_BUFFER
1821   0599~            	CALL	NEWLINE
1822   0599~            ;
1823   0599~            ; TEST DEBUG ***************************************************************************************
1824   0599~            ;
1825   0599             #ENDIF
1826   0599             ;
1827   0599             ; DISCOVER CPU TYPE
1828   0599             ;
1829   0599             ; SOME OF THIS CODE IS DERIVED FROM UNA BY JOHN COFFMAN
1830   0599             ;
1831   0599             ;	0: Z80
1832   0599             ;	1: Z80180 - ORIGINAL Z180 (EQUIVALENT TO HD64180)
1833   0599             ;	2: Z8S180 - ORIGINAL S-CLASS, REV. K, AKA SL1960, NO ASCI BRG
1834   0599             ;	3: Z8S180 - REVISED S-CLASS, REV. N, W/ ASCI BRG
1835   0599             ;	4: Z8280
1836   0599             ;
1837   0599 21 00 00    	LD	HL,0		; L = 0 MEANS Z80
1838   059C             ;
1839   059C~            #IF (CPUFAM == CPU_Z180)
1840   059C~            ;
1841   059C~            	; TEST FOR ORIGINAL Z180 USING MLT
1842   059C~            	LD	DE,$0506	; 5 X 6
1843   059C~            	MLT	DE		; DE = 30 IF Z180
1844   059C~            	LD	A,E		; CHECK IF MULTIPLY HAPPENED
1845   059C~            	CP	30
1846   059C~            	JR	NZ,HB_CPU1	; IT IS A Z80 IF != 30
1847   059C~            	INC	L		; FLAG Z80180 OR BETTER
1848   059C~            ;
1849   059C~            	; TEST FOR OLDER S-CLASS (REV K)
1850   059C~            	IN0	A,(Z180_CCR)	; SUPPOSEDLY ONLY ON S-CLASS
1851   059C~            	INC	A		; FF -> 0
1852   059C~            	JR	Z,HB_CPU1
1853   059C~            	INC	L		; FLAG Z8S180 REV K (SL1960) OR BETTER
1854   059C~            ;
1855   059C~            	; TEST FOR NEWER S-CLASS (REV N)
1856   059C~            	; ON OLDER S-CLASS, ASCI TIME CONSTANT REG DOES NOT EXIST
1857   059C~            	; AND WILL ALWYAS READ BACK AS $FF
1858   059C~            	OUT0	(Z180_ASTC1L),D	; D = 0 AT THIS POINT
1859   059C~            	IN0	A,(Z180_ASTC1L)	; ASCI TIME CONSTANT REG
1860   059C~            	INC	A		; FF -> 0
1861   059C~            	JR	Z,HB_CPU1
1862   059C~            	INC	L		; FLAG Z8S180 REV N W/ ASCI BRG
1863   059C~            ;
1864   059C             #ENDIF
1865   059C             ;
1866   059C~            #IF (CPUFAM == CPU_Z280)
1867   059C~            ;
1868   059C~            	; TEST FOR Z280 PER ZILOG DOC
1869   059C~            	LD	A,$40		; INITIALIZE THE OPERAND
1870   059C~            	.DB	$CB,$37		; THIS INSTRUCTION WILL SET THE S FLAG
1871   059C~            				; ON THE Z80 CPU AND CLEAR THE S FLAG
1872   059C~            				; ON THE Z280 MPU.
1873   059C~            	JP	M,HB_CPU1	; IF Z80, SKIP AHEAD
1874   059C~            	LD	L,4		; WE ARE Z280
1875   059C~            ;
1876   059C             #ENDIF
1877   059C             ;
1878   059C             HB_CPU1:
1879   059C 7D          	LD	A,L
1880   059D 32 66 29    	LD	(HB_CPUTYPE),A
1881   05A0             ;
1882   05A0~            #IF (DSRTCENABLE)
1883   05A0~            	CALL	DSRTC_PREINIT
1884   05A0             #ENDIF
1885   05A0             ;
1886   05A0~            #IF (SKZENABLE)
1887   05A0~            ;
1888   05A0~            	; SET THE SK Z80-512K UART CLK2 DIVIDER AS
1889   05A0~            	; CONFIGURED.  NOTE THAT THIS IMPLICITLY
1890   05A0~            	; CLEARS THE WATCHDOG BIT.  THE WATCHDOG
1891   05A0~            	; WILL BE ENABLED LATER IF CONFIGURED.
1892   05A0~            	LD	A,SKZDIV	; GET DIVIDER CODE
1893   05A0~            	OUT	($6D),A		; IMPLEMENT IT
1894   05A0~            ;
1895   05A0             #ENDIF
1896   05A0             ;
1897   05A0             	DIAG(DIAG_05)
1897   05A0             
1898   05A0             ;
1899   05A0             ; INIT OSCILLATOR SPEED FROM CONFIG
1900   05A0             ;
1901   05A0 21 00 40    	LD	HL,CPUOSC / 1000	; OSC SPD IN KHZ
1902   05A3 22 67 29    	LD	(HB_CPUOSC),HL		; INIT HB_CPUOSC DEFAULT
1903   05A6             ;
1904   05A6             ; ATTEMPT DYNAMIC CPU SPEED DERIVATION
1905   05A6             ; NOTE THAT FOR PLATFORMS WITH SOFTWARE SELECTABLE CPU SPEED,
1906   05A6             ; THIS IS BEING DONE WITH THE CPU SPEED SET TO THE LOWEST
1907   05A6             ; POSSIBLE SETTING.  THE FINAL CPU SPEED WILL BE ADJUSTED
1908   05A6             ; LATER.
1909   05A6             ;
1910   05A6 CD 5D 23    	CALL	HB_CPUSPD		; DYNAMIC CPU SPEED DETECTION
1911   05A9 20 03       	JR	NZ,HB_CPU2		; SKIP AHEAD IF FAILED
1912   05AB             ;
1913   05AB             ; RECORD THE UPDATED CPU OSCILLATOR SPEED
1914   05AB             ;
1915   05AB~            #IF ((CPUFAM == CPU_Z180) | (CPUSPDCAP == SPD_HILO))
1916   05AB~            	; SPEED MEASURED WILL BE HALF OSCILLATOR SPEED
1917   05AB~            	; SO RECORD DOUBLE THE MEASURED VALUE
1918   05AB~            	SLA	L
1919   05AB~            	RL	H
1920   05AB             #ENDIF
1921   05AB             ;
1922   05AB 22 67 29    	LD	(HB_CPUOSC),HL		; RECORD MEASURED SPEED
1923   05AE             ;
1924   05AE             HB_CPU2:
1925   05AE             ;
1926   05AE             ; INIT CPUKHZ BASED ON OSCILLATOR SPEED
1927   05AE             ;
1928   05AE 2A 67 29    	LD	HL,(HB_CPUOSC)
1929   05B1             ;
1930   05B1             ; TRANSITION TO FINAL DESIRED CPU SPEED FOR THOSE PLATFORMS
1931   05B1             ; THAT SUPPORT SOFTWARE SELECTABLE CPU SPEED.  UPDATE CB_CPUKHZ
1932   05B1             ; IN HCB AS WE DO THIS.
1933   05B1             ;
1934   05B1~            #IF ((CPUSPDCAP==SPD_HILO) & (PLATFORM==PLT_MBC))
1935   05B1~              #IF (CPUSPDDEF==SPD_HIGH)
1936   05B1~            	; SET HIGH SPEED VIA RTC LATCH
1937   05B1~            	LD	A,(HB_RTCVAL)
1938   05B1~            	OR	%00001000		; SET HI SPEED BIT
1939   05B1~            	LD	(HB_RTCVAL),A		; SAVE SHADOW
1940   05B1~            	OUT	(RTCIO),A		; IMPLEMENT
1941   05B1~            	; HL IS ALREADY CORRECT FOR FULL SPEED OPERATION
1942   05B1~              #ELSE
1943   05B1~            	; ADJUST HL TO REFLECT HALF SPEED OPERATION
1944   05B1~            	SRL	H		; ADJUST HL ASSUMING
1945   05B1~            	RR	L		; HALF SPEED OPERATION
1946   05B1~              #ENDIF
1947   05B1             #ENDIF
1948   05B1             ;
1949   05B1~            #IF ((CPUSPDCAP==SPD_HILO) & (PLATFORM==PLT_SBC))
1950   05B1~              #IF (CPUSPDDEF==SPD_HIGH)
1951   05B1~            	; SET HIGH SPEED VIA RTC LATCH
1952   05B1~            	LD	A,(HB_RTCVAL)
1953   05B1~            	AND	~%00001000		; CLEAR HI SPEED BIT
1954   05B1~            	LD	(HB_RTCVAL),A		; SAVE SHADOW
1955   05B1~            	OUT	(RTCIO),A		; IMPLEMENT
1956   05B1~            	; HL IS ALREADY CORRECT FOR FULL SPEED OPERATION
1957   05B1~              #ELSE
1958   05B1~            	; ADJUST HL TO REFLECT HALF SPEED OPERATION
1959   05B1~            	SRL	H		; ADJUST HL ASSUMING
1960   05B1~            	RR	L		; HALF SPEED OPERATION
1961   05B1~              #ENDIF
1962   05B1             #ENDIF
1963   05B1             ;
1964   05B1~            #IF (CPUFAM == CPU_Z180)
1965   05B1~            ;
1966   05B1~            	LD	HL,(HB_CPUOSC)	; INIT HL TO CPU OSC FREQ (KHZ)
1967   05B1~            ;
1968   05B1~            	; ADJUST HL TO REFLECT HALF SPEED OPERATION
1969   05B1~            	SRL	H		; ADJUST HL ASSUMING
1970   05B1~            	RR	L		; HALF SPEED OPERATION
1971   05B1~            ;	
1972   05B1~              #IF (Z180_CLKDIV >= 1)
1973   05B1~            	LD	A,(HB_CPUTYPE)	; GET CPU TYPE
1974   05B1~            	CP	2		; Z8S180 REV K OR BETTER?
1975   05B1~            	JR	C,HB_CPU3	; IF NOT, NOT POSSIBLE!
1976   05B1~            	; SET CLOCK DIVIDE TO 1 RESULTING IN FULL XTAL SPEED
1977   05B1~            	LD	A,$80
1978   05B1~            	OUT0	(Z180_CCR),A
1979   05B1~            	; ADJUST HL TO REFLECT FULL SPEED OPERATION
1980   05B1~            	SLA	L
1981   05B1~            	RL	H
1982   05B1~              #ENDIF
1983   05B1~            ;
1984   05B1~              #IF (Z180_CLKDIV >= 2)
1985   05B1~            	LD	A,(HB_CPUTYPE)	; GET CPU TYPE
1986   05B1~            	CP	3		; Z8S180 REV N OR BETTER?
1987   05B1~            	JR	C,HB_CPU3	; IF NOT, NOT POSSIBLE!
1988   05B1~            	; SET CPU MULTIPLIER TO 1 RESULTING IN XTAL * 2 SPEED
1989   05B1~            	; ALSO SET CCR AGAIN BECAUSE OF REPORTS THAT CCR
1990   05B1~            	; *MUST* BE SET AFTER CMR.
1991   05B1~            	LD	A,$80
1992   05B1~            	OUT0	(Z180_CMR),A	; CPU MULTIPLIER
1993   05B1~            	OUT0	(Z180_CCR),A	; CLOCK DIVIDE
1994   05B1~            	; ADJUST HL TO REFLECT DOUBLE SPEED OPERATION
1995   05B1~            	SLA	L
1996   05B1~            	RL	H
1997   05B1~              #ENDIF
1998   05B1~            ;
1999   05B1~            HB_CPU3:
2000   05B1             #ENDIF
2001   05B1             ;
2002   05B1             ; HL SHOULD NOW HAVE FINAL CPU RUNNING SPEED IN KHZ.
2003   05B1             ; UPDATE CB_CPUMHZ/CB_CPUKHZ WITH THIS VALUE.
2004   05B1             ;
2005   05B1 22 09 01    	LD	(CB_CPUKHZ),HL		; UPDATE CPUKHZ
2006   05B4 11 E8 03    	LD	DE,1000			; SET UP TO DIV BY 1000 FOR MHZ
2007   05B7 CD 57 1B    	CALL	DIV16			; BC=CPU MHZ, HL=REMAINDER
2008   05BA 11 F4 01    	LD	DE,500			; SET UP TO ROUND UP
2009   05BD AF          	XOR	A			; IF WITHIN 500 KHZ
2010   05BE ED 52       	SBC	HL,DE			; REMAINDER - 500
2011   05C0 3F          	CCF				; COMPLEMENT CF
2012   05C1 89          	ADC	A,C			; C -> A; ADD CF FOR ROUNDING
2013   05C2 32 08 01    	LD	(CB_CPUMHZ),A		; SAVE IT
2014   05C5             ;
2015   05C5~            #IF (CPUFAM == CPU_Z180)
2016   05C5~            ;
2017   05C5~            	; SET FINAL DESIRED WAIT STATES
2018   05C5~            	LD	A,0 + (Z180_MEMWAIT << 6) | (Z180_IOWAIT << 4)
2019   05C5~            	OUT0	(Z180_DCNTL),A
2020   05C5~            ;
2021   05C5             #ENDIF
2022   05C5             ;
2023   05C5~            #IF (CPUFAM == CPU_Z280)
2024   05C5~            ;
2025   05C5~            	LD	C,Z280_BTCR		; BUS TIMING AND CONTROL REG
2026   05C5~            	LDCTL	HL,(C)
2027   05C5~            	LD	A,L			; PUT IN A
2028   05C5~            	AND	%00111100		; CLEAR DC,HM, AND IO FIELDS
2029   05C5~            	OR	Z280_INTWAIT << 6	; SET INT ACK WAIT STATE BITS (DC)
2030   05C5~            	OR	Z280_MEMHIWAIT << 2	; SET HIGH 8MB WAIT STATE BITS (HM)
2031   05C5~            	OR	Z280_IOWAIT		; SET I/O WAIT STATE BITS
2032   05C5~            	LD	L,A			; BACK TO L
2033   05C5~            	LDCTL	(C),HL
2034   05C5~            ;
2035   05C5~            	LD	C,Z280_BTIR		; BUS TIMING AND INIT REG
2036   05C5~            	LDCTL	HL,(C)
2037   05C5~            	LD	A,L			; PUT IN A
2038   05C5~            	AND	%11110011		; CLEAR LM FIELD
2039   05C5~            	OR	Z280_MEMLOWAIT << 2	; SET LOW 8MB WAIT STATE BITS
2040   05C5~            	LD	L,A			; BACK TO L
2041   05C5~            	LDCTL	(C),HL
2042   05C5~            ;
2043   05C5             #ENDIF
2044   05C5             ;
2045   05C5 3A 08 01    	LD	A,(CB_CPUMHZ)		; CPU SPEED TO ACCUM AND INIT
2046   05C8 CD 1C 1B    	CALL	DELAY_INIT		; .. SPEED COMPENSATED DELAY
2047   05CB             ;
2048   05CB~            #IF (INTMODE == 2)
2049   05CB~            	; SETUP Z80 IVT AND INT MODE 2
2050   05CB~            	LD	A,HBX_IVT >> 8		; SETUP HI BYTE OF IVT ADDRESS
2051   05CB~            	LD	I,A			; ... AND PLACE IT IN I REGISTER
2052   05CB~            
2053   05CB~              #IF (CPUFAM == CPU_Z180)
2054   05CB~            	; SETUP Z180 IVT
2055   05CB~            	XOR	A			; SETUP LO BYTE OF IVT ADDRESS
2056   05CB~            	OUT0	(Z180_IL),A		; ... AND PLACE IN Z180 IL REGISTER
2057   05CB~              #ENDIF
2058   05CB~            
2059   05CB~            	IM	2			; SWITCH TO INT MODE 2
2060   05CB             #ENDIF
2061   05CB             ;
2062   05CB~            #IF (INTMODE == 3)
2063   05CB~            ;
2064   05CB~            	; SETUP Z280 INT A FOR VECTORED INTERRUPTS
2065   05CB~            	LD	HL,%0010000000000000
2066   05CB~            	LD	C,Z280_ISR
2067   05CB~            	LDCTL	(C),HL
2068   05CB~            ;
2069   05CB~            	IM	3
2070   05CB~            ;
2071   05CB             #ENDIF
2072   05CB             ;
2073   05CB~            #IF (PLATFORM == PLT_SBC)
2074   05CB~            ;
2075   05CB~              #IF (HTIMENABLE)			; SIMH TIMER
2076   05CB~            ;
2077   05CB~                #IF (INTMODE == 1)
2078   05CB~            	LD	HL,HB_TIMINT
2079   05CB~            	CALL	HB_ADDIM1		; ADD TO IM1 CALL LIST
2080   05CB~                #ENDIF
2081   05CB~            
2082   05CB~              #ENDIF
2083   05CB~            ;
2084   05CB             #ENDIF
2085   05CB             ;
2086   05CB~            #IF (KIOENABLE)
2087   05CB~            	CALL	KIO_PREINIT
2088   05CB             #ENDIF
2089   05CB             ;
2090   05CB~            #IF (CTCENABLE)
2091   05CB~            	CALL	CTC_PREINIT
2092   05CB             #ENDIF
2093   05CB             ;
2094   05CB~            #IF (CPUFAM == CPU_Z180)
2095   05CB~            ;
2096   05CB~              #IF (INTMODE == 2)
2097   05CB~            ;
2098   05CB~            	; MASK ALL EXTERNAL INTERRUPTS FOR NOW
2099   05CB~            	LD	A,$01			; INT0 ENABLED, INT1-2 DISABLED
2100   05CB~            	OUT0	(Z180_ITC),A		; WRITE TO INT/TRAP CONTROL REGISTER
2101   05CB~            ;
2102   05CB~                #IF (Z180_TIMER)
2103   05CB~            ;
2104   05CB~            	; SETUP Z180 TIMER0 INTERRUPT VECTOR IN IVT
2105   05CB~            	LD	HL,HB_TIMINT
2106   05CB~            	LD	(IVT(INT_TIM0)),HL	; Z180 TIMER 0
2107   05CB~            
2108   05CB~            	; SETUP PERIODIC TIMER INTERRUPT ON TIMER 0
2109   05CB~            	; *** THIS ASSUMES A TICKFREQ OF 50HZ!!! ***
2110   05CB~            ;
2111   05CB~            #IF (TICKFREQ != 50)
2112   05CB~            	.ECHO "TICKFREQ *MUST* BE 50 FOR Z180 TIMER\n"
2113   05CB~            	!!!
2114   05CB~            #ENDIF
2115   05CB~            ;
2116   05CB~            	; Z180 PRESCALES THE COUNTER BY 20 SO,
2117   05CB~            	; RLDR = CPU CLK / 20 / TICKFREQ
2118   05CB~            	; IF WE ASSUME TICKFREQ = 50, WE CAN SIMPIFY TO
2119   05CB~            	; RLDR = CPU CLK / 1000
2120   05CB~            	; NOW IF DIVIDE BOTH SIDES BY 1000, WE CAN USE
2121   05CB~            	; CPUKHZ VALUE AND SIMPLIFY TO
2122   05CB~            	; RLDR = CPUKHZ
2123   05CB~            	XOR	A			; ALL BITS ZERO
2124   05CB~            	OUT0	(Z180_TCR),A		; ... INHIBITS TIMER OPERATION
2125   05CB~            	LD	HL,(CB_CPUKHZ)		; 50HZ = 18432000 / 20 / 50 / X, SO X = CPU KHZ
2126   05CB~            	OUT0	(Z180_TMDR0L),L		; INITIALIZE TIMER 0 DATA REGISTER
2127   05CB~            	OUT0	(Z180_TMDR0H),H
2128   05CB~            	DEC	HL			; RELOAD OCCURS *AFTER* ZERO
2129   05CB~            	OUT0	(Z180_RLDR0L),L		; INITIALIZE TIMER 0 RELOAD REGISTER
2130   05CB~            	OUT0	(Z180_RLDR0H),H
2131   05CB~            	LD	A,%00010001		; ENABLE TIMER0 INT AND DOWN COUNTING
2132   05CB~            	OUT0	(Z180_TCR),A
2133   05CB~            ;
2134   05CB~                #ENDIF
2135   05CB~            ;
2136   05CB~              #ENDIF
2137   05CB~            ;
2138   05CB             #ENDIF
2139   05CB             ;
2140   05CB~            #IF (CPUFAM == CPU_Z280)
2141   05CB~            ;
2142   05CB~              #IF (MEMMGR == MM_Z280)
2143   05CB~            ;
2144   05CB~                #IF (Z280_TIMER)
2145   05CB~            ;
2146   05CB~            Z280_TC	.EQU	CPUOSC / 4 / 50 / 2	; TIME CONSTANT
2147   05CB~            ;
2148   05CB~            	LD	HL,Z280_TIMINT
2149   05CB~            	LD	(Z280_IVT+$16),HL	; Z280 T/C VECTOR
2150   05CB~            ;
2151   05CB~            	; SELECT I/O PAGE $FE
2152   05CB~            	LD	C,Z280_IOPR		; I/O PAGE REGISTER
2153   05CB~            	LDCTL	HL,(C)			; GET CURRENT I/O PAGE
2154   05CB~            	PUSH	HL			; SAVE IT
2155   05CB~            	LD	L,$FE			; I/O PAGE $FE
2156   05CB~            	LDCTL	(C),HL
2157   05CB~            ;
2158   05CB~            	LD	A,%10100000		; CONFIG: C, RE, IE
2159   05CB~            	OUT	(Z280_CT0_CFG),A	; SET C/T 0
2160   05CB~            	LD	HL,CPUOSC / 50 / 16	; TIME CONSTANT & COUNTER
2161   05CB~            	LD	C,Z280_CT0_TC		; SET C/T 0
2162   05CB~            	OUTW	(C),HL
2163   05CB~            	LD	C,Z280_CT0_CT		; SET C/T 0
2164   05CB~            	OUTW	(C),HL
2165   05CB~            	LD	A,%11100000		; CMD: EN, GT
2166   05CB~            	OUT	(Z280_CT0_CMDST),A	; SET C/T 0
2167   05CB~            ;
2168   05CB~            	; RESTORE I/O PAGE
2169   05CB~            	LD	C,Z280_IOPR		; I/O PAGE REGISTER
2170   05CB~            	POP	HL			; RESTORE I/O PAGE
2171   05CB~            	LDCTL	(C),HL
2172   05CB~            ;
2173   05CB~                #ENDIF
2174   05CB~            ;
2175   05CB~              #ENDIF
2176   05CB~            ;
2177   05CB             #ENDIF
2178   05CB             ;
2179   05CB             ; INITIALIZE HEAP STORAGE
2180   05CB             ;
2181   05CB             	; INITIALIZE POINTERS
2182   05CB 21 5B 2C    	LD	HL,HB_END		; HEAP FOLLOWS HBIOS CODE
2183   05CE 22 20 01    	LD	(CB_HEAP),HL		; INIT HEAP BASE ADDRESS
2184   05D1 22 22 01    	LD	(CB_HEAPTOP),HL		; INIT HEAP TOP ADDRESS
2185   05D4             	; CLEAR HEAP
2186   05D4 01 A5 53    	LD	BC,BNKTOP - HB_END	; MAX SIZE OF HEAP
2187   05D7 3E FF       	LD	A,$FF			; FILL WITH $FF
2188   05D9 CD 81 1B    	CALL	FILL			; DO IT
2189   05DC             ;
2190   05DC             	DIAG(DIAG_06)
2190   05DC             
2191   05DC             ;
2192   05DC~            #IF FALSE
2193   05DC~            ;
2194   05DC~            ; TEST DEBUG ***************************************************************************************
2195   05DC~            ;
2196   05DC~            	CALL	NEWLINE
2197   05DC~            	CALL	REGDMP
2198   05DC~            ;
2199   05DC~            ; TEST DEBUG ***************************************************************************************
2200   05DC~            ;
2201   05DC             #ENDIF
2202   05DC             ;
2203   05DC             ; PRE-CONSOLE INITIALIZATION
2204   05DC             ;
2205   05DC 11 6A 07    	LD	DE,HB_PCINITTBL		; POINT TO PRECONSOLE INIT TABLE
2206   05DF 06 02       	LD	B,HB_PCINITTBLLEN	; NUMBER OF ENTRIES
2207   05E1             ;
2208   05E1~            #IF (BT_REC_TYPE != BT_REC_NONE)
2209   05E1~            	LD	A,(HB_BOOT_REC)		; IF WE ARE IN RECOVERY MODE
2210   05E1~            	OR	A			; POINT TO THE RECOVER MODE
2211   05E1~            	JR	Z,NOT_REC_M0		; INITIALIZATION TABLE
2212   05E1~            	LD	B,HB_PCINITRLEN
2213   05E1~            	LD	DE,HB_PCINIT_REC
2214   05E1~            NOT_REC_M0:
2215   05E1~            ;
2216   05E1             #ENDIF
2217   05E1 CD 5A 07    	CALL	CALLLIST							; PROCESS THE PRE-INIT CALL TABLE
2218   05E4             ;
2219   05E4~            #IF (DSKYENABLE)
2220   05E4~            	LD	HL,MSG_HBVER +  5
2221   05E4~            	LD	A,(DSKY_HEXMAP + RMJ)
2222   05E4~            	OR	$80
2223   05E4~            	LD	(HL),A
2224   05E4~            	INC	HL
2225   05E4~            	LD	A,(DSKY_HEXMAP + RMN)
2226   05E4~            	OR	$80
2227   05E4~            	LD	(HL),A
2228   05E4~            	INC	HL
2229   05E4~            	LD	A,(DSKY_HEXMAP + RUP)
2230   05E4~            	LD	(HL),A
2231   05E4~            	LD	HL,MSG_HBVER
2232   05E4~            	CALL	DSKY_SHOW
2233   05E4             #ENDIF
2234   05E4             ;
2235   05E4~            #IF FALSE
2236   05E4~            ;
2237   05E4~            ; TEST DEBUG ***************************************************************************************
2238   05E4~            ;
2239   05E4~            	CALL	NEWLINE
2240   05E4~            	CALL	REGDMP
2241   05E4~            ;
2242   05E4~            ; TEST DEBUG ***************************************************************************************
2243   05E4~            ;
2244   05E4             #ENDIF
2245   05E4             ;
2246   05E4             	DIAG(DIAG_07)
2246   05E4             
2247   05E4             	LED(%00000111)
2247   05E4             
2248   05E4             ;
2249   05E4             ;
2250   05E4             ;
2251   05E4             ;
2252   05E4~            #IF (BOOT_DELAY > 100)
2253   05E4~            	.ECHO	"*** ERROR: INVALID BOOT_DELAY (BOOT_DELAY > 100)!!!\n"
2254   05E4~            	!!!	; FORCE AN ASSEMBLY ERROR
2255   05E4             #ENDIF
2256   05E4             ;
2257   05E4~            #IF (BOOT_DELAY > 0)
2258   05E4~            	LD	B,BOOT_DELAY * 2	; SCALE TO 1/2 SEC
2259   05E4~            HB_BOOTDLY:
2260   05E4~            	CALL	LDELAY			; 1/2 SECOND DELAY
2261   05E4~            	DJNZ	HB_BOOTDLY		; LOOP TILL DONE
2262   05E4             #ENDIF
2263   05E4             ;
2264   05E4             ; PRIOR TO THIS POINT, CONSOLE I/O WAS NOT AVAILABLE UNLESS DIRECTED TO DEBUG OUTPUT I.E. XIO
2265   05E4             ; NOW THAT HBIOS IS READY, SET THE CONSOLE UNIT TO ACTIVATE CONSOLE I/O
2266   05E4             ; VIA HBIOS.
2267   05E4             ;
2268   05E4 AF          	XOR	A			; FAILSAFE VALUE FOR BOOT CONSOLE DEVICE
2269   05E5 32 12 01    	LD	(CB_CONDEV),A		; SAVE IT
2270   05E8             ;
2271   05E8 3A CD 07    	LD	A,(CIO_CNT)		; GET COUNT OF CHAR DEVICES
2272   05EB FE 01       	CP	BOOTCON	+ 1		; COUNT - (DEVICE + 1)
2273   05ED 38 05       	JR	C,HB_CONRDY		; IF TOO HIGH, JUST USE FAILSAFE
2274   05EF 3E 00       	LD	A,BOOTCON		; GET REQUESTED CONSOLE DEV
2275   05F1 32 12 01    	LD	(CB_CONDEV),A		; SAVE IT
2276   05F4             HB_CONRDY:
2277   05F4             ;
2278   05F4             ; MOST SERIAL PORTS ARE CONFIGURED WITH HARDWARE FLOW CONTROL ENABLED.
2279   05F4             ; IF THERE IS A PROBLEM WITH THE RTS SIGNAL, THEN OUTPUT TO THE CONSOLE
2280   05F4             ; WILL BE STALLED WHICH CAN LEAD A USER TO THINK THE SYSTEM IS TOTALLY
2281   05F4             ; DEAD WHEN, IN FACT, IT IS JUST WAITING FOR RTS TO BE ASSERTED.  ALSO,
2282   05F4             ; IF THE USER IS BOOTING TO A CRT DEVICE AND DISCONNECTS THE CONSOLE
2283   05F4             ; SERIAL PORT, THE SYSTEM WILL WAIT FOR RTS AND NEVER BOOT.  SO, HERE
2284   05F4             ; WE SAVE THE ACTIVE CONSOLE CONFIGURATION, THEN TURN OFF HARDWARE
2285   05F4             ; FLOW CONTROL.  THE ORIGINAL CONFIGURATION WILL BE RESTORED BELOW
2286   05F4             ; PRIOR TO LAUNCING THE ROM LOADER.
2287   05F4             ;
2288   05F4             	; RETRIEVE THE CONFIG FROM THE CONSOLE PORT
2289   05F4 06 05       	LD	B,BF_CIOQUERY		; HBIOS QUERY CIO CONFIG
2290   05F6 3A 12 01    	LD	A,(CB_CONDEV)		; GET CONSOLE DEVICE
2291   05F9 32 58 2A    	LD	(HB_BOOTCONSAV),A	; SAVE IT FOR LATER
2292   05FC 4F          	LD	C,A			; BOOT CONSOLE TO C
2293   05FD CD 83 07    	CALL	HB_DISPATCH		; INTERNAL HBIOS CALL
2294   0600 ED 53 59 2A 	LD	(HB_CONCFGSAV),DE	; SAVE CONFIG
2295   0604 CB AA       	RES	5,D			; CLEAR RTS BIT
2296   0606 06 04       	LD	B,BF_CIOINIT		; HBIOS CIO INIT
2297   0608 3A 12 01    	LD	A,(CB_CONDEV)		; GET CONSOLE DEVICE
2298   060B 4F          	LD	C,A			; BOOT CONSOLE TO C
2299   060C CD 83 07    	CALL	HB_DISPATCH		; INTERNAL HBIOS CALL
2300   060F             
2301   060F~            #IF (WBWDEBUG == USEMIO)		; OUTPUT ANY CACHED DEBUG TEXT
2302   060F~            	LD	HL,MIOOUTPTR
2303   060F~            	LD	E,(HL)
2304   060F~            	INC	HL
2305   060F~            	LD	D,(HL)
2306   060F~            	INC	HL
2307   060F~            NXTMIO:	LD	A,(HL)
2308   060F~            	CALL	COUT
2309   060F~            	INC	HL
2310   060F~            	LD	A,L
2311   060F~            	CP	E
2312   060F~            	JR	NZ,NXTMIO
2313   060F~            	LD	A,H
2314   060F~            	CP	D
2315   060F~            	JR	NZ,NXTMIO
2316   060F~            ;	CALL	WRITESTR		; WRITESTR WILL WORK WILL ONLY PRINT UP TO FIRST $
2317   060F             #ENDIF
2318   060F             ;
2319   060F~            #IF FALSE
2320   060F~            ;
2321   060F~            ; TEST DEBUG ***************************************************************************************
2322   060F~            ;
2323   060F~            	CALL	NEWLINE2
2324   060F~            	PRTS("DEBUG+IVT$")
2324   060F~            	PRTS("DEBUG+IVT$")
2325   060F~            	LD	DE,HB_IVT
2326   060F~            	CALL	DUMP_BUFFER
2327   060F~            ;
2328   060F~            ; TEST DEBUG ***************************************************************************************
2329   060F~            ;
2330   060F             #ENDIF
2331   060F             ;
2332   060F             ; ANNOUNCE HBIOS
2333   060F             ;
2334   060F CD 1D 19    	CALL	NEWLINE2
2335   0612 CD 43 19    	PRTX(STR_BANNER)
2335   0615 6B 29       
2336   0617             ;
2337   0617             ; DISPLAY HBIOS MUTEX ENABLED MESSAGE
2338   0617             ;
2339   0617~            #IF (HBIOS_MUTEX == TRUE)
2340   0617~            	CALL	NEWLINE
2341   0617~            	CALL	PRTSTRD
2342   0617~            	.TEXT	"HBIOS MUTEX ENABLED$"
2343   0617             #ENDIF
2344   0617             ;
2345   0617             ; DISPLAY RECOVERY MODE MESSAGE
2346   0617             ;
2347   0617~            #IF (BT_REC_TYPE != BT_REC_NONE)
2348   0617~            	LD	A,(HB_BOOT_REC)		; IF WE ARE IN RECOVERY MODE
2349   0617~            	OR	A			; DISPLAY RECOVERY MODE MESSAGE
2350   0617~            	JR	Z,NOT_REC_M2
2351   0617~            	CALL	NEWLINE
2352   0617~            	CALL	PRTSTRD
2353   0617~            	.TEXT	"RECOVERY MODE$"
2354   0617             #ENDIF
2355   0617             NOT_REC_M2:
2356   0617             ;
2357   0617             	DIAG(DIAG_08)
2357   0617             
2358   0617             ;
2359   0617             ; IO PORT SCAN
2360   0617             ;
2361   0617~            #IF FALSE
2362   0617~            PSCN:
2363   0617~            	LD	C,0			; IO PORT NUMBER
2364   0617~            	LD	B,0			; LOOP COUNTER
2365   0617~            	CALL	NEWLINE
2366   0617~            PSCN1:
2367   0617~            	CALL	NEWLINE
2368   0617~            	LD	A,C
2369   0617~            	CALL	PRTHEXBYTE
2370   0617~            	CALL	PC_COLON
2371   0617~            	CALL	PC_SPACE
2372   0617~            	CALL	DELAY
2373   0617~            	LD	A,C
2374   0617~            	LD	(PSCNX),A
2375   0617~            PSCNX	.EQU	$ + 1
2376   0617~            	IN	A,(0)
2377   0617~            	CALL	PRTHEXBYTE
2378   0617~            	CALL	PC_COMMA
2379   0617~            	PUSH	BC
2380   0617~            	LD	B,0
2381   0617~            	IN	A,(C)
2382   0617~            	POP	BC
2383   0617~            	CALL	PRTHEXBYTE
2384   0617~            	INC	C
2385   0617~            	DJNZ	PSCN1
2386   0617             #ENDIF
2387   0617             ;
2388   0617~            #IF FALSE
2389   0617~            HB_SPDTST:
2390   0617~            	CALL	HB_CPUSPD		; CPU SPEED DETECTION
2391   0617~            	CALL	NEWLINE
2392   0617~            	LD	HL,(CB_CPUKHZ)
2393   0617~            	CALL	PRTD3M			; PRINT AS DECIMAL WITH 3 DIGIT MANTISSA
2394   0617~            	JR	HB_SPDTST
2395   0617             #ENDIF
2396   0617             ;
2397   0617 FB          	HB_EI				; INTERRUPTS SHOULD BE OK NOW
2398   0618             ;
2399   0618             ; DISPLAY PLATFORM INFORMATION
2400   0618             ;
2401   0618 CD 1D 19    	CALL	NEWLINE2
2402   061B CD 43 19    	PRTX(STR_PLATFORM)
2402   061E 8B 29       
2403   0620             ;
2404   0620 3A 66 29    	LD	A,(HB_CPUTYPE)		; GET CPU TYPE
2405   0623 11 E1 26    	LD	DE,HB_CPU_STR		; DISPLAY IT
2406   0626 CD FE 19    	CALL	PRTIDXDEA
2407   0629             ;
2408   0629 CD 3B 19    	PRTS(" @ $")
2408   062C 20 40 20 24 
2409   0630 2A 09 01    	LD	HL,(CB_CPUKHZ)
2410   0633 CD B7 23    	CALL	PRTD3M			; PRINT AS DECIMAL WITH 3 DIGIT MANTISSA
2411   0636 CD 3B 19    	PRTS("MHz$")
2411   0639 4D 48 7A 24 
2412   063D             ;
2413   063D~            #IF (CPUFAM == CPU_Z180)
2414   063D~            	PRTS(" IO=0x$")
2414   063D~            	PRTS(" IO=0x$")
2415   063D~            	LD	A,Z180_BASE
2416   063D~            	CALL	PRTHEXBYTE
2417   063D             #ENDIF
2418   063D             ;
2419   063D~            #IF (CPUFAM == CPU_Z280)
2420   063D~            	CALL	PRTSTRD
2421   063D~            	.TEXT	", BUS @ $"
2422   063D~            	LD	C,Z280_BTIR		; BUS TIMING AND CTL REG
2423   063D~            	LDCTL	HL,(C)
2424   063D~            	LD	A,L			; MOVE TO A
2425   063D~            	AND	%00000011		; ISOLATE CS FIELD
2426   063D~            	LD	HL,(CB_CPUKHZ)		; GET CPU SPEED
2427   063D~            	CP	%00000001		; BUS @ 1/1
2428   063D~            	JR	Z,HB_Z280BUS		; GOT IT, SHOW IT
2429   063D~            	SRL	H			; DIVIDE
2430   063D~            	RR	L			; ... BY 2
2431   063D~            	CP	%00000000		; BUS @ 1/2
2432   063D~            	JR	Z,HB_Z280BUS		; GOT IT, SHOW IT
2433   063D~            	SRL	H                       ; DIVIDE
2434   063D~            	RR	L                       ; ... BY 2
2435   063D~            	CP	%00000010		; BUS @ 1/4
2436   063D~            	JR	Z,HB_Z280BUS		; GOT IT, SHOW IT
2437   063D~            	PRTS("???$")			; INVALID VALUE
2437   063D~            	PRTS("???$")			; INVALID VALUE
2438   063D~            	JR	HB_Z280BUS1		; CONTINUE
2439   063D~            HB_Z280BUS:
2440   063D~            	CALL	PRTD3M			; PRINT AS DECIMAL WITH 3 DIGIT MANTISSA
2441   063D~            HB_Z280BUS1:
2442   063D~            	PRTS("MHz$")			; SUFFIX
2442   063D~            	PRTS("MHz$")			; SUFFIX
2443   063D             #ENDIF
2444   063D             ;
2445   063D             ; DISPLAY CPU CONFIG
2446   063D             ;
2447   063D CD 20 19    	CALL	NEWLINE
2448   0640             
2449   0640~            #IF (CPUFAM == CPU_Z280)
2450   0640~            	LD	A,Z280_MEMLOWAIT
2451   0640~            	CALL	PRTDECB
2452   0640~            	LD	A,'/'
2453   0640~            	CALL	COUT
2454   0640~            	LD	A,Z280_MEMHIWAIT
2455   0640~            	CALL	PRTDECB
2456   0640~            	CALL	PRTSTRD
2457   0640~            	.TEXT	" MEM W/S, $"
2458   0640             #ELSE
2459   0640 AF          	XOR	A
2460   0641~              #IF (CPUFAM == CPU_Z180)
2461   0641~            	LD	A,Z180_MEMWAIT
2462   0641               #ENDIF
2463   0641 CD B2 1B    	CALL	PRTDECB
2464   0644 CD 3B 19    	CALL	PRTSTRD
2465   0647 20 4D 45 4D 	.TEXT	" MEM W/S, $"
2465   064B 20 57 2F 53 
2465   064F 2C 20 24 
2466   0652             #ENDIF
2467   0652 3E 01       	LD	A,1
2468   0654~            #IF (CPUFAM == CPU_Z180)
2469   0654~            	LD	A,Z180_IOWAIT + 1
2470   0654             #ENDIF
2471   0654~            #IF (CPUFAM == CPU_Z280)
2472   0654~            	LD	A,Z280_IOWAIT + 1
2473   0654             #ENDIF
2474   0654 CD B2 1B    	CALL	PRTDECB
2475   0657 CD 3B 19    	CALL	PRTSTRD
2476   065A 20 49 2F 4F 	.TEXT	" I/O W/S$"
2476   065E 20 57 2F 53 
2476   0662 24 
2477   0663~            #IF (CPUFAM == CPU_Z280)
2478   0663~            	CALL	PRTSTRD
2479   0663~            	.TEXT	", $"
2480   0663~            	LD	A,Z280_INTWAIT
2481   0663~            	CALL	PRTDECB
2482   0663~            	CALL	PRTSTRD
2483   0663~            	.TEXT	" INT W/S$"
2484   0663             #ENDIF
2485   0663             #IF (INTMODE > 0)
2486   0663 CD 3B 19    	CALL	PRTSTRD
2487   0666 2C 20 49 4E 	.TEXT	", INT MODE $"
2487   066A 54 20 4D 4F 
2487   066E 44 45 20 24 
2488   0672 3E 01       	LD	A,INTMODE
2489   0674 CD B2 1B    	CALL	PRTDECB
2490   0677             #ENDIF
2491   0677             ;
2492   0677 CD 3B 19    	CALL	PRTSTRD
2493   067A 2C 20 24    	.TEXT	", $"
2494   067D CD 3B 19    	CALL	PRTSTRD
2495   0680~            #IF (MEMMGR == MM_NONE)
2496   0680~            	.TEXT	"NONE$"
2497   0680             #ENDIF
2498   0680~            #IF (MEMMGR == MM_SBC)
2499   0680~            	.TEXT	"SBC$"
2500   0680             #ENDIF
2501   0680             #IF (MEMMGR == MM_Z2)
2502   0680 5A 32 24    	.TEXT	"Z2$"
2503   0683             #ENDIF
2504   0683~            #IF (MEMMGR == MM_N8)
2505   0683~            	.TEXT	"N8$"
2506   0683             #ENDIF
2507   0683~            #IF (MEMMGR == MM_Z180)
2508   0683~            	.TEXT	"Z180$"
2509   0683             #ENDIF
2510   0683~            #IF (MEMMGR == MM_Z280)
2511   0683~            	.TEXT	"Z280$"
2512   0683             #ENDIF
2513   0683~            #IF (MEMMGR == MM_ZRC)
2514   0683~            	.TEXT	"ZRC$"
2515   0683             #ENDIF
2516   0683~            #IF (MEMMGR == MM_MBC)
2517   0683~            	.TEXT	"MBC$"
2518   0683             #ENDIF
2519   0683~            #IF (MEMMGR == MM_RPH)
2520   0683~            	.TEXT	"RPH$"
2521   0683             #ENDIF
2522   0683 CD 3B 19    	CALL	PRTSTRD
2523   0686 20 4D 4D 55 	.TEXT	" MMU$"
2523   068A 24 
2524   068B             ;
2525   068B             ; DISPLAY MEMORY CONFIG
2526   068B             ;
2527   068B CD 20 19    	CALL	NEWLINE
2528   068E 21 00 02    	LD	HL,ROMSIZE
2529   0691 CD BE 1B    	CALL	PRTDEC
2530   0694 CD 3B 19    	CALL	PRTSTRD
2531   0697 4B 42 20 52 	.TEXT	"KB ROM, $"
2531   069B 4F 4D 2C 20 
2531   069F 24 
2532   06A0             ;
2533   06A0 2A 0B 01    	LD	HL,(CB_RAMBANKS)	; GET NUMBER OF BANKS IN L
2534   06A3 26 00       	LD	H,0			; CALCULATE RAM SIZE
2535   06A5 29          	ADD	HL,HL
2536   06A6 29          	ADD	HL,HL			; X4
2537   06A7 29          	ADD	HL,HL			; X8
2538   06A8 29          	ADD	HL,HL			; X16
2539   06A9 29          	ADD	HL,HL			; X32
2540   06AA             ;
2541   06AA CD BE 1B    	CALL	PRTDEC
2542   06AD CD 3B 19    	CALL	PRTSTRD
2543   06B0 4B 42 20 52 	.TEXT	"KB RAM$"
2543   06B4 41 4D 24 
2544   06B7             ;
2545   06B7~            #IFDEF TESTING
2546   06B7~            ;
2547   06B7~            	CALL	PRTSTRD
2548   06B7~            	.TEXT	", RAMBANKS=0x$"
2549   06B7~            	LD	A,($FFEA)
2550   06B7~            	CALL	PRTHEXBYTE
2551   06B7~            ;
2552   06B7~            	CALL	PRTSTRD
2553   06B7~            	.TEXT	", RTCDEF=0x$"
2554   06B7~            	LD	A,(RTCDEFVAL)
2555   06B7~            	CALL	PRTHEXBYTE
2556   06B7~            ;
2557   06B7             #ENDIF
2558   06B7             ;
2559   06B7~            #IF 0
2560   06B7~            ;
2561   06B7~            ; DIAGNOSTIC DISPLAY OF BANK IDS IN HCB
2562   06B7~            ;
2563   06B7~            	CALL	PRTSTRD
2564   06B7~            	.TEXT	", BANK IDS:$"
2565   06B7~            	LD	DE,CB_BIDCOM
2566   06B7~            	LD	A,8
2567   06B7~            	CALL	PRTHEXBUF
2568   06B7~            ;
2569   06B7             #ENDIF
2570   06B7             ;
2571   06B7~            #IF (CPUFAM == CPU_Z280)
2572   06B7~            	CALL	NEWLINE
2573   06B7~            	PRTS("Z280: $")
2573   06B7~            	PRTS("Z280: $")
2574   06B7~            	PRTS("MSR=$")
2574   06B7~            	PRTS("MSR=$")
2575   06B7~            	LD	C,Z280_MSR		; MASTER STATUS REGISTER
2576   06B7~            	LDCTL	HL,(C)
2577   06B7~            	CALL	PRTHEXWORDHL
2578   06B7~            	CALL	PC_SPACE
2579   06B7~            	PRTS("BTCR=$")
2579   06B7~            	PRTS("BTCR=$")
2580   06B7~            	LD	C,Z280_BTCR		; BUS TIMING AND CONTROL REGISTER
2581   06B7~            	LDCTL	HL,(C)
2582   06B7~            	CALL	PRTHEXWORDHL
2583   06B7~            	CALL	PC_SPACE
2584   06B7~            	PRTS("BTIR=$")
2584   06B7~            	PRTS("BTIR=$")
2585   06B7~            	LD	C,Z280_BTIR		; BUS TIMING AND CONTROL REGISTER
2586   06B7~            	LDCTL	HL,(C)
2587   06B7~            	CALL	PRTHEXWORDHL
2588   06B7~            	CALL	PC_SPACE
2589   06B7~            	PRTS("CCR=$")
2589   06B7~            	PRTS("CCR=$")
2590   06B7~            	LD	C,Z280_CCR		; CACHE CONTROL REGISTER
2591   06B7~            	LDCTL	HL,(C)
2592   06B7~            	CALL	PRTHEXWORDHL
2593   06B7             #ENDIF
2594   06B7             ;
2595   06B7             #IFDEF ROMBOOT
2596   06B7               #IF (ROMSIZE > 0)
2597   06B7             ;
2598   06B7             ; ROM CHECKSUM VERIFICATION
2599   06B7             ; EACH OF THE FIRST 4 ROM BANKS HAS A CHECKSUM INJECTED SUCH THAT
2600   06B7             ; A COMPUTED CHECKSUM ACROSS THE ENTIRE BANK SHOULD ALWAYS BE ZERO
2601   06B7             ;
2602   06B7             HB_ROMCK:
2603   06B7 CD 20 19    	CALL	NEWLINE
2604   06BA CD 3B 19    	PRTS("ROM VERIFY:$")
2604   06BD 52 4F 4D 20 
2604   06C1 56 45 52 49 
2604   06C5 46 59 3A 24 
2605   06C9             ;
2606   06C9             	; COPY CHECKSUM ROUTINE TO UPPER RAM
2607   06C9 21 FF 06    	LD	HL,HB_CKBNK
2608   06CC 11 00 F0    	LD	DE,$F000
2609   06CF 01 1E 00    	LD	BC,HB_CKBNKSIZ
2610   06D2 ED B0       	LDIR
2611   06D4             ;
2612   06D4             	; TEST FIRST 4 BANKS OF ROM
2613   06D4 06 04       	LD	B,4			; 4 BANKS
2614   06D6 0E 00       	LD	C,0			; STARTING AT BANK 0
2615   06D8             HB_ROMCK1:
2616   06D8 C5          	PUSH	BC			; SAVE LOOP CONTROL
2617   06D9 CD 00 F0    	CALL	$F000			; TEST THE BANK
2618   06DC CD D7 18    	CALL	PC_SPACE		; FORMATTING
2619   06DF CD 52 19    	CALL	PRTHEXBYTE		; PRINT RESULT
2620   06E2 C1          	POP	BC			; RESTORE LOOP CONTROL
2621   06E3 B7          	OR	A			; SET FLAGS
2622   06E4 20 0E       	JR	NZ,HB_ROMCK2		; HANDLE FAILURE
2623   06E6 0C          	INC	C			; NEXT BANK
2624   06E7 10 EF       	DJNZ	HB_ROMCK1		; LOOP FOR BANKS
2625   06E9 CD 3B 19    	PRTS(" PASS$")			; DISPLAY SUCCESS
2625   06EC 20 50 41 53 
2625   06F0 53 24 
2626   06F2 18 29       	JR	HB_ROMCKZ		; CONTINUE BOOT
2627   06F4             HB_ROMCK2:
2628   06F4 CD 3B 19    	PRTS(" FAIL$")			; DISPLAY ERROR
2628   06F7 20 46 41 49 
2628   06FB 4C 24 
2629   06FD 18 1E       	JR	HB_ROMCKZ		; CONTINUE BOOT
2630   06FF             ;
2631   06FF             ; VERIFY ROM CHECKSUM BANK SPECIFIED IN REG C
2632   06FF             ; THIS MUST BE COPIED TO UPPER RAM TO RUN
2633   06FF             ; INTERRUPTS ARE DISABLED SINCE PAGE ZERO VECTOR WILL BE
2634   06FF             ; SWAPPED OUT.  ASSUMES THAT INTERRUPTS ARE ENABLED AT ENTRY.
2635   06FF             ;
2636   06FF             HB_CKBNK:
2637   06FF F3          	HB_DI				; SUPPRESS INTERRUPTS
2638   0700 3A E0 FF    	LD	A,(HB_CURBNK)		; GET CURRENT BANK
2639   0703 5F          	LD	E,A			; SAVE IN E
2640   0704 79          	LD	A,C			; BANK TO TEST
2641   0705 CD 2B FE    	CALL	HBX_BNKSEL		; SELECT BANK IT
2642   0708 21 FF 7F    	LD	HL,$7FFF		; START AT BANK END
2643   070B 01 01 00    	LD	BC,1			; DECREMENT VALUE
2644   070E AF          	XOR	A			; ZERO ACCUM
2645   070F             HB_CKBNK1:
2646   070F~            #IF (MEMMGR == MM_Z280)
2647   070F~            	LD	D,A			; WORKING VALUE TO D
2648   070F~            	LDUD	A,(HL)			; GRAB NEXT BYTE FROM USER SPACE
2649   070F~            	ADD	A,D			; ADD NEXT BYTE
2650   070F             #ELSE
2651   070F 86          	ADD	A,(HL)			; ADD NEXT BYTE
2652   0710             #ENDIF
2653   0710 B7          	OR	A			; CLEAR CARRY
2654   0711 ED 42       	SBC	HL,BC			; DECREMENT
2655   0713 30 FA       	JR	NC,HB_CKBNK1		; LOOP TILL DONE
2656   0715 F5          	PUSH	AF			; SAVE RESULT
2657   0716 7B          	LD	A,E			; BANK TO RESTORE
2658   0717 CD 2B FE    	CALL	HBX_BNKSEL		; RESTORE ORIG BANK
2659   071A F1          	POP	AF			; RECOVER RESULT
2660   071B FB          	HB_EI				; ALLOW INTERRUPTS AGAIN
2661   071C C9          	RET				; AND DONE
2662   071D             ;
2663   071D             HB_CKBNKSIZ	.EQU	$-HB_CKBNK	; SIZE OF ROUTINE
2664   071D             ;
2665   071D             HB_ROMCKZ:
2666   071D             ;
2667   071D               #ENDIF
2668   071D             #ENDIF
2669   071D             ;
2670   071D             ; LOW BATTERY DIAGNOSTIC MESSAGE
2671   071D             ;
2672   071D~            #IF (BATCOND)
2673   071D~            	LD	A,(HB_BATCOND)
2674   071D~            	OR	A
2675   071D~            	LD	DE,STR_LOWBAT
2676   071D~            	CALL	Z,WRITESTR
2677   071D             #ENDIF
2678   071D             ;
2679   071D             ; PERFORM DEVICE INITIALIZATION
2680   071D             ;
2681   071D CD 20 19    	CALL	NEWLINE
2682   0720             
2683   0720~            #IF (BT_REC_TYPE != BT_REC_NONE)
2684   0720~            	LD	A,(HB_BOOT_REC)		; IF WE ARE IN RECOVERY MODE
2685   0720~            	OR	A			; POINT TO THE RECOVER MODE
2686   0720~            	JR	Z,NOT_REC_M1		; INITIALIZATION TABLE
2687   0720~            	LD	B,HB_INITRLEN
2688   0720~            	LD	DE,HB_INIT_REC
2689   0720~            	JR	IS_REC_M1
2690   0720             #ENDIF
2691   0720             
2692   0720             NOT_REC_M1:
2693   0720 06 04       	LD	B,HB_INITTBLLEN
2694   0722 11 6E 07    	LD	DE,HB_INITTBL
2695   0725             IS_REC_M1:
2696   0725 CD 5A 07    	CALL	CALLLIST
2697   0728             ;
2698   0728             ; IF WATCHDOG FUNCTIONALITY IS REQUESTED, CHECK TO MAKE SURE
2699   0728             ; WE ARE GETTING INTERRUPTS.  IF SO, ENABLE THE WATCHDOG.
2700   0728             ;
2701   0728~            #IF (WDOGMODE != WDOG_NONE)
2702   0728~            	CALL	NEWLINE
2703   0728~            	PRTS("WDOG: $")
2703   0728~            	PRTS("WDOG: $")
2704   0728~            	PRTS("MODE=$")
2704   0728~            	PRTS("MODE=$")
2705   0728~            
2706   0728~              #IF (WDOGMODE == WDOG_EZZ80)
2707   0728~            	PRTS("EZZ80$")
2707   0728~            	PRTS("EZZ80$")
2708   0728~              #ENDIF
2709   0728~              #IF (WDOGMODE == WDOG_SKZ)
2710   0728~            	PRTS("SKZ$")
2710   0728~            	PRTS("SKZ$")
2711   0728~              #ENDIF
2712   0728~            ;
2713   0728~            	PRTS(" IO=0x$")
2713   0728~            	PRTS(" IO=0x$")
2714   0728~            	LD	A,WDOGIO
2715   0728~            	CALL	PRTHEXBYTE
2716   0728~            ;
2717   0728~              #IF (WDOGMODE == WDOG_SKZ)
2718   0728~            	; SKZ WATCHDOG IS DISABLED EARLY IN BOOT PROCESS
2719   0728~            	; HERE, WE ONLY NEED TO ENABLE IT, IF APPROPRIATE
2720   0728~            	LD	HL,(HB_TICKS)		; GET LOW WORD
2721   0728~            	LD	A,H			; CHECK FOR
2722   0728~            	OR	L			; ... ZERO
2723   0728~            	JR	Z,HB_WDOFF		; SKIP IF NOT TICKING
2724   0728~            	IN	A,($6D)			; GET PORT VALUE
2725   0728~            	SET	5,A			; SET THE WATCHDOG ENABLE BIT
2726   0728~            	OUT	($6D),A			; ACTIVATE WATCHDOG
2727   0728~              #ENDIF
2728   0728~            ;
2729   0728~            	PRTS(" ENABLED$")
2729   0728~            	PRTS(" ENABLED$")
2730   0728~            	JR	HB_WDZ
2731   0728~            ;
2732   0728~            HB_WDOFF:
2733   0728~            	PRTS(" DISABLED$")
2733   0728~            	PRTS(" DISABLED$")
2734   0728~            ;
2735   0728~            HB_WDZ:
2736   0728~            ;
2737   0728             #ENDIF
2738   0728             ;
2739   0728             ; RECORD HEAP CURB AT THE CURRENT VALUE OF HEAP TOP.  HEAP CURB
2740   0728             ; MARKS THE POINT IN THE HEAP AFTER WHICH MEMORY IS RELEASED
2741   0728             ; WHEN AN HBIOS RESET IS PEFORMED.
2742   0728             ;
2743   0728 2A 22 01    	LD	HL,(CB_HEAPTOP)
2744   072B 22 5B 29    	LD	(HEAPCURB),HL
2745   072E             ;
2746   072E             ; NOW SWITCH TO CRT CONSOLE IF CONFIGURED
2747   072E             ;
2748   072E~            #IF CRTACT
2749   072E~            ;
2750   072E~            ; BIOS IS CONFIGURED TO AUTO ACTIVATE CRT DEVICE.  FIRST,
2751   072E~            ; CHECK TO SEE IF WE HAVE A VALID CRT DEVICE TO USE.
2752   072E~            ;
2753   072E~            	LD	A,(CB_CRTDEV)		; GET THE CRT DEVICE
2754   072E~            	INC	A			; INCREMENT TO TEST FOR $FF
2755   072E~            	JR	Z,INITSYS3		; IF NO CRT DEVICE, BYPASS CONSOLE SWITCH
2756   072E~            ;
2757   072E~            ; IF PLATFORM HAS A CONFIG JUMPER, CHECK TO SEE IF IT IS JUMPERED.
2758   072E~            ; IF SO, BYPASS SWITCH TO CRT CONSOLE (FAILSAFE MODE)
2759   072E~            ;
2760   072E~              #IF ((PLATFORM == PLT_SBC) | (PLATFORM == PLT_ZETA) | (PLATFORM == PLT_ZETA2) | (PLATFORM == PLT_MBC))
2761   072E~            	IN	A,(RTCIO)		; RTC PORT, BIT 6 HAS STATE OF CONFIG JUMPER
2762   072E~            	BIT	6,A			; BIT 6 HAS CONFIG JUMPER STATE
2763   072E~            	JR	Z,INITSYS3		; Z=SHORTED, BYPASS CONSOLE SWITCH
2764   072E~              #ENDIF
2765   072E~            ;
2766   072E~            	; NOTIFY USER OF CONSOLE SWITCH ON BOOT CONSOLE
2767   072E~            	CALL	NEWLINE2
2768   072E~            	PRTX(STR_SWITCH)
2768   072E~            	PRTX(STR_SWITCH)
2769   072E~            	CALL	NEWLINE
2770   072E~            ;
2771   072E~            	; SWITCH TO CRT CONSOLE
2772   072E~            	LD	A,(CB_CRTDEV)		; GET CRT DISPLAY DEVICE
2773   072E~            	LD	(CB_CONDEV),A		; SAVE IT AS ACTIVE CONSOLE DEVICE
2774   072E~            ;
2775   072E             #ENDIF
2776   072E             ;
2777   072E             INITSYS3:
2778   072E             ;
2779   072E             ; RESTORE BOOT CONSOLE CONFIGURATION
2780   072E             ;
2781   072E CD 11 1B    	CALL	LDELAY			; ALLOW SERIAL PORT TO FLUSH
2782   0731 06 04       	LD	B,BF_CIOINIT		; HBIOS CIO INIT
2783   0733 3A 58 2A    	LD	A,(HB_BOOTCONSAV)	; ORIGINAL BOOT CONSOLE DEVICE
2784   0736 4F          	LD	C,A			; BOOT CONSOLE TO C
2785   0737 ED 5B 59 2A 	LD	DE,(HB_CONCFGSAV)	; SAVED ORIGINAL CONSOLE CFG
2786   073B CD 83 07    	CALL	HB_DISPATCH		; INTERNAL HBIOS CALL
2787   073E             ;
2788   073E 3A 58 2A    	LD	A,(HB_BOOTCONSAV)	; GET ORIGINAL BOOT CONSOLE DEV
2789   0741 4F          	LD	C,A			; PUT IN C
2790   0742 3A 12 01    	LD	A,(CB_CONDEV)		; GET ACTIVE CONSOLE DEVICE
2791   0745 B9          	CP	C			; COMPARE
2792   0746 28 05       	JR	Z,INITSYS3A		; SKIP AHEAD IF NO CHANGE
2793   0748             ;
2794   0748             	; DISPLAY HBIOS BANNER ON NEW CONSOLE IF WE SWITCHED TO NEW
2795   0748             	; CONSOLE DEVICE
2796   0748 CD 43 19    	PRTX(STR_BANNER)		; DISPLAY HBIOS BANNER
2796   074B 6B 29       
2797   074D             ;
2798   074D             INITSYS3A:
2799   074D CD F2 23    	CALL	PRTSUM			; PRINT UNIT/DEVICE SUMMARY TABLE
2800   0750             ;
2801   0750~            #IF 0
2802   0750~            	CALL	NEWLINE
2803   0750~            	CALL	NEWLINE
2804   0750~            	CALL	NEWLINE
2805   0750~            
2806   0750~            	; SRC & DEST BELOW BND
2807   0750~            	CALL	NEWLINE
2808   0750~            	LD	HL,$4000
2809   0750~            	LD	DE,$5000
2810   0750~            	LD	BC,$3000
2811   0750~            	CALL	NEWLINE
2812   0750~            	CALL	REGDMP
2813   0750~            	CALL	Z280_BNKCPYX
2814   0750~            
2815   0750~            	; SRC & DEST ABOVE BND
2816   0750~            	CALL	NEWLINE
2817   0750~            	LD	HL,$8000
2818   0750~            	LD	DE,$9000
2819   0750~            	LD	BC,$1000
2820   0750~            	CALL	NEWLINE
2821   0750~            	CALL	REGDMP
2822   0750~            	CALL	Z280_BNKCPYX
2823   0750~            
2824   0750~            	; SRC CROSSOVER
2825   0750~            	CALL	NEWLINE
2826   0750~            	LD	HL,$7000
2827   0750~            	LD	DE,$9000
2828   0750~            	LD	BC,$2000
2829   0750~            	CALL	NEWLINE
2830   0750~            	CALL	REGDMP
2831   0750~            	CALL	Z280_BNKCPYX
2832   0750~            
2833   0750~            	; DEST CROSSOVER
2834   0750~            	CALL	NEWLINE
2835   0750~            	LD	HL,$9000
2836   0750~            	LD	DE,$7000
2837   0750~            	LD	BC,$2000
2838   0750~            	CALL	NEWLINE
2839   0750~            	CALL	REGDMP
2840   0750~            	CALL	Z280_BNKCPYX
2841   0750~            
2842   0750~            	; DOUBLE CROSSOVER
2843   0750~            	CALL	NEWLINE
2844   0750~            	LD	HL,$7800
2845   0750~            	LD	DE,$7000
2846   0750~            	LD	BC,$2000
2847   0750~            	CALL	NEWLINE
2848   0750~            	CALL	REGDMP
2849   0750~            	CALL	Z280_BNKCPYX
2850   0750~            
2851   0750~            	; DOUBLE CROSSOVER SINGLE BYTES
2852   0750~            	CALL	NEWLINE
2853   0750~            	LD	HL,$7FFE
2854   0750~            	LD	DE,$7FFF
2855   0750~            	LD	BC,$0500
2856   0750~            	CALL	NEWLINE
2857   0750~            	CALL	REGDMP
2858   0750~            	CALL	Z280_BNKCPYX
2859   0750~            
2860   0750~            	CALL	NEWLINE
2861   0750~            	CALL	NEWLINE
2862   0750~            	CALL	NEWLINE
2863   0750~            ;
2864   0750             #ENDIF
2865   0750             ;
2866   0750~            #IF 0
2867   0750~            ;
2868   0750~            	LD	HL,0
2869   0750~            	CALL	DBG_NOTE
2870   0750~            	LD	HL,48
2871   0750~            	CALL	DBG_NOTE
2872   0750~            	LD	HL,204
2873   0750~            	CALL	DBG_NOTE
2874   0750~            	LD	HL,268
2875   0750~            	CALL	DBG_NOTE
2876   0750~            	LD	HL,436
2877   0750~            	CALL	DBG_NOTE
2878   0750~            ;
2879   0750~            	JP	INITSYS4
2880   0750~            ;
2881   0750~            DBG_NOTE:
2882   0750~            	PUSH	HL
2883   0750~            	CALL	NEWLINE
2884   0750~            	PRTS("AY: $")
2884   0750~            	PRTS("AY: $")
2885   0750~            	CALL	PRTDEC16
2886   0750~            	PRTS("=$")
2886   0750~            	PRTS("=$")
2887   0750~            	CALL	AY_NOTE
2888   0750~            	LD	HL,(AY_PENDING_PERIOD)
2889   0750~            	CALL	PRTDEC16
2890   0750~            	POP	HL
2891   0750~            ;
2892   0750~            	PRTS(" SN: $")
2892   0750~            	PRTS(" SN: $")
2893   0750~            	CALL	PRTDEC16
2894   0750~            	PRTS("=$")
2894   0750~            	PRTS("=$")
2895   0750~            	CALL	SN7_NOTE
2896   0750~            	LD	HL,(SN7_PENDING_PERIOD)
2897   0750~            	CALL	PRTDEC16
2898   0750~            ;
2899   0750~            	RET
2900   0750~            ;
2901   0750             #ENDIF
2902   0750             ;
2903   0750             INITSYS4:
2904   0750             ;
2905   0750~            #IF (MEMMGR == MM_Z280)
2906   0750~            	; LEAVE SYSTEM MODE STACK POINTING TO AN OK PLACE
2907   0750~            	LD	SP,HB_STACK		; NOW USE REAL SYSTEM STACK LOC
2908   0750~            ;
2909   0750~            	HB_DI				; NOT SURE THIS IS NEEDED
2910   0750~            ;
2911   0750~            	; ACTIVATE THE CORRECT USER MODE BANK
2912   0750~            	LD	A,(HB_CURBNK)		; GET CURRENT BANK
2913   0750~            	CALL	HBX_BNKSEL
2914   0750~            ;
2915   0750~            	; PRESET THE USER MODE STACK
2916   0750~            	LD	HL,HBX_LOC
2917   0750~            	LDCTL	USP,HL
2918   0750~            ;
2919   0750~            	HB_EI				; NOT SURE THIS IS NEEDED
2920   0750~            ;
2921   0750~            	; SWITCH TO USER MODE NOW
2922   0750~            	LD	C,Z280_MSR
2923   0750~            	LD	HL,$407F
2924   0750~            	LDCTL	(C),HL
2925   0750             #ENDIF
2926   0750             ;
2927   0750~            #IFDEF TESTING
2928   0750~            	CALL	SND_BEEP
2929   0750             #ENDIF
2930   0750             ;
2931   0750~            #IFNDEF ROMBOOT
2932   0750~            ;
2933   0750~            	; COPY OS IMAGE: BID_USR:<IMG START> --> BID_USR:0
2934   0750~            	LD	B,BF_SYSSETCPY		; HBIOS FUNC: SETUP BANK COPY
2935   0750~            	LD	D,BID_USR		; D = DEST BANK = USER BANK
2936   0750~            	;LD	E,BID_USR		; E = SRC BANK = USER BANK
2937   0750~            	LD	A,(HB_APPBNK)		; GET APP LOAD BANK
2938   0750~            	LD	E,A			; USE AS SOURCE
2939   0750~            	LD	HL,$8000		; HL = COPY LEN = ENTIRE BANK
2940   0750~            	RST	08			; DO IT
2941   0750~            	LD	B,BF_SYSBNKCPY		; HBIOS FUNC: PERFORM BANK COPY
2942   0750~            	LD	HL,HB_END		; COPY FROM END OF HBIOS
2943   0750~            	LD	DE,0			; TO USER ADDRESS 0
2944   0750~            	RST	08			; DO IT
2945   0750~            ;
2946   0750             #ENDIF
2947   0750             ;
2948   0750             ; CHAIN TO LOADER
2949   0750             ;
2950   0750             #IFDEF ROMBOOT
2951   0750               #IF (ROMSIZE > 0)
2952   0750 3E 01       	LD	A,BID_IMG0		; CHAIN TO OS IMAGES BANK
2953   0752~              #ELSE
2954   0752~            	LD	A,BID_USR		; CHAIN TO USER BANK
2955   0752               #ENDIF
2956   0752~            #ELSE
2957   0752~            	LD	A,BID_USR		; CHAIN TO USER BANK
2958   0752             #ENDIF
2959   0752 DD 21 00 00 	LD	IX,0			; ENTER AT ADDRESS 0
2960   0756 CD 8E FE    	CALL	HBX_BNKCALL		; GO THERE
2961   0759 76          	HALT				; WE SHOULD NEVER COME BACK!
2962   075A             ;
2963   075A             ;	CALL A LIST OF ROUTINES POINTED TO BY DE OF LENGTH B.
2964   075A             ;
2965   075A             CALLLIST:
2966   075A 1A          	LD	A,(DE)
2967   075B 6F          	LD	L,A
2968   075C 13          	INC	DE
2969   075D 1A          	LD	A,(DE)
2970   075E 67          	LD	H,A
2971   075F 13          	INC	DE
2972   0760 D5          	PUSH	DE
2973   0761 C5          	PUSH	BC
2974   0762 CD CD 1A    	CALL	JPHL
2975   0765 C1          	POP	BC
2976   0766 D1          	POP	DE
2977   0767 10 F1       	DJNZ	CALLLIST
2978   0769             CALLDUMMY:
2979   0769 C9          	RET
2980   076A             
2981   076A             ;
2982   076A             ;==================================================================================================
2983   076A             ;   TABLE OF RECOVERY MODE INITIALIZATION ENTRY POINTS
2984   076A             ;==================================================================================================
2985   076A             ;
2986   076A             ; USE "CALLDUMMY" IF NO ENTRY REQUIRED
2987   076A             ;
2988   076A~            #IF (BT_REC_TYPE != BT_REC_NONE)
2989   076A~            ;
2990   076A~            HB_PCINIT_REC:
2991   076A~              #IF ((PLATFORM == PLT_SBC) | (PLATFORM == PLT_MBC))
2992   076A~            	.DW	UART_PREINIT
2993   076A~            ;	.DW	CALLDUMMY
2994   076A~              #ENDIF
2995   076A~            HB_PCINITRLEN	.EQU	(($ - HB_PCINIT_REC) / 2)
2996   076A~            ;
2997   076A~            HB_INIT_REC:
2998   076A~              #IF ((PLATFORM == PLT_SBC) | (PLATFORM == PLT_MBC))
2999   076A~            	.DW	UART_INIT
3000   076A~            	.DW	MD_INIT
3001   076A~            	.DW	PPIDE_INIT
3002   076A~              #ENDIF
3003   076A~            HB_INITRLEN	.EQU	(($ - HB_INIT_REC) / 2)
3004   076A~            ;
3005   076A             #ENDIF
3006   076A             ;
3007   076A             ;==================================================================================================
3008   076A             ;   TABLE OF PRE-CONSOLE INITIALIZATION ENTRY POINTS
3009   076A             ;==================================================================================================
3010   076A             ;
3011   076A             HB_PCINITTBL:
3012   076A~            #IF (DSKYENABLE)
3013   076A~            	.DW	DSKY_PREINIT
3014   076A             #ENDIF
3015   076A             #IF (H8FPENABLE)
3016   076A A2 1E       	.DW	H8P_PREINIT
3017   076C             #ENDIF
3018   076C~            #IF (ASCIENABLE)
3019   076C~            	.DW	ASCI_PREINIT
3020   076C             #ENDIF
3021   076C~            #IF (Z2UENABLE)
3022   076C~            	.DW	Z2U_PREINIT
3023   076C             #ENDIF
3024   076C             #IF (UARTENABLE)
3025   076C 9D 0D       	.DW	UART_PREINIT
3026   076E             #ENDIF
3027   076E~            #IF (DUARTENABLE)
3028   076E~            	.DW	DUART_PREINIT
3029   076E             #ENDIF
3030   076E~            #IF (SIOENABLE)
3031   076E~            	.DW	SIO_PREINIT
3032   076E             #ENDIF
3033   076E~            #IF (ACIAENABLE)
3034   076E~            	.DW	ACIA_PREINIT
3035   076E             #ENDIF
3036   076E~            #IF (PIOENABLE)
3037   076E~            	.DW	PIO_PREINIT
3038   076E             #ENDIF
3039   076E~            #IF LPTENABLE)
3040   076E~            	.DW	LPT_PREINIT
3041   076E             #ENDIF
3042   076E~            #IF (PIO_4P | PIO_ZP)
3043   076E~            	.DW	PIO_PREINIT
3044   076E             #ENDIF
3045   076E~            #IF (UFENABLE)
3046   076E~            	.DW	UF_PREINIT
3047   076E             #ENDIF
3048   076E~            #IF (TMSENABLE)
3049   076E~            	.DW	TMS_PREINIT
3050   076E             #ENDIF
3051   076E             HB_PCINITTBLLEN	.EQU	(($ - HB_PCINITTBL) / 2)
3052   076E             
3053   076E             ;==================================================================================================
3054   076E             ;   TABLE OF INITIALIZATION ENTRY POINTS
3055   076E             ;==================================================================================================
3056   076E             ;
3057   076E             HB_INITTBL:
3058   076E~            #IF (KIOENABLE)
3059   076E~            	.DW	KIO_INIT
3060   076E             #ENDIF
3061   076E~            #IF (CTCENABLE)
3062   076E~            	.DW	CTC_INIT
3063   076E             #ENDIF
3064   076E~            #IF (DSKYENABLE)
3065   076E~            	.DW	DSKY_INIT
3066   076E             #ENDIF
3067   076E             #IF (H8FPENABLE)
3068   076E A9 1E       	.DW	H8P_INIT
3069   0770             #ENDIF
3070   0770~            #IF (AY38910ENABLE)
3071   0770~            	.DW	AY38910_INIT		; AUDIBLE INDICATOR OF BOOT START
3072   0770             #ENDIF
3073   0770~            #IF (SN76489ENABLE)
3074   0770~            	.DW	SN76489_INIT
3075   0770             #ENDIF
3076   0770~            #IF (YM2612ENABLE)
3077   0770~            	.DW	YM2612_INIT
3078   0770             #ENDIF
3079   0770~            #IF (SPKENABLE)
3080   0770~            	.DW	SP_INIT			; AUDIBLE INDICATOR OF BOOT START
3081   0770             #ENDIF
3082   0770~            #IF (ASCIENABLE)
3083   0770~            	.DW	ASCI_INIT
3084   0770             #ENDIF
3085   0770~            #IF (Z2UENABLE)
3086   0770~            	.DW	Z2U_INIT
3087   0770             #ENDIF
3088   0770             #IF (UARTENABLE)
3089   0770 E2 0D       	.DW	UART_INIT
3090   0772             #ENDIF
3091   0772~            #IF (DUARTENABLE)
3092   0772~            	.DW	DUART_INIT
3093   0772             #ENDIF
3094   0772~            #IF (SIOENABLE)
3095   0772~            	.DW	SIO_INIT
3096   0772             #ENDIF
3097   0772~            #IF (ACIAENABLE)
3098   0772~            	.DW	ACIA_INIT
3099   0772             #ENDIF
3100   0772~            #IF (PIOENABLE)
3101   0772~            	.DW	PIO_INIT
3102   0772             #ENDIF
3103   0772~            #IF (LPTENABLE)
3104   0772~            	.DW	LPT_INIT
3105   0772             #ENDIF
3106   0772~            #IF (PIO_4P | PIO_ZP)
3107   0772~            	.DW	PIO_INIT
3108   0772             #ENDIF
3109   0772~            #IF (UFENABLE)
3110   0772~            	.DW	UF_INIT
3111   0772             #ENDIF
3112   0772~            #IF (DSRTCENABLE)
3113   0772~            	.DW	DSRTC_INIT
3114   0772             #ENDIF
3115   0772~            #IF (DS1501RTCENABLE)
3116   0772~            	.DW	DS1501RTC_INIT
3117   0772             #ENDIF
3118   0772~            #IF (BQRTCENABLE)
3119   0772~            	.DW	BQRTC_INIT
3120   0772             #ENDIF
3121   0772~            #IF (SIMRTCENABLE)
3122   0772~            	.DW	SIMRTC_INIT
3123   0772             #ENDIF
3124   0772~            #IF (INTRTCENABLE)
3125   0772~            	.DW	INTRTC_INIT
3126   0772             #ENDIF
3127   0772~            #IF (DS7RTCENABLE)
3128   0772~            	.DW	PCF8584_INIT
3129   0772~            	.DW	DS7RTC_INIT
3130   0772             #ENDIF
3131   0772~            #IF (RP5RTCENABLE)
3132   0772~            	.DW	RP5RTC_INIT
3133   0772             #ENDIF
3134   0772~            #IF (VDUENABLE)
3135   0772~            	.DW	VDU_INIT
3136   0772             #ENDIF
3137   0772~            #IF (CVDUENABLE)
3138   0772~            	.DW	CVDU_INIT
3139   0772             #ENDIF
3140   0772~            #IF (VGAENABLE)
3141   0772~            	.DW	VGA_INIT
3142   0772             #ENDIF
3143   0772~            #IF (GDCENABLE)
3144   0772~            	.DW	GDC_INIT
3145   0772             #ENDIF
3146   0772~            #IF (TMSENABLE)
3147   0772~            	.DW	TMS_INIT
3148   0772             #ENDIF
3149   0772             ;#IF (DSKYENABLE)
3150   0772             ;	.DW	DSKY_INIT
3151   0772             ;#ENDIF
3152   0772~            #IF (DMAENABLE)
3153   0772~            	.DW	DMA_INIT
3154   0772             #ENDIF
3155   0772             #IF (MDENABLE)
3156   0772 B4 10       	.DW	MD_INIT
3157   0774             #ENDIF
3158   0774~            #IF (FDENABLE)
3159   0774~            	.DW	FD_INIT
3160   0774             #ENDIF
3161   0774~            #IF (RFENABLE)
3162   0774~            	.DW	RF_INIT
3163   0774             #ENDIF
3164   0774~            #IF (IDEENABLE)
3165   0774~            	.DW	IDE_INIT
3166   0774             #ENDIF
3167   0774             #IF (PPIDEENABLE)
3168   0774 8D 12       	.DW	PPIDE_INIT
3169   0776             #ENDIF
3170   0776~            #IF (SDENABLE)
3171   0776~            	.DW	SD_INIT
3172   0776             #ENDIF
3173   0776~            #IF (HDSKENABLE)
3174   0776~            	.DW	HDSK_INIT
3175   0776             #ENDIF
3176   0776~            #IF (PRPENABLE)
3177   0776~            	.DW	PRP_INIT
3178   0776             #ENDIF
3179   0776~            #IF (PPPENABLE)
3180   0776~            	.DW	PPP_INIT
3181   0776             #ENDIF
3182   0776             ;
3183   0776             HB_INITTBLLEN	.EQU	(($ - HB_INITTBL) / 2)
3184   0776             ;
3185   0776             ;==================================================================================================
3186   0776             ;   IDLE
3187   0776             ;==================================================================================================
3188   0776             ;
3189   0776             ;__________________________________________________________________________________________________
3190   0776             ;
3191   0776             IDLE:
3192   0776 F5          	PUSH	AF
3193   0777 C5          	PUSH	BC
3194   0778 D5          	PUSH	DE
3195   0779 E5          	PUSH	HL
3196   077A FD E5       	PUSH	IY
3197   077C~            #IF (FDENABLE)
3198   077C~            	CALL	FD_IDLE
3199   077C             #ENDIF
3200   077C FD E1       	POP	IY
3201   077E E1          	POP	HL
3202   077F D1          	POP	DE
3203   0780 C1          	POP	BC
3204   0781 F1          	POP	AF
3205   0782 C9          	RET
3206   0783             ;
3207   0783             ;==================================================================================================
3208   0783             ;   BIOS FUNCTION DISPATCHER
3209   0783             ;==================================================================================================
3210   0783             ;
3211   0783             ; MAIN BIOS FUNCTION
3212   0783             ;   B: FUNCTION
3213   0783             ;__________________________________________________________________________________________________
3214   0783             ;
3215   0783             HB_DISPATCH:
3216   0783             ;
3217   0783~            #IF (MEMMGR == MM_Z280)
3218   0783~            	; FOR Z280 MEMMGR, WE DISPATCH VIA THE Z280 SYSCALL.
3219   0783~            	; THE SYSCALL MECHANISM WILL CLEAR INTERRUPTS.  IN
3220   0783~            	; GENERAL, INTERRUPTS ARE OK DURING API PROCESSING,
3221   0783~            	; SO ENABLE THEM HERE.
3222   0783~            	HB_EI
3223   0783             #ENDIF
3224   0783             ;
3225   0783             ;
3226   0783~            #IF FALSE	; *DEBUG* START
3227   0783~            ;
3228   0783~            	CALL	HB_DISPATCH1	; DO THE WORK
3229   0783~            ;
3230   0783~            	; CHECK STACK INTEGRITY
3231   0783~            	PUSH	AF
3232   0783~            	LD	A,(HB_STACK - HB_STKSIZ + $08)
3233   0783~            	CP	$FF
3234   0783~            	SYSCHKERR(ERR_INTERNAL)
3234   0783~            	SYSCHKERR(ERR_INTERNAL)
3234   0783~            	SYSCHKERR(ERR_INTERNAL)
3234   0783~            	SYSCHKERR(ERR_INTERNAL)
3234   0783~            	SYSCHKERR(ERR_INTERNAL)
3235   0783~            	LD	A,$FF
3236   0783~            	LD	(HB_STACK - HB_STKSIZ + $08),A
3237   0783~            	POP	AF
3238   0783~            	RET
3239   0783~            HB_DISPATCH1:
3240   0783~            ;
3241   0783             #ENDIF	; *DEBUG* END
3242   0783             ;
3243   0783 78          	LD	A,B			; REQUESTED FUNCTION IS IN B
3244   0784 FE 10       	CP	BF_CIO + $10		; $00-$0F: CHARACTER I/O
3245   0786 DA AF 07    	JP	C,CIO_DISPATCH
3246   0789 FE 20       	CP	BF_DIO + $10		; $10-$1F: DISK I/O
3247   078B DA 4E 08    	JP	C,DIO_DISPATCH
3248   078E FE 30       	CP	BF_RTC + $10		; $20-$2F: REAL TIME CLOCK (RTC)
3249   0790 DA 64 09    	JP	C,RTC_DISPATCH
3250   0793 FE 40       	CP	BF_EMU + $10		; $30-$3F: EMULATION
3251   0795 38 11       	JR	C,HB_DISPERR
3252   0797 FE 50       	CP	BF_VDA + $10		; $40-$4F: VIDEO DISPLAY ADAPTER
3253   0799 DA 7E 09    	JP	C,VDA_DISPATCH
3254   079C FE 58       	CP	BF_SND + $08		; $50-$58: SOUND DRIVERS
3255   079E DA D3 09    	JP	C,SND_DISPATCH
3256   07A1 FE F0       	CP	BF_SYS			; SKIP TO BF_SYS VALUE AT $F0
3257   07A3 38 03       	JR	C,HB_DISPERR		; ERROR IF LESS THAN BF_SYS
3258   07A5 C3 32 0A    	JP	SYS_DISPATCH		; OTHERWISE SYS CALL
3259   07A8             	; FALL THRU
3260   07A8             ;
3261   07A8             HB_DISPERR:
3262   07A8             	SYSCHKERR(ERR_NOFUNC)
3262   07A8             
3262   07A8 CD 60 23    
3262   07AB 3E FD       
3262   07AD B7          
3263   07AE C9          	RET
3264   07AF             ;
3265   07AF             ;==================================================================================================
3266   07AF             ;   CHARACTER I/O DEVICE FUNCTION DISPATCHER
3267   07AF             ;==================================================================================================
3268   07AF             ;
3269   07AF             ; ROUTE CALL TO SPECIFIED CHARACTER I/O DRIVER
3270   07AF             ;   B: FUNCTION
3271   07AF             ;   C: UNIT NUMBER
3272   07AF             ;
3273   07AF             CIO_DISPATCH:
3274   07AF CB 79       	BIT	7,C			; CHECK FOR SPECIAL UNIT CODE
3275   07B1 C4 C0 07    	CALL	NZ,CIO_SPECIAL		; IF SO, HANDLE IT
3276   07B4             
3277   07B4 FD E5       	PUSH	IY			; SAVE INCOMING IY
3278   07B6             
3279   07B6 FD 21 CE 07 	LD	IY,CIO_TBL		; POINT IY TO START OF CIO TABLE
3280   07BA CD F5 0C    	CALL	HB_DISPCALL		; GO TO GENERIC API CALL CODE
3281   07BD             
3282   07BD FD E1       	POP	IY			; RESTORE IY
3283   07BF C9          	RET				; AND DONE
3284   07C0             ;
3285   07C0             ; SPECIAL HANDLING FOR DEDICATED UNIT CODES
3286   07C0             ;
3287   07C0             CIO_SPECIAL:
3288   07C0             	; FOR NOW, ONLY SPECIAL CODE IS A CONSOLE REQUEST
3289   07C0             	; SO JUST SWAP IN ACTIVE CONSOLE UNIT
3290   07C0 3A 12 01    	LD	A,(CB_CONDEV)		; GET ACTIVE CONSOLE
3291   07C3 4F          	LD	C,A			; OVERLAY UNIT CODE IN C
3292   07C4 C9          	RET				; AND REJOIN MAIN DISPATCH FLOW
3293   07C5             ;
3294   07C5             ; ADD AN ENTRY TO THE CIO UNIT TABLE (SEE HB_ADDENT FOR DETAILS)
3295   07C5             ;
3296   07C5             CIO_ADDENT:
3297   07C5 21 CE 07    	LD	HL,CIO_TBL		; POINT TO CIO TABLE
3298   07C8 C3 3F 0D    	JP	HB_ADDENT		; ... AND GO TO COMMON CODE
3299   07CB             ;
3300   07CB             ; HBIOS CHARACTER DEVICE UNIT TABLE
3301   07CB             ;
3302   07CB             ; TABLE IS BUILT DYNAMICALLY BY EACH DRIVER DURING INITIALIZATION.
3303   07CB             ; THE TABLE IS PREFIXED BY TWO BYTES.  TABLE - 1 CONTAINS THE CURRENT
3304   07CB             ; NUMBER OF ENTRIES.  TABLE - 2 CONTAINS THE MAXIMUM NUMBER OF ENTRIES.
3305   07CB             ; TABLE - 3 CONTAINS THE NUMBER OF CIO FUNCTION IDS
3306   07CB             ; EACH ENTRY IS DEFINED AS:
3307   07CB             ;
3308   07CB             ;	WORD	DRIVER FUNCTION TABLE ADDRESS
3309   07CB             ;	WORD	UNIT SPECIFIC DATA (TYPICALLY A DEVICE INSTANCE DATA ADDRESS)
3310   07CB             ;
3311   07CB             CIO_FNCNT	.EQU	7		; NUMBER OF CIO FUNCS (FOR RANGE CHECK)
3312   07CB             CIO_MAX		.EQU	32		; UP TO 32 UNITS
3313   07CB             CIO_SIZ		.EQU	CIO_MAX * 4	; EACH ENTRY IS 4 BYTES
3314   07CB             ;
3315   07CB 07          		.DB	CIO_FNCNT	; CIO FUNCTION COUNT (FOR RANGE CHECK)
3316   07CC 20          		.DB	CIO_MAX		; MAX ENTRY COUNT TABLE PREFIX
3317   07CD 00          CIO_CNT		.DB	0		; ENTRY COUNT PREFIX
3318   07CE 00 00 00 00 CIO_TBL		.FILL	CIO_SIZ,0	; SPACE FOR ENTRIES
3318   07D2 00 00 00 00 
3318   07D6 00 00 00 00 
3318   07DA 00 00 00 00 
3318   07DE 00 00 00 00 
3318   07E2 00 00 00 00 
3318   07E6 00 00 00 00 
3318   07EA 00 00 00 00 
3318   07EE 00 00 00 00 
3318   07F2 00 00 00 00 
3318   07F6 00 00 00 00 
3318   07FA 00 00 00 00 
3318   07FE 00 00 00 00 
3318   0802 00 00 00 00 
3318   0806 00 00 00 00 
3318   080A 00 00 00 00 
3318   080E 00 00 00 00 
3318   0812 00 00 00 00 
3318   0816 00 00 00 00 
3318   081A 00 00 00 00 
3318   081E 00 00 00 00 
3318   0822 00 00 00 00 
3318   0826 00 00 00 00 
3318   082A 00 00 00 00 
3318   082E 00 00 00 00 
3318   0832 00 00 00 00 
3318   0836 00 00 00 00 
3318   083A 00 00 00 00 
3318   083E 00 00 00 00 
3318   0842 00 00 00 00 
3318   0846 00 00 00 00 
3318   084A 00 00 00 00 
3319   084E             ;
3320   084E             ;==================================================================================================
3321   084E             ; DISK I/O DEVICE FUNCTION DISPATCHER
3322   084E             ;==================================================================================================
3323   084E             ;
3324   084E             ; ROUTE CALL TO SPECIFIED DISK I/O DRIVER
3325   084E             ;   B: FUNCTION
3326   084E             ;   C: UNIT NUMBER
3327   084E             ;
3328   084E             DIO_DISPATCH:
3329   084E             ;
3330   084E~            #IF FALSE	; *DEBUG* START
3331   084E~            ;
3332   084E~            	; DUMP INCOMING CALL
3333   084E~            	CALL	NEWLINE
3334   084E~            	PRTS("DIO>$")
3334   084E~            	PRTS("DIO>$")
3335   084E~            	CALL	REGDMP			; DUMP REGS, NONE DESTROYED
3336   084E~            ;
3337   084E~            	; DO THE ACTUAL DISPATCH PROCESSING
3338   084E~            	CALL	DIO_DISPCALL
3339   084E~            ;
3340   084E~            	; DUMP CALL RESULTS AND RETURN
3341   084E~            	CALL	NEWLINE
3342   084E~            	PRTS("DIO<$")
3342   084E~            	PRTS("DIO<$")
3343   084E~            	CALL	REGDMP			; DUMP REGS, NONE DESTROYED
3344   084E~            	RET
3345   084E~            ;
3346   084E             #ENDIF	; *DEBUG* END
3347   084E             ;
3348   084E             DIO_DISPCALL:
3349   084E FD E5       	PUSH	IY			; SAVE INCOMING IY
3350   0850             
3351   0850 FD 21 63 08 	LD	IY,DIO_TBL		; POINT IY TO START OF DIO TABLE
3352   0854 CD F5 0C    	CALL	HB_DISPCALL		; GO TO GENERIC API CALL CODE
3353   0857             
3354   0857 FD E1       	POP	IY			; RESTORE IY
3355   0859 C9          	RET				; AND DONE
3356   085A             ;
3357   085A             ; ADD AN ENTRY TO THE DIO UNIT TABLE
3358   085A             ;
3359   085A             DIO_ADDENT:
3360   085A 21 63 08    	LD	HL,DIO_TBL		; POINT TO DIO TABLE
3361   085D C3 3F 0D    	JP	HB_ADDENT		; ... AND GO TO COMMON CODE
3362   0860             ;
3363   0860             ; HBIOS DISK DEVICE UNIT TABLE
3364   0860             ;
3365   0860             ; TABLE IS BUILT DYNAMICALLY BY EACH DRIVER DURING INITIALIZATION.
3366   0860             ; THE TABLE IS PREFIXED BY TWO BYTES.  TABLE - 1 CONTAINS THE CURRENT
3367   0860             ; NUMBER OF ENTRIES.  TABLE - 2 CONTAINS THE MAXIMUM NUMBER OF ENTRIES.
3368   0860             ; TABLE - 3 CONTAINS THE NUMBER OF DIO FUNCTION IDS
3369   0860             ; EACH ENTRY IS DEFINED AS:
3370   0860             ;
3371   0860             ;	WORD	DRIVER FUNCTION TABLE ADDRESS
3372   0860             ;	WORD	UNIT SPECIFIC DATA (TYPICALLY A DEVICE INSTANCE DATA ADDRESS)
3373   0860             ;
3374   0860             DIO_FNCNT	.EQU	12		; NUMBER OF DIO FUNCS (FOR RANGE CHECK)
3375   0860             DIO_MAX		.EQU	16		; UP TO 16 UNITS
3376   0860             DIO_SIZ		.EQU	DIO_MAX * 4	; EACH ENTRY IS 4 BYTES
3377   0860             ;
3378   0860 0C          		.DB	DIO_FNCNT	; DIO FUNCTION COUNT (FOR RANGE CHECK)
3379   0861 10          		.DB	DIO_MAX		; MAX ENTRY COUNT TABLE PREFIX
3380   0862 00          DIO_CNT		.DB	0		; ENTRY COUNT PREFIX
3381   0863 00 00 00 00 DIO_TBL		.FILL	DIO_SIZ,0	; SPACE FOR ENTRIES
3381   0867 00 00 00 00 
3381   086B 00 00 00 00 
3381   086F 00 00 00 00 
3381   0873 00 00 00 00 
3381   0877 00 00 00 00 
3381   087B 00 00 00 00 
3381   087F 00 00 00 00 
3381   0883 00 00 00 00 
3381   0887 00 00 00 00 
3381   088B 00 00 00 00 
3381   088F 00 00 00 00 
3381   0893 00 00 00 00 
3381   0897 00 00 00 00 
3381   089B 00 00 00 00 
3381   089F 00 00 00 00 
3382   08A3             ;
3383   08A3             ;==================================================================================================
3384   08A3             ; DISK READ HELPER
3385   08A3             ;==================================================================================================
3386   08A3             ;
3387   08A3             ; IMPLEMENTS MULTI SECTOR READS AND I/O TO/FROM
3388   08A3             ; BANKED RAM VIA BOUNCE BUFFER
3389   08A3             ;
3390   08A3             ; ON ENTRY:
3391   08A3             ;  TOS=READ FN ADR
3392   08A3             ;  HL=BUF ADR
3393   08A3             ;  E=SEC COUNT
3394   08A3             ;  D=BUF BANK ID
3395   08A3             ;
3396   08A3             HB_DSKREAD:
3397   08A3             ;
3398   08A3             	; THE ACTUAL SECTOR READ FUNCTION ADDRESS IS ON TOS, SAVE IT
3399   08A3 E3          	EX	(SP),HL			; SAVE HL TO TOS, HL := READ FN ADR
3400   08A4 22 5A 09    	LD	(HB_DSKFNADR),HL	; IMBED IN CALL OP BELOW
3401   08A7 E1          	POP	HL			; RECOVER HL
3402   08A8             ;
3403   08A8 ED 43 62 09 	LD	(HB_DSKCMD),BC		; SAVE HBIOS FUNC & UNIT
3404   08AC             ;
3405   08AC~            #IF (DIAGENABLE)
3406   08AC~            	; SAVE DISK UNIT NUMBER BIT MASK
3407   08AC~            	LD	A,C			; GET DISK UNIT NUMBER
3408   08AC~            	LD	B,A			; PUT IN B FOR LOOP COUNTER
3409   08AC~            	INC	B			; LOOP ONE EXTRA TIME TO HANDLE UNIT=0
3410   08AC~            	XOR	A			; START WITH ACCUM ZERO
3411   08AC~            	SCF				; ... AND CF SET
3412   08AC~            HB_DSKREAD0:
3413   08AC~            	RLA				; ROTATE BIT
3414   08AC~            	DJNZ	HB_DSKREAD0		; ... UNTIL IN PROPER LOCATION
3415   08AC~            	LD	(HB_DSKBIT),A		; SAVE IT FOR DIAGNOSTICS
3416   08AC             #ENDIF
3417   08AC             ;
3418   08AC             #IF 1
3419   08AC             	; CHECK TO SEE IF INTER-BANK I/O NEEDED.
3420   08AC CB 7C       	BIT	7,H			; TGT BUF IN UPPER 32K?
3421   08AE C2 47 09    	JP	NZ,HB_DSKIO		; IF SO, NON-BANKED
3422   08B1 7A          	LD	A,D			; GET TGT BANK
3423   08B2 FE 8D       	CP	BID_BIOS		; BIOS BANK?
3424   08B4 CA 47 09    	JP	Z,HB_DSKIO		; IF SO, NON-BANKED
3425   08B7             #ENDIF
3426   08B7             ;
3427   08B7             #IF 1
3428   08B7             	; RAM BANK RANGE CHECK
3429   08B7 7A          	LD	A,D			; GET TGT BANK
3430   08B8 FE 8F       	CP	BID_RAMN		; BANK IN RANGE 0-N?
3431   08BA D4 82 23    	CALL	NC,PANIC		; IF >N, PANIC
3432   08BD             #ENDIF
3433   08BD             ;
3434   08BD             	; SAVE TGT BUF BNK/ADR
3435   08BD 22 5F 09    	LD	(HB_IOBUF),HL
3436   08C0 7A          	LD	A,D
3437   08C1 32 61 09    	LD	(HB_IOBNK),A
3438   08C4             ;
3439   08C4             	; SETUP READ AND LOOP COUNT
3440   08C4 43          	LD	B,E			; SEC LOOP COUNTER
3441   08C5 0E 00       	LD	C,0			; SEC COMPLETE COUNTER
3442   08C7             ;
3443   08C7             HB_DSKREAD1:
3444   08C7 21 5B 2A    	LD	HL,HB_WRKBUF		; USE WORK BUF REAL I/O
3445   08CA             ;
3446   08CA             	; CALL READ FN
3447   08CA CD 56 09    	CALL	HB_DSKFN		; READ ONE SECTOR
3448   08CD             ;
3449   08CD             	; IF FAIL, RETURN ERR
3450   08CD 20 22       	JR	NZ,HB_DSKREADX		; BAIL OUT ON ERROR
3451   08CF             ;
3452   08CF             	; BNKCPY SEC DATA TO REAL BANK/BUF & INC BUF ADR
3453   08CF C5          	PUSH	BC			; SAVE COUNTERS
3454   08D0 3A 61 09    	LD	A,(HB_IOBNK)		; DEST BANK
3455   08D3 32 E7 FF    	LD	(HB_DSTBNK),A		; ... TO PROXY
3456   08D6 3E 8D       	LD	A,BID_BIOS		; SRC BANK
3457   08D8 32 E4 FF    	LD	(HB_SRCBNK),A		; ... TO PROXY
3458   08DB 01 00 02    	LD	BC,512			; COPY 512 BYTES (1 SEC)
3459   08DE ED 5B 5F 09 	LD	DE,(HB_IOBUF)		; TGT BUFFER ADR
3460   08E2 21 5B 2A    	LD	HL,HB_WRKBUF		; SOURCE BUFFER
3461   08E5 CD 3D FE    	CALL	HBX_BNKCPY		; DO BANK COPY
3462   08E8 ED 53 5F 09 	LD	(HB_IOBUF),DE		; SAVE UPDATED TGT BUF ADR
3463   08EC C1          	POP	BC			; RESTORE COUNTERS
3464   08ED             ;
3465   08ED             	; INC READ COUNT
3466   08ED 0C          	INC	C			; BUMP SEC READ COUNT
3467   08EE 10 D7       	DJNZ	HB_DSKREAD1		; LOOP AS NEEDED
3468   08F0 AF          	XOR	A			; SIGNAL SUCCESS
3469   08F1             ;
3470   08F1             HB_DSKREADX:
3471   08F1 2A 5F 09    	LD	HL,(HB_IOBUF)		; NEXT BUF ADR
3472   08F4 18 5D       	JR	HB_DSKIOX		; DONE
3473   08F6             ;
3474   08F6             ;==================================================================================================
3475   08F6             ; DISK WRITE HELPER
3476   08F6             ;==================================================================================================
3477   08F6             ;
3478   08F6             ; IMPLEMENTS MULTI SECTOR WRITES AND I/O TO/FROM
3479   08F6             ; BANKED RAM VIA BOUNCE BUFFER
3480   08F6             ;
3481   08F6             ; TOS=WRITE FN ADR
3482   08F6             ; HL=BUF ADR
3483   08F6             ; E=SEC COUNT
3484   08F6             ; D=BUF BANK ID
3485   08F6             ;
3486   08F6             HB_DSKWRITE:
3487   08F6             ;
3488   08F6             	; THE ACTUAL SECTOR READ FUNCTION ADDRESS IS ON TOS, SAVE IT
3489   08F6 E3          	EX	(SP),HL			; SAVE HL TO TOS, HL := READ FN ADR
3490   08F7 22 5A 09    	LD	(HB_DSKFNADR),HL	; IMBED IN CALL OP BELOW
3491   08FA E1          	POP	HL			; RECOVER HL
3492   08FB             ;
3493   08FB ED 43 62 09 	LD	(HB_DSKCMD),BC		; SAVE HBIOS FUNC & UNIT
3494   08FF             ;
3495   08FF~            #IF (DIAGENABLE)
3496   08FF~            	; SAVE DISK UNIT NUMBER BIT MASK
3497   08FF~            	LD	A,C			; GET DISK UNIT NUMBER
3498   08FF~            	LD	B,A			; PUT IN B FOR LOOP COUNTER
3499   08FF~            	INC	B			; LOOP ONE EXTRA TIME TO HANDLE UNIT=0
3500   08FF~            	XOR	A			; START WITH ACCUM ZERO
3501   08FF~            	SCF				; ... AND CF SET
3502   08FF~            HB_DSKWRITE0:
3503   08FF~            	RLA				; ROTATE BIT
3504   08FF~            	DJNZ	HB_DSKWRITE0		; ... UNTIL IN PROPER LOCATION
3505   08FF~            	LD	(HB_DSKBIT),A		; SAVE IT FOR DIAGNOSTICS
3506   08FF             #ENDIF
3507   08FF             ;
3508   08FF             #IF 1
3509   08FF             	; CHECK TO SEE IF INTER-BANK I/O NEEDED.
3510   08FF CB 7C       	BIT	7,H			; TGT BUF IN UPPER 32K?
3511   0901 C2 47 09    	JP	NZ,HB_DSKIO		; IF SO, NON-BANKED
3512   0904 7A          	LD	A,D			; GET TGT BANK
3513   0905 FE 8D       	CP	BID_BIOS		; BIOS BANK?
3514   0907 CA 47 09    	JP	Z,HB_DSKIO		; IF SO, NON-BANKED
3515   090A             #ENDIF
3516   090A             ;
3517   090A             #IF 1
3518   090A             	; RAM BANK RANGE CHECK
3519   090A 7A          	LD	A,D			; GET TGT BANK
3520   090B FE 8F       	CP	BID_RAMN		; BANK IN RANGE 0-N?
3521   090D D4 82 23    	CALL	NC,PANIC		; IF >N, PANIC
3522   0910             #ENDIF
3523   0910             ;
3524   0910             	; SAVE TGT BUF BNK/ADR
3525   0910 22 5F 09    	LD	(HB_IOBUF),HL
3526   0913 7A          	LD	A,D
3527   0914 32 61 09    	LD	(HB_IOBNK),A
3528   0917             ;
3529   0917             	; SETUP WRITE AND LOOP COUNT
3530   0917 43          	LD	B,E			; SEC LOOP COUNTER
3531   0918 0E 00       	LD	C,0			; SEC COMPLETE COUNTER
3532   091A             ;
3533   091A             HB_DSKWRITE1:
3534   091A             	; BNKCPY SEC DATA TO WORK BANK/BUF & INC BUF ADR
3535   091A C5          	PUSH	BC			; SAVE COUNTERS
3536   091B 3E 8D       	LD	A,BID_BIOS		; DEST BANK
3537   091D 32 E7 FF    	LD	(HB_DSTBNK),A		; ... TO PROXY
3538   0920 3A 61 09    	LD	A,(HB_IOBNK)		; SRC BANK
3539   0923 32 E4 FF    	LD	(HB_SRCBNK),A		; ... TO PROXY
3540   0926 01 00 02    	LD	BC,512			; COPY 512 BYTES (1 SEC)
3541   0929 11 5B 2A    	LD	DE,HB_WRKBUF		; TGT BUFFER ADR
3542   092C 2A 5F 09    	LD	HL,(HB_IOBUF)		; SOURCE BUFFER
3543   092F CD 3D FE    	CALL	HBX_BNKCPY		; DO BANK COPY
3544   0932 22 5F 09    	LD	(HB_IOBUF),HL		; SAVE UPDATED SRC BUF ADR
3545   0935 C1          	POP	BC			; RESTORE COUNTERS
3546   0936             ;
3547   0936             	; CALL WRITE FN
3548   0936 21 5B 2A    	LD	HL,HB_WRKBUF		; WRITE FROM WORK BUFFER
3549   0939 CD 56 09    	CALL	HB_DSKFN		; WRITE ONE SECTOR
3550   093C             ;
3551   093C             	; IF FAIL, RETURN ERR
3552   093C 20 04       	JR	NZ,HB_DSKWRITEX		; BAIL OUT ON ERROR
3553   093E             ;
3554   093E             	; INC WRITE COUNT
3555   093E 0C          	INC	C			; BUMP SEC WRITE COUNT
3556   093F 10 D9       	DJNZ	HB_DSKWRITE1		; LOOP AS NEEDED
3557   0941 AF          	XOR	A			; SIGNAL SUCCESS
3558   0942             ;
3559   0942             HB_DSKWRITEX:
3560   0942 2A 5F 09    	LD	HL,(HB_IOBUF)		; NEXT BUF ADR
3561   0945 18 0C       	JR	HB_DSKIOX		; DONE
3562   0947             ;
3563   0947             ;==================================================================================================
3564   0947             ; NON-BANKED DISK READ/WRITE
3565   0947             ;==================================================================================================
3566   0947             ;
3567   0947             HB_DSKIO:
3568   0947             ;
3569   0947             	; SETUP LOOP COUNT
3570   0947 43          	LD	B,E			; SEC LOOP COUNTER
3571   0948 0E 00       	LD	C,0			; SEC COMPLETE COUNTER
3572   094A             ;
3573   094A             HB_DSKIO1:
3574   094A             	; CALL READ/WRITE FN
3575   094A CD 56 09    	CALL	HB_DSKFN		; READ/WRITE ONE SECTOR
3576   094D             ;
3577   094D             	; IF FAIL, RETURN ERR
3578   094D 20 04       	JR	NZ,HB_DSKIOX		; BAIL OUT ON ERROR
3579   094F             ;
3580   094F             	; INC SECTOR COUNT
3581   094F 0C          	INC	C			; BUMP SEC READ/WRITE COUNT
3582   0950 10 F8       	DJNZ	HB_DSKIO1		; LOOP AS NEEDED
3583   0952 AF          	XOR	A			; SIGNAL SUCCESS
3584   0953             ;
3585   0953             HB_DSKIOX:
3586   0953 59          	LD	E,C			; WRITE COUNT TO E
3587   0954 B7          	OR	A			; SET RESULT FLAGS
3588   0955 C9          	RET				; DONE
3589   0956             ;
3590   0956             HB_DSKFN:
3591   0956 C5          	PUSH	BC			; SAVE COUNTERS
3592   0957~            #IF (DIAGENABLE & DIAGDISKIO)
3593   0957~            	LD	A,(HB_DSKBIT)		; LOAD UNIT DISK BIT MASK
3594   0957~            	OUT	(DIAGPORT),A		; DISPLAY ON DIAG LEDS
3595   0957             #ENDIF
3596   0957~            #IF (LEDENABLE & LEDDISKIO)
3597   0957~            	LED(%00000101)			; BIT 0 FOR TINY Z80 & MBC, BIT 2 FOR SCXXX
3597   0957~            	LED(%00000101)			; BIT 0 FOR TINY Z80 & MBC, BIT 2 FOR SCXXX
3598   0957             #ENDIF
3599   0957 1E 01       	LD	E,1			; ONE SECTOR
3600   0959             HB_DSKFNADR	.EQU	$+1
3601   0959 CD 82 23    	CALL	PANIC			; READ ONE SECTOR
3602   095C~            #IF (DIAGENABLE & DIAGDISKIO)
3603   095C~            	DIAG(DIAG_00)			; CLEAR DIAG LEDS
3603   095C~            	DIAG(DIAG_00)			; CLEAR DIAG LEDS
3604   095C             #ENDIF
3605   095C~            #IF (LEDENABLE & LEDDISKIO)
3606   095C~            	LED($00)
3606   095C~            	LED($00)
3607   095C             #ENDIF
3608   095C C1          	POP	BC			; RESTORE COUNTERS
3609   095D C9          	RET				; RETURN
3610   095E             ;
3611   095E 00          HB_DSKBIT	.DB	0		; ACTIVE DISK UNIT
3612   095F 00 00       HB_IOBUF	.DW	0		; CURRENT IO BUFFER ADR
3613   0961 00          HB_IOBNK	.DB	0		; CURRENT IO BUFFER BANK ID
3614   0962             HB_DSKCMD:
3615   0962 00          HB_DSKUNIT	.DB	0		; CURRENT DISK UNIT
3616   0963 00          HB_DSKFUNC	.DB	0		; CURRENT DISK FUNCTION
3617   0964             ;
3618   0964~            #IF (DSKYENABLE)
3619   0964~            ;
3620   0964~            ;==================================================================================================
3621   0964~            ;   DSKY DISK ACTIVITY MONITOR
3622   0964~            ;==================================================================================================
3623   0964~            ;
3624   0964~            ; THIS FUNCTION IS CALLED BY DISK DRIVERS JUST PRIOR TO
3625   0964~            ; THE START OF A DISK I/O OPERATION.
3626   0964~            ;
3627   0964~            ; THE CURRENT DISK UNIT NUMBER WILL BE DISPLAYED IN THE FIRST
3628   0964~            ; 2 SEG DISPLAYS.  THE LOWER 24 BITS OF THE SECTOR WILL BE
3629   0964~            ; DISPLAYED IN THE LAST 6 SEG DISPLAYS.
3630   0964~            ;
3631   0964~            ; A DOT IS DISPLAYED TO SEPARATE THE UNIT NUMBER FROM THE ADDRESS
3632   0964~            ; DISPLAY.  ALSO, A TRAILING DOT IS DISPLAYED IF THE I/O FUNCTION
3633   0964~            ; IS A WRITE.
3634   0964~            ;
3635   0964~            ;   HL: ADDRESS OF 32-BIT SECTOR NUMBER (LITTLE-ENDIAN)
3636   0964~            ;   ALL REGISTERS PERSERVED
3637   0964~            ;
3638   0964~            HB_DSKACT:
3639   0964~            	PUSH	AF
3640   0964~            	PUSH	BC
3641   0964~            	PUSH	DE
3642   0964~            	PUSH	HL
3643   0964~            	LD	DE,DSKY_HEXBUF+3	; START AT END
3644   0964~            	LD	B,3			; 3 BYTES OF SECTOR ADDRESS
3645   0964~            HB_DSKACT1:
3646   0964~            	LD	A,(HL)			; GET FIRST BYTE
3647   0964~            	LD	(DE),A			; AND STORE IN BUF
3648   0964~            	INC	HL			; NEXT SRC BYTE
3649   0964~            	DEC	DE			; NEXT DEST BYTE
3650   0964~            	DJNZ	HB_DSKACT1		; LOOP
3651   0964~            	LD	A,(HB_DSKUNIT)		; GET DISK UNIT NUM
3652   0964~            	LD	(DE),A			; PUT AT HEAD OF BUF
3653   0964~            HB_DSKACT2:
3654   0964~            	LD	HL,DSKY_HEXBUF		; BINARY BUF
3655   0964~            	LD	DE,DSKY_BUF		; DISPLAY BUF
3656   0964~            	CALL	DSKY_BIN2SEG		; CONVERT TO SEG DISPLAY BUF
3657   0964~            	LD	A,(DSKY_BUF+1)		; SECOND SEGMENT
3658   0964~            	OR	%10000000		; TURN ON DOT
3659   0964~            	LD	(DSKY_BUF+1),A		; SAVE IT
3660   0964~            	LD	A,(HB_DSKFUNC)		; GET CURRENT I/O FUNCTION
3661   0964~            	CP	BF_DIOWRITE		; IS IT A WRITE?
3662   0964~            	JR	NZ,HB_DSKACT3		; IF NOT, NO DOT, SKIP AHEAD
3663   0964~            	LD	A,(DSKY_BUF+7)		; LAST SEGMENT
3664   0964~            	OR	%10000000		; TURN ON DOT
3665   0964~            	LD	(DSKY_BUF+7),A		; SAVE IT
3666   0964~            HB_DSKACT3:
3667   0964~            	EX	DE,HL			; SEG DISPLAY BUF TO HL
3668   0964~            	CALL	DSKY_SHOW		; DISPLAY ON DSKY
3669   0964~            	POP	HL
3670   0964~            	POP	DE
3671   0964~            	POP	BC
3672   0964~            	POP	AF
3673   0964~            	RET
3674   0964~            ;
3675   0964~            ; THIS IS THE CHS VARIANT OF THE ABOVE.  THIS IS USED BY CHS ORIENTED
3676   0964~            ; DISK DRIVERS (BASICALLY JUST FLOPPY).
3677   0964~            ;
3678   0964~            ; THE CURRENT DISK UNIT NUMBER WILL BE DISPLAYED IN THE FIRST
3679   0964~            ; 2 SEG DISPLAYS.  THE TRACK, HEAD, AND SECTOR WILL BE DISPLAYED IN
3680   0964~            ; THE LAST 6 SEG DISPLAYS
3681   0964~            ;
3682   0964~            ;   HL: ADDRESS OF CYL,HD,SEC IN THE FORMAT CCSH
3683   0964~            ;   ALL REGISTERS PRESERVED
3684   0964~            ;
3685   0964~            HB_DSKACTCHS:
3686   0964~            	PUSH	AF
3687   0964~            	PUSH	BC
3688   0964~            	PUSH	DE
3689   0964~            	PUSH	HL
3690   0964~            	LD	DE,DSKY_HEXBUF		; START OF HEX BUF
3691   0964~            	LD	A,(HB_DSKUNIT)		; GET DISK UNIT NUM
3692   0964~            	LD	(DE),A			; PUT AT HEAD OF BUF
3693   0964~            	INC	DE			; NEXT BYTE OF BUF
3694   0964~            	LD	A,(HL)			; LSB OF TRACK
3695   0964~            	LD	(DE),A			; ADD TO BUF
3696   0964~            	INC	DE			; NEXT BYTE OF BUF
3697   0964~            	INC	HL			; BUMP TO HEAD
3698   0964~            	INC	HL			; "
3699   0964~            	INC	HL			; "
3700   0964~            	LD	A,(HL)			; GET HEAD
3701   0964~            	LD	(DE),A			; ADD TO BUF
3702   0964~            	INC	DE			; NEXT BYTE OF BUF
3703   0964~            	DEC	HL			; BACK TO SECTOR
3704   0964~            	LD	A,(HL)			; GET SECTOR
3705   0964~            	LD	(DE),A			; ADD TO BUF
3706   0964~            	JR	HB_DSKACT2
3707   0964~            ;
3708   0964             #ENDIF
3709   0964             ;
3710   0964             ;==================================================================================================
3711   0964             ;   REAL TIME CLOCK DEVICE DISPATCHER
3712   0964             ;==================================================================================================
3713   0964             ;
3714   0964             ; ROUTE CALL TO REAL TIME CLOCK DRIVER
3715   0964             ;   B: FUNCTION
3716   0964             ;
3717   0964             RTC_DISPATCH:
3718   0964 E5          	PUSH	HL			; SAVE INCOMING HL
3719   0965 2A 7B 09    	LD	HL,(RTC_DISPADR)	;
3720   0968 E3          	EX	(SP),HL
3721   0969 C9          	RET
3722   096A             ;
3723   096A             RTC_DISPERR:
3724   096A             	SYSCHKERR(ERR_NOHW)
3724   096A             
3724   096A CD 60 23    
3724   096D 3E F8       
3724   096F B7          
3725   0970 C9          	RET
3726   0971             ;
3727   0971             ; SET RTC DISPATCH ADDRESS, USED BY RTC DRIVERS DURING INIT
3728   0971             ; BC HAS ADDRESS OF DISPATCH ADDRESS
3729   0971             ; WILL ONLY SAVE THE FIRST ADDRESS SET
3730   0971             ;
3731   0971             RTC_SETDISP:
3732   0971 ED 43 7B 09 	LD	(RTC_DISPADR),BC	; SAVE THE ADDRESS
3733   0975 F6 FF       	OR	$FF			; FLAG ACTIVE VALUE
3734   0977 32 7D 09    	LD	(RTC_DISPACT),A		; SAVE IT
3735   097A C9          	RET				; AND DONE
3736   097B             ;
3737   097B             ;
3738   097B             ;
3739   097B 6A 09       RTC_DISPADR	.DW	RTC_DISPERR	; RTC DISPATCH ADDRESS
3740   097D 00          RTC_DISPACT	.DB	0		; SET WHEN DISPADR SET
3741   097E             ;
3742   097E             ;==================================================================================================
3743   097E             ;   VIDEO DISPLAY ADAPTER DEVICE DISPATCHER
3744   097E             ;==================================================================================================
3745   097E             ;
3746   097E             ; ROUTE CALL TO SPECIFIED VDA DEVICE DRIVER
3747   097E             ;   B: FUNCTION
3748   097E             ;   C: UNIT NUMBER
3749   097E             ;
3750   097E             VDA_DISPATCH:
3751   097E FD E5       	PUSH	IY			; SAVE INCOMING IY
3752   0980             
3753   0980 FD 21 93 09 	LD	IY,VDA_TBL		; POINT IY TO START OF DIO TABLE
3754   0984 CD F5 0C    	CALL	HB_DISPCALL		; GO TO GENERIC API CALL CODE
3755   0987             
3756   0987 FD E1       	POP	IY			; RESTORE IY
3757   0989 C9          	RET				; AND DONE
3758   098A             ;
3759   098A             ; ADD AN ENTRY TO THE VDA UNIT TABLE (SEE HB_ADDENT FOR DETAILS)
3760   098A             ;
3761   098A             VDA_ADDENT:
3762   098A 21 93 09    	LD	HL,VDA_TBL		; POINT TO VDA TABLE
3763   098D C3 3F 0D    	JP	HB_ADDENT		; ... AND GO TO COMMON CODE
3764   0990             ;
3765   0990             ; HBIOS VIDEO DEVICE UNIT TABLE
3766   0990             ;
3767   0990             ; TABLE IS BUILT DYNAMICALLY BY EACH DRIVER DURING INITIALIZATION.
3768   0990             ; THE TABLE IS PREFIXED BY TWO BYTES.  TABLE - 1 CONTAINS THE CURRENT
3769   0990             ; NUMBER OF ENTRIES.  TABLE - 2 CONTAINS THE MAXIMUM NUMBER OF ENTRIES.
3770   0990             ; TABLE - 3 CONTAINS THE NUMBER OF CIO FUNCTION IDS
3771   0990             ; EACH ENTRY IS DEFINED AS:
3772   0990             ;
3773   0990             ;	WORD	DRIVER FUNCTION TABLE ADDRESS
3774   0990             ;	WORD	UNIT SPECIFIC DATA (TYPICALLY A DEVICE INSTANCE DATA ADDRESS)
3775   0990             ;
3776   0990             VDA_FNCNT	.EQU	16		; NUMBER OF VDA FUNCS (FOR RANGE CHECK)
3777   0990             VDA_MAX		.EQU	16		; UP TO 16 UNITS
3778   0990             VDA_SIZ		.EQU	VDA_MAX * 4	; EACH ENTRY IS 4 BYTES
3779   0990             ;
3780   0990 10          		.DB	VDA_FNCNT	; VDA FUNCTION COUNT (FOR RANGE CHECK)
3781   0991 10          		.DB	VDA_MAX		; MAX ENTRY COUNT TABLE PREFIX
3782   0992 00          VDA_CNT		.DB	0		; ENTRY COUNT PREFIX
3783   0993 00 00 00 00 VDA_TBL		.FILL	VDA_SIZ,0	; SPACE FOR ENTRIES
3783   0997 00 00 00 00 
3783   099B 00 00 00 00 
3783   099F 00 00 00 00 
3783   09A3 00 00 00 00 
3783   09A7 00 00 00 00 
3783   09AB 00 00 00 00 
3783   09AF 00 00 00 00 
3783   09B3 00 00 00 00 
3783   09B7 00 00 00 00 
3783   09BB 00 00 00 00 
3783   09BF 00 00 00 00 
3783   09C3 00 00 00 00 
3783   09C7 00 00 00 00 
3783   09CB 00 00 00 00 
3783   09CF 00 00 00 00 
3784   09D3             
3785   09D3             ;
3786   09D3             ;
3787   09D3             ;==================================================================================================
3788   09D3             ;   SOUND ADAPTER DEVICE DISPATCHER
3789   09D3             ;==================================================================================================
3790   09D3             ;
3791   09D3             ; ROUTE CALL TO SPECIFIED SOUND DEVICE DRIVER
3792   09D3             ;   B: FUNCTION
3793   09D3             ;   C: UNIT NUMBER
3794   09D3             ;
3795   09D3             SND_DISPATCH:
3796   09D3 FD E5       	PUSH	IY			; SAVE INCOMING IY
3797   09D5             
3798   09D5 FD 21 E8 09 	LD	IY, SND_TBL		; POINT IY TO START OF DIO TABLE
3799   09D9 CD F5 0C    	CALL	HB_DISPCALL		; GO TO GENERIC API CALL CODE
3800   09DC             
3801   09DC FD E1       	POP	IY			; RESTORE IY
3802   09DE C9          	RET				; AND DONE
3803   09DF             ;
3804   09DF             ; ADD AN ENTRY TO THE SND UNIT TABLE (SEE HB_ADDENT FOR DETAILS)
3805   09DF             ;
3806   09DF             SND_ADDENT:
3807   09DF 21 E8 09    	LD	HL, SND_TBL		; POINT TO SND TABLE
3808   09E2 C3 3F 0D    	JP	HB_ADDENT		; ... AND GO TO COMMON CODE
3809   09E5             ;
3810   09E5             ; HBIOS VIDEO DEVICE UNIT TABLE
3811   09E5             ;
3812   09E5             ; TABLE IS BUILT DYNAMICALLY BY EACH DRIVER DURING INITIALIZATION.
3813   09E5             ; THE TABLE IS PREFIXED BY TWO BYTES.  TABLE - 1 CONTAINS THE CURRENT
3814   09E5             ; NUMBER OF ENTRIES.  TABLE - 2 CONTAINS THE MAXIMUM NUMBER OF ENTRIES.
3815   09E5             ; TABLE - 3 CONTAINS THE NUMBER OF SND FUNCTION IDS
3816   09E5             ; EACH ENTRY IS DEFINED AS:
3817   09E5             ;
3818   09E5             ;	WORD	DRIVER FUNCTION TABLE ADDRESS
3819   09E5             ;	WORD	UNIT SPECIFIC DATA (TYPICALLY A DEVICE INSTANCE DATA ADDRESS)
3820   09E5             ;
3821   09E5             SND_FNCNT	.EQU	8		; NUMBER OF SND FUNCS (FOR RANGE CHECK)
3822   09E5             SND_MAX		.EQU	5		; UP TO 5 UNITS
3823   09E5             SND_SIZ		.EQU	SND_MAX * 4	; EACH ENTRY IS 4 BYTES
3824   09E5             ;
3825   09E5 08          		.DB	SND_FNCNT	; SND FUNCTION COUNT (FOR RANGE CHECK)
3826   09E6 05          		.DB	SND_MAX		; MAX ENTRY COUNT TABLE PREFIX
3827   09E7 00          SND_CNT		.DB	0		; ENTRY COUNT PREFIX
3828   09E8 00 00 00 00 SND_TBL		.FILL	SND_SIZ,0	; SPACE FOR ENTRIES
3828   09EC 00 00 00 00 
3828   09F0 00 00 00 00 
3828   09F4 00 00 00 00 
3828   09F8 00 00 00 00 
3829   09FC             ;
3830   09FC             ;==================================================================================================
3831   09FC             ;   SPEAKER BEEP ROUTINE
3832   09FC             ;==================================================================================================
3833   09FC             ;
3834   09FC             ; ROUTINE TO BEEP THE DEFAULT SOUND UNIT
3835   09FC             ; NEED TO CHECK FOR EXISTENCE OF SOUND UNIT
3836   09FC             ; WHICH CHANNEL SHOULD BE USED?  IS THERE A GOOD DEFAULT CHANNEL?
3837   09FC             ;
3838   09FC             SND_BEEP:
3839   09FC             	; CHECK FOR AT LEAST 1 SOUND DEVICE
3840   09FC 3A E7 09    	LD	A,(SND_CNT)		; GET SOUND UNIT COUNT
3841   09FF B7          	OR	A			; CHECK FOR ZERO
3842   0A00 C8          	RET	Z			; BAIL OUT IF NO SOUND UNITS
3843   0A01             	
3844   0A01             	; PLAY A BEEP ON SOUND DEVICE UNIT 0
3845   0A01 06 50       	LD	B,$50			; SOUND RESET FUNCTION
3846   0A03 0E 00       	LD	C,0			; SOUND UNIT NUMBER
3847   0A05 CD D3 09    	CALL	SND_DISPATCH		; DO IT
3848   0A08 06 51       	LD	B,$51			; VOLUME
3849   0A0A 0E 00       	LD	C,0			; SOUND UNIT NUMBER
3850   0A0C 2E FF       	LD	L,$FF			; MAX
3851   0A0E CD D3 09    	CALL	SND_DISPATCH		; DO IT
3852   0A11 06 53       	LD	B,$53			; SELECT NOTE
3853   0A13 0E 00       	LD	C,0			; SOUND UNIT NUMBER
3854   0A15             	;LD	HL,0			; A0#
3855   0A15 21 F4 00    	LD	HL,244			; B5 (CLOSE TO 1 KHZ)
3856   0A18 CD D3 09    	CALL	SND_DISPATCH		; DO IT
3857   0A1B             	;LD	B,$56			; DURATION
3858   0A1B             	;LD	C,0			; SOUND UNIT NUMBER
3859   0A1B             	;LD	HL,500			; 1/2 SECOND
3860   0A1B             	;CALL	SND_DISPATCH		; DO IT
3861   0A1B 06 54       	LD	B,$54			; PLAY SOUND
3862   0A1D 0E 00       	LD	C,0			; SOUND UNIT NUMBER
3863   0A1F 16 00       	LD	D,0			; CHANNEL 0
3864   0A21 CD D3 09    	CALL	SND_DISPATCH		; DO IT
3865   0A24 11 09 3D    	LD	DE,15625		; PLAY FOR 1/4 SECOND
3866   0A27 CD 04 1B    	CALL	VDELAY			; WAIT WHILE TONE IS PLAYED
3867   0A2A             	;CALL	LDELAY			; LET SOUND PLAY 1/2 SECOND
3868   0A2A 06 50       	LD	B,$50			; SOUND RESET FUNCTION
3869   0A2C 0E 00       	LD	C,0			; SOUND UNIT NUMBER
3870   0A2E CD D3 09    	CALL	SND_DISPATCH		; DO IT
3871   0A31 C9          	RET				; DONE
3872   0A32             ;
3873   0A32             ;==================================================================================================
3874   0A32             ;   SYSTEM FUNCTION DISPATCHER
3875   0A32             ;==================================================================================================
3876   0A32             ;
3877   0A32             ;   B: FUNCTION
3878   0A32             ;
3879   0A32             SYS_DISPATCH:
3880   0A32 78          	LD	A,B			; GET REQUESTED FUNCTION
3881   0A33 E6 0F       	AND	$0F			; ISOLATE SUB-FUNCTION
3882   0A35 CA 69 0A    	JP	Z,SYS_RESET		; $F0
3883   0A38 3D          	DEC	A
3884   0A39 CA A7 0A    	JP	Z,SYS_VER		; $F1
3885   0A3C 3D          	DEC	A
3886   0A3D CA AE 0A    	JP	Z,SYS_SETBNK		; $F2
3887   0A40 3D          	DEC	A
3888   0A41 CA B8 0A    	JP	Z,SYS_GETBNK		; $F3
3889   0A44 3D          	DEC	A
3890   0A45 CA BE 0A    	JP	Z,SYS_SETCPY		; $F4
3891   0A48 3D          	DEC	A
3892   0A49 CA CB 0A    	JP	Z,SYS_BNKCPY		; $F5
3893   0A4C 3D          	DEC	A
3894   0A4D CA D6 0A    	JP	Z,SYS_ALLOC		; $F6
3895   0A50 3D          	DEC	A
3896   0A51 CA D9 0A    	JP	Z,SYS_FREE		; $F7
3897   0A54 3D          	DEC	A
3898   0A55 CA E0 0A    	JP	Z,SYS_GET		; $F8
3899   0A58 3D          	DEC	A
3900   0A59 CA DD 0B    	JP	Z,SYS_SET		; $F9
3901   0A5C 3D          	DEC	A
3902   0A5D CA 16 0C    	JP	Z,SYS_PEEK		; $FA
3903   0A60 3D          	DEC	A
3904   0A61 CA 24 0C    	JP	Z,SYS_POKE		; $FB
3905   0A64 3D          	DEC	A
3906   0A65 CA 32 0C    	JP	Z,SYS_INT		; $FC
3907   0A68 3D          	DEC	A
3908   0A69             ;
3909   0A69             ; RESTART SYSTEM
3910   0A69             ; SUBFUNCTION IN C
3911   0A69             ;
3912   0A69             SYS_RESET:
3913   0A69 79          	LD	A,C			; GET REQUESTED SUB-FUNCTION
3914   0A6A FE 00       	CP	BF_SYSRES_INT
3915   0A6C 28 13       	JR	Z,SYS_RESINT
3916   0A6E FE 01       	CP	BF_SYSRES_WARM
3917   0A70 28 17       	JR	Z,SYS_RESWARM
3918   0A72 FE 02       	CP	BF_SYSRES_COLD
3919   0A74 28 23       	JR	Z,SYS_RESCOLD
3920   0A76 FE 03       	CP	BF_SYSRES_USER
3921   0A78 28 2C       	JR	Z,SYS_RESUSER
3922   0A7A             	SYSCHKERR(ERR_NOFUNC)
3922   0A7A             
3922   0A7A CD 60 23    
3922   0A7D 3E FD       
3922   0A7F B7          
3923   0A80 C9          	RET
3924   0A81             ;
3925   0A81             ; SOFT RESET HBIOS, RELEASE HEAP MEMORY NOT USED BY HBIOS
3926   0A81             ;
3927   0A81             SYS_RESINT:
3928   0A81             ;
3929   0A81             	; RESET THE HEAP
3930   0A81 2A 5B 29    	LD	HL,(HEAPCURB)		; GET HBIOS HEAP THRESHOLD
3931   0A84 22 22 01    	LD	(CB_HEAPTOP),HL		; RESTORE HEAP TOP
3932   0A87             ;;
3933   0A87             ;	; MAKE SURE THE PROPER RESET VECTOR IS AT ADDRESS $0000
3934   0A87             ;	LD	HL,$0040		; USER RESET CODE STUB
3935   0A87             ;	LD	($0001),HL		; OPERAND OF JP AT $0000
3936   0A87             ;
3937   0A87 AF          	XOR	A
3938   0A88 C9          	RET
3939   0A89             ;
3940   0A89             ; GO BACK TO ROM BOOT LOADER
3941   0A89             ;
3942   0A89             SYS_RESWARM:
3943   0A89             ;
3944   0A89~            #IF (ROMSIZE == 0)
3945   0A89~            	JR	SYS_RESCOLD
3946   0A89             #ENDIF
3947   0A89             ;
3948   0A89 CD 81 0A    	CALL	SYS_RESINT
3949   0A8C             ;
3950   0A8C~            #IF (MEMMGR == MM_Z280)
3951   0A8C~            	JP	INITSYS4
3952   0A8C             #ELSE
3953   0A8C             	; PERFORM BANK CALL TO OS IMAGES BANK IN ROM
3954   0A8C 31 00 FE    	LD	SP,HBX_LOC		; STACK JUST BELOW HBIOS PROXY
3955   0A8F 3E 01       	LD	A,BID_IMG0		; CHAIN TO OS IMAGES BANK
3956   0A91 DD 21 00 00 	LD	IX,0			; ENTER AT ADDRESS 0
3957   0A95 CD 8E FE    	CALL	HBX_BNKCALL		; GO THERE
3958   0A98 76          	HALT				; WE SHOULD NEVER COME BACK!
3959   0A99             #ENDIF
3960   0A99             ;
3961   0A99             ; RESTART SYSTEM AS THOUGH POWER HAD JUST BEEN TURNED ON
3962   0A99             ;
3963   0A99             SYS_RESCOLD:
3964   0A99             ;
3965   0A99~            #IF (ROMSIZE == 0)
3966   0A99~            	LD	DE,STR_RESTART
3967   0A99~            	CALL	Z,WRITESTR
3968   0A99~            	DI
3969   0A99~            	HALT
3970   0A99             #ENDIF
3971   0A99             ;
3972   0A99~            #IF (MEMMGR == MM_Z280)
3973   0A99~            	JP	Z280_RESTART
3974   0A99             #ELSE
3975   0A99 F3          	DI
3976   0A9A 31 00 FE    	LD	SP,HBX_LOC		; STACK JUST BELOW HBIOS PROXY
3977   0A9D 3E 00       	LD	A,BID_BOOT		; BOOT BANK
3978   0A9F DD 21 00 00 	LD	IX,0			; ADDRESS ZERO
3979   0AA3 CD F9 FF    	CALL	HB_BNKCALL		; DOES NOT RETURN
3980   0AA6             #ENDIF
3981   0AA6             ;
3982   0AA6             ; HOOK CALLED WHEN A USERLAND RESET IS INVOKED, TYPICALLY VIA A JUMP
3983   0AA6             ; TO LOGICAL CPU ADDRESS $0000
3984   0AA6             ;
3985   0AA6             ; CREDIT TO PHILLIP STEVENS FOR SUGGESTING AND SIGNIFICANT CONTRIBUTIONS
3986   0AA6             ; TO THE Z180 INVALID OPCODE TRAP ENHANCEMENT.
3987   0AA6             ;
3988   0AA6             SYS_RESUSER:
3989   0AA6             ;
3990   0AA6~            #IF (CPUFAM == CPU_Z180)
3991   0AA6~            ;
3992   0AA6~            	IN0	A,(Z180_ITC)		; GET ITC REGISTER
3993   0AA6~            	XOR	$80			; PRECLEAR TRAP BIT
3994   0AA6~            	RET	M			; IF TRAP BIT NOT SET, DONE
3995   0AA6~            ;
3996   0AA6~            	; HANDLE INVALID OPCODE
3997   0AA6~            	DEC	HL			; BACK UP TO OPCODE START
3998   0AA6~            	BIT	6,A			; CHECK UFO BIT (2 BYTE OPCODE)
3999   0AA6~            	JR	Z,SYS_RESUSER1		; IF NOT, ALL SET
4000   0AA6~            	DEC	HL			; OTHERWISE, BACK UP 1 MORE BYTE
4001   0AA6~            ;
4002   0AA6~            SYS_RESUSER1:
4003   0AA6~            	OUT0	(Z180_ITC),A		; SAVE IT
4004   0AA6~            ;
4005   0AA6~            	CALL	PRTSTRD			; PRINT ERROR TAG
4006   0AA6~            	.TEXT	"\r\n\r\n+++ INVALID Z180 OPCODE @$"
4007   0AA6~            	CALL	PRTHEXWORDHL		; PRINT OPCODE ADDRESS
4008   0AA6~            	PRTS("H:$")			; FORMATTING
4008   0AA6~            	PRTS("H:$")			; FORMATTING
4009   0AA6~            ;
4010   0AA6~            	LD	B,8			; SHOW 8 BYTES
4011   0AA6~            SYS_RESUSER2:
4012   0AA6~            	PUSH	BC			; SAVE BC
4013   0AA6~            	PUSH	HL			; SAVE HL
4014   0AA6~            	LD	A,(HB_INVBNK)		; GET BYTE FROM INVOKING BANK
4015   0AA6~            	LD	D,A			; PUT IN D
4016   0AA6~            	CALL	SYS_PEEK		; PEEK TO GET BYTE VALUE
4017   0AA6~            	LD	A,E			; PUT IN A
4018   0AA6~            	CALL	PC_SPACE		; FORMATTING
4019   0AA6~            	CALL	PRTHEXBYTE		; DISPLAY BYTE
4020   0AA6~            	POP	HL			; RECOVER HL
4021   0AA6~            	POP	BC			; RECOVER BC
4022   0AA6~            	INC	HL			; NEXT BYTE
4023   0AA6~            	DJNZ	SYS_RESUSER2		; LOOP TIL DONE
4024   0AA6~            	JP	NEWLINE			; FORMATTING & EXIT
4025   0AA6~            ;
4026   0AA6             #ENDIF
4027   0AA6             ;
4028   0AA6 C9          	RET				; ELSE RETURN WITH USER RESET VECTOR IN HL
4029   0AA7             ;
4030   0AA7             ; GET THE CURRENT HBIOS VERSION
4031   0AA7             ;   ON INPUT, C=0
4032   0AA7             ;   RETURNS VERSION IN DE AS BCD
4033   0AA7             ;     D: MAJOR VERION IN TOP 4 BITS, MINOR VERSION IN LOW 4 BITS
4034   0AA7             ;     E: UPDATE VERION IN TOP 4 BITS, PATCH VERSION IN LOW 4 BITS
4035   0AA7             ;     L: PLATFORM ID
4036   0AA7             ;
4037   0AA7             SYS_VER:
4038   0AA7 11 10 32    	LD	DE,0 | (RMJ << 12) | (RMN << 8) | (RUP << 4) | RTP
4039   0AAA 2E 0F       	LD	L,PLATFORM
4040   0AAC AF          	XOR	A
4041   0AAD C9          	RET
4042   0AAE             ;
4043   0AAE             ; SET ACTIVE MEMORY BANK AND RETURN PREVIOUSLY ACTIVE MEMORY BANK
4044   0AAE             ;   NOTE THAT IT GOES INTO EFFECT AS HBIOS FUNCTION IS EXITED
4045   0AAE             ;   HERE, WE JUST SET THE CURRENT BANK
4046   0AAE             ;   CALLER MUST ESTABLISH UPPER MEMORY STACK BEFORE INVOKING THIS FUNCTION!
4047   0AAE             ;
4048   0AAE             SYS_SETBNK:
4049   0AAE~            #IF (MEMMGR == MM_Z280)
4050   0AAE~            	; FOR Z280 MEMMGR, WE ARE IN SYSTEM MODE HERE, SO WE CAN UPDATE
4051   0AAE~            	; THE USER MODE BANK WITHOUT IMPACTING THE RUNNING CODE.  IT
4052   0AAE~            	; TAKE EFFECT UPON RETURN TO USER MODE.
4053   0AAE~            	LD	A,(HB_INVBNK)		; GET PREVIOUS BANK
4054   0AAE~            	PUSH	AF			; SAVE IT
4055   0AAE~            	LD	A,C			; NEW BANK TO A
4056   0AAE~            	LD	(HB_INVBNK),A		; UPDATE INVBNK
4057   0AAE~            	LD	B,$00			; FIRST USER PDR
4058   0AAE~            	CALL	Z280_BNKSEL		; DO IT
4059   0AAE~            	POP	AF			; RECOVER PREV BANK
4060   0AAE~            	LD	C,A			; PREVIOUS BANK TO C
4061   0AAE~            	XOR	A			; SIGNAL SUCCESS
4062   0AAE~            	RET				; DONE
4063   0AAE             #ELSE
4064   0AAE E5          	PUSH	HL			; SAVE INCOMING HL
4065   0AAF 21 E1 FF    	LD	HL,HB_INVBNK		; POINT TO HBIOS INVOKE BANK ID ADDRESS
4066   0AB2 7E          	LD	A,(HL)			; GET EXISTING BANK ID TO A
4067   0AB3 71          	LD	(HL),C			; UPDATE INVOKE BANK TO NEW BANK ID
4068   0AB4 4F          	LD	C,A			; PUT PREVIOUS BANK ID IN C FOR RETURN
4069   0AB5 E1          	POP	HL			; RESTORE ORIGINAL HL
4070   0AB6 AF          	XOR	A			; SIGNAL SUCCESS
4071   0AB7 C9          	RET				; DONE
4072   0AB8             #ENDIF
4073   0AB8             ;
4074   0AB8             ; GET ACTIVE MEMORY BANK
4075   0AB8             ;
4076   0AB8             SYS_GETBNK:
4077   0AB8 3A E1 FF    	LD	A,(HB_INVBNK)		; GET THE ACTIVE MEMORY BANK
4078   0ABB 4F          	LD	C,A			; MOVE TO C
4079   0ABC AF          	XOR	A			; SIGNAL SUCCESS
4080   0ABD C9          	RET
4081   0ABE             ;
4082   0ABE             ; SET BANKS AND LENGTH FOR INTERBANK MEMORY COPY (BNKCPY)
4083   0ABE             ; ENTRY: E=SOURCE BANK ID
4084   0ABE             ;	 D=DEST BANK ID
4085   0ABE             ;	 HL=COPY LENGTH (IN BYTES)
4086   0ABE             ;
4087   0ABE             SYS_SETCPY:
4088   0ABE 7B          	LD	A,E
4089   0ABF 32 E4 FF    	LD	(HB_SRCBNK),A		; RECORD THE SOURCE BANK
4090   0AC2 7A          	LD	A,D
4091   0AC3 32 E7 FF    	LD	(HB_DSTBNK),A		; RECORD THE DESTINATION BANK
4092   0AC6 22 E8 FF    	LD	(HB_CPYLEN),HL		; RECORD THE COPY LENGTH
4093   0AC9 AF          	XOR	A
4094   0ACA C9          	RET
4095   0ACB             ;
4096   0ACB             ; PERFORM MEMORY COPY POTENTIALLY ACROSS BANKS
4097   0ACB             ; ENTRY: HL=SOURCE ADDRESS
4098   0ACB             ;	 DE=DESTINATION ADDRESS
4099   0ACB             ; NOTE: SRC/DEST BANK & COPY LENGTH MUST BE SET VIA SETCPY
4100   0ACB             ;
4101   0ACB             SYS_BNKCPY:
4102   0ACB E5          	PUSH	HL			; SAVE INCOMING HL
4103   0ACC 2A E8 FF    	LD	HL,(HB_CPYLEN)		; HL := COPY LEN (SAVED IN SETCPY)
4104   0ACF E3          	EX	(SP),HL			; RESTORE HL & SET (SP) TO COPY LEN
4105   0AD0 C1          	POP	BC			; BC := COPY LEN
4106   0AD1 CD F6 FF    	CALL	HB_BNKCPY
4107   0AD4 AF          	XOR	A
4108   0AD5 C9          	RET
4109   0AD6             ;
4110   0AD6             ; ALLOCATE HL BYTES OF MEMORY FROM HBIOS HEAP
4111   0AD6             ; RETURNS POINTER TO ALLOCATED MEMORY IN HL
4112   0AD6             ; ON SUCCESS RETURN A == 0, AND Z SET
4113   0AD6             ; ON FAILURE A <> 0 AND NZ SET AND HL TRASHED
4114   0AD6             ; ALL OTHER REGISTERS PRESERVED
4115   0AD6             ;
4116   0AD6             SYS_ALLOC:
4117   0AD6 C3 59 0D    	JP	HB_ALLOC
4118   0AD9             ;
4119   0AD9             ; FREE HEAP MEMORY BY SIMPLY RELEASING ALL
4120   0AD9             ; MEMORY BEYOND POINTER IN HL.
4121   0AD9             ; ON SUCCESS RETURN A == 0, AND Z SET
4122   0AD9             ; ON FAILURE A <> 0 AND NZ SET AND HL TRASHED
4123   0AD9             ; ALL OTHER REGISTERS PRESERVED
4124   0AD9             ;
4125   0AD9             SYS_FREE:
4126   0AD9             	SYSCHKERR(ERR_NOTIMPL)		; NOT YET IMPLEMENTED
4126   0AD9             
4126   0AD9 CD 60 23    
4126   0ADC 3E FE       
4126   0ADE B7          
4127   0ADF C9          	RET
4128   0AE0             ;
4129   0AE0             ; GET SYSTEM INFORMATION
4130   0AE0             ; ITEM TO RETURN INDICATED IN C
4131   0AE0             ;
4132   0AE0             SYS_GET:
4133   0AE0 79          	LD	A,C			; GET REQUESTED SUB-FUNCTION
4134   0AE1 FE 00       	CP	BF_SYSGET_CIOCNT
4135   0AE3 CA 89 0B    	JP	Z,SYS_GETCIOCNT
4136   0AE6 FE 01       	CP	BF_SYSGET_CIOFN
4137   0AE8 CA 8F 0B    	JP	Z,SYS_GETCIOFN
4138   0AEB FE 10       	CP	BF_SYSGET_DIOCNT
4139   0AED CA A0 0B    	JP	Z,SYS_GETDIOCNT
4140   0AF0 FE 11       	CP	BF_SYSGET_DIOFN
4141   0AF2 CA A6 0B    	JP	Z,SYS_GETDIOFN
4142   0AF5 FE 20       	CP	BF_SYSGET_RTCCNT
4143   0AF7 CA AD 0B    	JP	Z,SYS_GETRTCCNT
4144   0AFA FE 40       	CP	BF_SYSGET_VDACNT
4145   0AFC CA B8 0B    	JP	Z,SYS_GETVDACNT
4146   0AFF FE 41       	CP	BF_SYSGET_VDAFN
4147   0B01 CA BE 0B    	JP	Z,SYS_GETVDAFN
4148   0B04 FE 50       	CP	BF_SYSGET_SNDCNT
4149   0B06 CA C5 0B    	JP	Z, SYS_GETSNDCNT
4150   0B09 FE 51       	CP	BF_SYSGET_SNDFN
4151   0B0B CA CB 0B    	JP	Z,SYS_GETSNDFN
4152   0B0E FE D0       	CP	BF_SYSGET_TIMER
4153   0B10 CA 38 0B    	JP	Z,SYS_GETTIMER
4154   0B13 FE D1       	CP	BF_SYSGET_SECS
4155   0B15 CA 44 0B    	JP	Z,SYS_GETSECS
4156   0B18 FE E0       	CP	BF_SYSGET_BOOTINFO
4157   0B1A CA 56 0B    	JP	Z,SYS_GETBOOTINFO
4158   0B1D FE F0       	CP	BF_SYSGET_CPUINFO
4159   0B1F CA 60 0B    	JP	Z,SYS_GETCPUINFO
4160   0B22 FE F1       	CP	BF_SYSGET_MEMINFO
4161   0B24 CA 72 0B    	JP	Z,SYS_GETMEMINFO
4162   0B27 FE F2       	CP	BF_SYSGET_BNKINFO
4163   0B29 CA 7C 0B    	JP	Z,SYS_GETBNKINFO
4164   0B2C FE F3       	CP	BF_SYSGET_CPUSPD
4165   0B2E CA 86 0B    	JP	Z,SYS_GETCPUSPD
4166   0B31             	SYSCHKERR(ERR_NOFUNC)		; SIGNAL ERROR
4166   0B31             
4166   0B31 CD 60 23    
4166   0B34 3E FD       
4166   0B36 B7          
4167   0B37 C9          	RET
4168   0B38             ;
4169   0B38             ; GET TIMER
4170   0B38             ;   RETURNS:
4171   0B38             ;     DE:HL: TIMER VALUE (32 BIT)
4172   0B38             ;
4173   0B38             SYS_GETTIMER:
4174   0B38 21 5D 29    	LD	HL,HB_TICKS
4175   0B3B F3          	HB_DI
4176   0B3C CD AE 1C    	CALL	LD32
4177   0B3F FB          	HB_EI
4178   0B40 0E 32       	LD	C, TICKFREQ
4179   0B42 AF          	XOR	A
4180   0B43 C9          	RET
4181   0B44             ;
4182   0B44             ; GET SECONDS
4183   0B44             ;   RETURNS:
4184   0B44             ;     DE:HL: SECONDS VALUE (32 BIT)
4185   0B44             ;     C: NUM TICKS WITHIN CURRENT SECOND
4186   0B44             ;
4187   0B44             SYS_GETSECS:
4188   0B44 21 62 29    	LD	HL,HB_SECS
4189   0B47 F3          	HB_DI
4190   0B48 CD AE 1C    	CALL	LD32
4191   0B4B 3A 61 29    	LD	A,(HB_SECTCK)
4192   0B4E FB          	HB_EI
4193   0B4F ED 44       	NEG			; CONVERT DOWNCOUNTER TO UPCOUNTER
4194   0B51 C6 32       	ADD	A,TICKFREQ
4195   0B53 4F          	LD	C,A
4196   0B54 AF          	XOR	A
4197   0B55 C9          	RET
4198   0B56             ;
4199   0B56             ; GET BOOT INFORMATION
4200   0B56             ;   RETURNS:
4201   0B56             ;     L: BOOT BANK ID
4202   0B56             ;     DE: BOOT DISK VOLUME (UNIT/SLICE)
4203   0B56             ;
4204   0B56             SYS_GETBOOTINFO:
4205   0B56 3A 0F 01    	LD	A,(CB_BOOTBID)
4206   0B59 6F          	LD	L,A
4207   0B5A ED 5B 0D 01 	LD	DE,(CB_BOOTVOL)
4208   0B5E AF          	XOR	A
4209   0B5F C9          	RET
4210   0B60             ;
4211   0B60             ; GET CPU INFORMATION
4212   0B60             ;   RETURNS:
4213   0B60             ;     H: Z80 CPU VARIANT
4214   0B60             ;     L: CPU SPEED IN MHZ
4215   0B60             ;     DE: CPU SPEED IN KHZ
4216   0B60             ;
4217   0B60             SYS_GETCPUINFO:
4218   0B60 3A 66 29    	LD	A,(HB_CPUTYPE)
4219   0B63 67          	LD	H,A
4220   0B64 3A 08 01    	LD	A,(CB_CPUMHZ)
4221   0B67 6F          	LD	L,A
4222   0B68 ED 5B 09 01 	LD	DE,(CB_CPUKHZ)
4223   0B6C ED 4B 67 29 	LD	BC,(HB_CPUOSC)
4224   0B70 AF          	XOR	A
4225   0B71 C9          	RET
4226   0B72             ;
4227   0B72             ; GET MEMORY INFORMATION
4228   0B72             ;   RETURNS:
4229   0B72             ;     D: COUNT OF ROM BANKS
4230   0B72             ;     E: COUNT OF RAM BANKS
4231   0B72             ;
4232   0B72             SYS_GETMEMINFO:
4233   0B72 3A 0C 01    	LD	A,(CB_ROMBANKS)
4234   0B75 57          	LD	D,A
4235   0B76 3A 0B 01    	LD	A,(CB_RAMBANKS)
4236   0B79 5F          	LD	E,A
4237   0B7A AF          	XOR	A
4238   0B7B C9          	RET
4239   0B7C             ;
4240   0B7C             ; GET BANK CONFIGURATION INFORMATION
4241   0B7C             ;   RETURNS:
4242   0B7C             ;     D: HBIOS BANK ID
4243   0B7C             ;     E: USER BANK ID
4244   0B7C             ;
4245   0B7C             SYS_GETBNKINFO:
4246   0B7C 3A DA 01    	LD	A,(CB_BIDBIOS)
4247   0B7F 57          	LD	D,A
4248   0B80 3A D9 01    	LD	A,(CB_BIDUSR)
4249   0B83 5F          	LD	E,A
4250   0B84 AF          	XOR	A
4251   0B85 C9          	RET
4252   0B86             ;
4253   0B86             ; GET SYSTEM CPU SPEED PERFORMANCE ATTRIBUTES
4254   0B86             ;   RETURNS:
4255   0B86             ;     L: CLOCK MULT (0:HALF, 1:FULL, 2: DOUBLE)
4256   0B86             ;     D: MEMORY WAIT STATES
4257   0B86             ;     E: I/O WAIT STATES
4258   0B86             ;
4259   0B86             SYS_GETCPUSPD:
4260   0B86             ;
4261   0B86~            #IF (((PLATFORM == PLT_SBC) | (PLATFORM == PLT_MBC)) & (CPUSPDCAP==SPD_HILO))
4262   0B86~            	LD	A,(HB_RTCVAL)
4263   0B86~            #IF (PLATFORM == PLT_SBC)
4264   0B86~            	XOR	%00001000		; SBC SPEED BIT IS INVERTED
4265   0B86~            #ENDIF
4266   0B86~            	BIT	3,A
4267   0B86~            	LD	L,0			; ASSUME HALF SPEED
4268   0B86~            	JR	Z,SYS_GETCPUSPD1
4269   0B86~            	LD	L,1
4270   0B86~            SYS_GETCPUSPD1:
4271   0B86~            	LD	DE,$FFFF		; UNKNOWN WAIT STATES
4272   0B86~            ;
4273   0B86~            	XOR	A
4274   0B86~            	RET
4275   0B86             #ENDIF
4276   0B86             ;
4277   0B86~            #IF (CPUFAM == CPU_Z180)
4278   0B86~            	LD	HL,0			; INIT CPU SPEED TO HALF
4279   0B86~            	LD	A,(HB_CPUTYPE)		; LOAD CPUTYPE
4280   0B86~            	CP	2			; S-CLASS OR ABOVE?
4281   0B86~            	JR	C,SYS_GETCPUSPD1	; IF NOT, NO CCR/CMR
4282   0B86~            ;
4283   0B86~            	; GET CCR BIT
4284   0B86~            	IN0	A,(Z180_CCR)		; GET CLOCK CONTROL
4285   0B86~            	RLCA				; ROTATE BIT TO BIT 0
4286   0B86~            	AND	%00000001		; ISOLATE IT
4287   0B86~            	LD	L,A			; SAVE IN L
4288   0B86~            ;
4289   0B86~            	LD	A,(HB_CPUTYPE)		; LOAD CPUTYPE
4290   0B86~            	CP	3			; REV. N?
4291   0B86~            	JR	C,SYS_GETCPUSPD1	; IF NOT, NO CMR
4292   0B86~            ;
4293   0B86~            	; GET CMR BIT
4294   0B86~            	IN0	A,(Z180_CMR)		; GET CLOCK MULTIPLIER
4295   0B86~            	RLCA				; ROTATE BIT TO BIT 0
4296   0B86~            	AND	%00000001		; ISOLATE IT
4297   0B86~            	LD	H,A			; SAVE IN H
4298   0B86~            ;
4299   0B86~            SYS_GETCPUSPD1:
4300   0B86~            	; CALC FINAL MULTIPLIER TO L
4301   0B86~            	XOR	A			; CLEAR ACCUM
4302   0B86~            	ADD	A,H			; ADD IN CMR BIT
4303   0B86~            	ADD	A,L			; ADD IN CCR BIT
4304   0B86~            	LD	L,A			; SAVE RESULT IN L
4305   0B86~            	; DCNTL = MMII????
4306   0B86~            	IN0	A,(Z180_DCNTL)		; GET WAIT STATES
4307   0B86~            	RLCA				; ROTATE MEM WS BITS
4308   0B86~            	RLCA				; ... TO LOW BITS
4309   0B86~            	PUSH	AF			; SAVE FOR NOW
4310   0B86~            	AND	%00000011		; ISOLATE BITS
4311   0B86~            	LD	D,A			; PUT IN D
4312   0B86~            	POP	AF			; RECOVER A
4313   0B86~            	RLCA				; ROTATE I/O WS BITS
4314   0B86~            	RLCA				; ... TO LOW BITS
4315   0B86~            	AND	%00000011		; ISOLATE BITS
4316   0B86~            	INC	A			; ADD 1 FOR BUILT-IN WS
4317   0B86~            	LD	E,A			; PUT IN E
4318   0B86~            ;
4319   0B86~            	XOR	A
4320   0B86~            	RET
4321   0B86             #ENDIF
4322   0B86             ;
4323   0B86 F6 FF       	OR	$FF
4324   0B88 C9          	RET
4325   0B89             ;
4326   0B89             ; GET SERIAL UNIT COUNT
4327   0B89             ;
4328   0B89             SYS_GETCIOCNT:
4329   0B89 3A CD 07    	LD	A,(CIO_CNT)		; GET DEVICE COUNT (FIRST BYTE OF LIST)
4330   0B8C 5F          	LD	E,A			; PUT IT IN E
4331   0B8D AF          	XOR	A			; SIGNALS SUCCESS
4332   0B8E C9          	RET
4333   0B8F             ;
4334   0B8F             ; GET SERIAL UNIT API FN ADR AND DATA ADR
4335   0B8F             ;   ENTRY:
4336   0B8F             ;     D: FUNCTION
4337   0B8F             ;     E: UNIT
4338   0B8F             ;   RETURNS:
4339   0B8F             ;     HL: FUNCTION ADDRESS
4340   0B8F             ;     DE: DATA BLOB ADDRESS
4341   0B8F             ;
4342   0B8F             SYS_GETCIOFN:
4343   0B8F CB 7B       	BIT	7,E			; CHECK FOR SPECIAL UNIT CODE
4344   0B91 C4 9B 0B    	CALL	NZ,SYS_GETCIOFN1	; IF SO, HANDLE IT
4345   0B94 FD 21 CE 07 	LD	IY,CIO_TBL		; POINT TO UNIT TABLE
4346   0B98 C3 D2 0B    	JP	SYS_GETFN		; GO TO COMMON CODE
4347   0B9B             ;
4348   0B9B             SYS_GETCIOFN1:
4349   0B9B 3A 12 01    	LD	A,(CB_CONDEV)		; UNIT $80 -> CONSOLE UNIT
4350   0B9E 5F          	LD	E,A			; REPLACE UNIT VALUE IN C
4351   0B9F C9          	RET				; AND BACK TO REGULAR FLOW
4352   0BA0             ;
4353   0BA0             ;
4354   0BA0             ; GET DISK UNIT COUNT
4355   0BA0             ;
4356   0BA0             SYS_GETDIOCNT:
4357   0BA0 3A 62 08    	LD	A,(DIO_CNT)		; GET DEVICE COUNT (FIRST BYTE OF LIST)
4358   0BA3 5F          	LD	E,A			; PUT IT IN E
4359   0BA4 AF          	XOR	A			; SIGNALS SUCCESS
4360   0BA5 C9          	RET
4361   0BA6             ;
4362   0BA6             ; GET DISK UNIT API FN ADR AND DATA ADR
4363   0BA6             ;   ENTRY:
4364   0BA6             ;     D: FUNCTION
4365   0BA6             ;     E: UNIT
4366   0BA6             ;   RETURNS:
4367   0BA6             ;     HL: FUNCTION ADDRESS
4368   0BA6             ;     DE: DATA BLOB ADDRESS
4369   0BA6             ;
4370   0BA6             SYS_GETDIOFN:
4371   0BA6 FD 21 63 08 	LD	IY,DIO_TBL		; POINT TO UNIT TABLE
4372   0BAA C3 D2 0B    	JP	SYS_GETFN		; GO TO COMMON CODE
4373   0BAD             ;
4374   0BAD             ; GET RTC UNIT COUNT
4375   0BAD             ;
4376   0BAD             SYS_GETRTCCNT:
4377   0BAD 1E 00       	LD	E,0			; ASSUME 0 RTC DEVICES
4378   0BAF 3A 7D 09    	LD	A,(RTC_DISPACT)		; IS RTC ACTIVE?
4379   0BB2 B7          	OR	A			; SET FLAGS
4380   0BB3 28 01       	JR	Z,SYS_GETRTCCNT1	; IF NONE, DONE
4381   0BB5 1C          	INC	E			; SET ONE DEVICE
4382   0BB6             SYS_GETRTCCNT1:
4383   0BB6 AF          	XOR	A			; SIGNALS SUCCESS
4384   0BB7 C9          	RET
4385   0BB8             ;
4386   0BB8             ; GET VIDEO UNIT COUNT
4387   0BB8             ;
4388   0BB8             SYS_GETVDACNT:
4389   0BB8 3A 92 09    	LD	A,(VDA_CNT)		; GET DEVICE COUNT (FIRST BYTE OF LIST)
4390   0BBB 5F          	LD	E,A			; PUT IT IN E
4391   0BBC AF          	XOR	A			; SIGNALS SUCCESS
4392   0BBD C9          	RET
4393   0BBE             ;
4394   0BBE             ; GET VIDEO UNIT API FN ADR AND DATA ADR
4395   0BBE             ;   ENTRY:
4396   0BBE             ;     D: FUNCTION
4397   0BBE             ;     E: UNIT
4398   0BBE             ;   RETURNS:
4399   0BBE             ;     HL: FUNCTION ADDRESS
4400   0BBE             ;     DE: DATA BLOB ADDRESS
4401   0BBE             ;
4402   0BBE             SYS_GETVDAFN:
4403   0BBE FD 21 93 09 	LD	IY,VDA_TBL		; POINT TO UNIT TABLE
4404   0BC2 C3 D2 0B    	JP	SYS_GETFN		; GO TO COMMON CODE
4405   0BC5             ;
4406   0BC5             ; GET SOUND UNIT COUNT
4407   0BC5             ;
4408   0BC5             SYS_GETSNDCNT:
4409   0BC5 3A E7 09    	LD	A,(SND_CNT)		; GET DEVICE COUNT (FIRST BYTE OF LIST)
4410   0BC8 5F          	LD	E,A			; PUT IT IN E
4411   0BC9 AF          	XOR	A			; SIGNALS SUCCESS
4412   0BCA C9          	RET
4413   0BCB             ;
4414   0BCB             ; GET SOUND UNIT API FN ADR AND DATA ADR
4415   0BCB             ;   ENTRY:
4416   0BCB             ;     D: FUNCTION
4417   0BCB             ;     E: UNIT
4418   0BCB             ;   RETURNS:
4419   0BCB             ;     HL: FUNCTION ADDRESS
4420   0BCB             ;     DE: DATA BLOB ADDRESS
4421   0BCB             ;
4422   0BCB             SYS_GETSNDFN:
4423   0BCB FD 21 E8 09 	LD	IY,SND_TBL		; POINT TO UNIT TABLE
4424   0BCF C3 D2 0B    	JP	SYS_GETFN		; GO TO COMMON CODE
4425   0BD2             ;
4426   0BD2             ; SHARED CODE TO COMPLETE A FUNCTION LOOKUP
4427   0BD2             ; ENTRY:
4428   0BD2             ;   IY: DISPATCH FUNCTION TABLE
4429   0BD2             ;   D: FUNCTION ID
4430   0BD2             ;   E: UNIT NUMBER
4431   0BD2             ; EXIT:
4432   0BD2             ;   HL: DRIVER FUNCTION ADDRESS
4433   0BD2             ;   DE: DRIVER UNIT DATA ADDRESS
4434   0BD2             ;
4435   0BD2             SYS_GETFN:
4436   0BD2 7A          	LD	A,D			; GET FUNC NUM FROM D
4437   0BD3 47          	LD	B,A			; AND PUT IN B
4438   0BD4 7B          	LD	A,E			; GET UNIT NUM FROM E
4439   0BD5 4F          	LD	C,A			; AND PUT IN C
4440   0BD6 CD FF 0C    	CALL	HB_DISPCALC		; CALC FN ADR & BLOB ADR
4441   0BD9 FD E5       	PUSH	IY			; MOVE DATA ADR
4442   0BDB D1          	POP	DE			; ... TO DE
4443   0BDC C9          	RET				; AF STILL HAS RESULT OF CALC
4444   0BDD             ;
4445   0BDD             ; SET SYSTEM PARAMETERS
4446   0BDD             ; PARAMETER(S) TO SET INDICATED IN C
4447   0BDD             ;
4448   0BDD             SYS_SET:
4449   0BDD 79          	LD	A,C			; GET REQUESTED SUB-FUNCTION
4450   0BDE FE D0       	CP	BF_SYSSET_TIMER
4451   0BE0 28 1D       	JR	Z,SYS_SETTIMER
4452   0BE2 FE D1       	CP	BF_SYSSET_SECS
4453   0BE4 28 23       	JR	Z,SYS_SETSECS
4454   0BE6 FE E0       	CP	BF_SYSSET_BOOTINFO
4455   0BE8 28 0B       	JR	Z,SYS_SETBOOTINFO
4456   0BEA FE F3       	CP	BF_SYSSET_CPUSPD
4457   0BEC 28 25       	JR	Z,SYS_SETCPUSPD
4458   0BEE             	SYSCHKERR(ERR_NOFUNC)		; SIGNAL ERROR
4458   0BEE             
4458   0BEE CD 60 23    
4458   0BF1 3E FD       
4458   0BF3 B7          
4459   0BF4 C9          	RET
4460   0BF5             ;
4461   0BF5             ; SET BOOT INFORMATION
4462   0BF5             ;   ON ENTRY:
4463   0BF5             ;     L: BOOT BANK ID
4464   0BF5             ;     DE: BOOT DISK VOLUME (UNIT/SLICE)
4465   0BF5             ;
4466   0BF5             SYS_SETBOOTINFO:
4467   0BF5 7D          	LD	A,L
4468   0BF6 32 0F 01    	LD	(CB_BOOTBID),A
4469   0BF9 ED 53 0D 01 	LD	(CB_BOOTVOL),DE
4470   0BFD AF          	XOR	A
4471   0BFE C9          	RET
4472   0BFF             ;
4473   0BFF             ; SET TIMER
4474   0BFF             ;   ON ENTRY:
4475   0BFF             ;     DE:HL: TIMER VALUE (32 BIT)
4476   0BFF             ;
4477   0BFF             SYS_SETTIMER:
4478   0BFF 01 5D 29    	LD	BC,HB_TICKS
4479   0C02 F3          	HB_DI
4480   0C03 CD BA 1C    	CALL	ST32
4481   0C06 FB          	HB_EI
4482   0C07 AF          	XOR	A
4483   0C08 C9          	RET
4484   0C09             ;
4485   0C09             ; SET SECS
4486   0C09             ;   ON ENTRY:
4487   0C09             ;     DE:HL: SECONDS VALUE (32 BIT)
4488   0C09             ;
4489   0C09             SYS_SETSECS:
4490   0C09 01 62 29    	LD	BC,HB_SECS
4491   0C0C F3          	HB_DI
4492   0C0D CD BA 1C    	CALL	ST32
4493   0C10 FB          	HB_EI
4494   0C11 AF          	XOR	A
4495   0C12 C9          	RET
4496   0C13             ;
4497   0C13             ; SET SYSTEM CPU SPEED ATTRIBUTES
4498   0C13             ;   ON ENTRY:
4499   0C13             ;     L: CLOCK MULT (0:HALF, 1:FULL, 2: DOUBLE)
4500   0C13             ;     D: MEMORY WAIT STATES
4501   0C13             ;     E: I/O WAIT STATES
4502   0C13             ;
4503   0C13             SYS_SETCPUSPD:
4504   0C13             ;
4505   0C13~            #IF (((PLATFORM == PLT_SBC) | (PLATFORM == PLT_MBC)) & (CPUSPDCAP==SPD_HILO))
4506   0C13~            ;
4507   0C13~            ; NOTE: WAIT STATE SETTINGS ARE IGNORED FOR Z80
4508   0C13~            ;
4509   0C13~            	LD	A,L			; CLK SPD TO ACCUM
4510   0C13~            	CP	$FF			; NO CHANGE?
4511   0C13~            	JR	Z,SYS_SETCPUSPD3	; DONE IF SO
4512   0C13~            	LD	C,%00000000		; HALF SPEED
4513   0C13~            	CP	0
4514   0C13~            	JR	Z,SYS_SETCPUSPD1
4515   0C13~            	LD	C,%00001000		; FULL SPEED
4516   0C13~            	CP	1
4517   0C13~            	JR	Z,SYS_SETCPUSPD1
4518   0C13~            	JR	SYS_SETCPUSPD_ERR	; SPD NOT SUPPORTED
4519   0C13~            SYS_SETCPUSPD1:
4520   0C13~            	LD	A,(HB_RTCVAL)
4521   0C13~            	AND	~%00001000		; CLEAR SPEED BIT
4522   0C13~            	OR	C			; IMPLEMENT NEW SPEED BIT
4523   0C13~            #IF (PLATFORM == PLT_SBC)
4524   0C13~            	; SBC SPEED BIT IS INVERTED, ADJUST IT
4525   0C13~            	LD	A,C
4526   0C13~            	XOR	%00001000
4527   0C13~            	LD	C,A
4528   0C13~            #ENDIF
4529   0C13~            	LD	(HB_RTCVAL),A		; SAVE IN SHADOW REGISTER
4530   0C13~            	OUT	(RTCIO),A		; UPDATE HARDWARE REGISTER
4531   0C13~            ;
4532   0C13~            	; UPDATE THE CURRENT CPU SPEED IN HCB!
4533   0C13~            	LD	A,L
4534   0C13~            	LD	HL,(HB_CPUOSC)		; ASSUME FULL SPEED
4535   0C13~            	CP	1			; CHECK FOR 1 (FULL SPEED)
4536   0C13~            	JR	Z,SYS_SETCPUSPD2	; IF SO, ALL DONE
4537   0C13~            	; ADJUST HL TO REFLECT HALF SPEED OPERATION
4538   0C13~            	SRL	H		; ADJUST HL ASSUMING
4539   0C13~            	RR	L		; HALF SPEED OPERATION
4540   0C13~            ;
4541   0C13~            SYS_SETCPUSPD2:
4542   0C13~            ;
4543   0C13~            ; HL SHOULD NOW HAVE FINAL CPU RUNNING SPEED IN KHZ.
4544   0C13~            ; UPDATE CB_CPUMHZ/CB_CPUKHZ WITH THIS VALUE.
4545   0C13~            ;
4546   0C13~            	LD	(CB_CPUKHZ),HL		; UPDATE CPUKHZ
4547   0C13~            	LD	DE,1000			; SET UP TO DIV BY 1000 FOR MHZ
4548   0C13~            	CALL	DIV16			; BC=CPU MHZ, HL=REMAINDER
4549   0C13~            	LD	DE,500			; SET UP TO ROUND UP
4550   0C13~            	XOR	A			; IF WITHIN 500 KHZ
4551   0C13~            	SBC	HL,DE			; REMAINDER - 500
4552   0C13~            	CCF				; COMPLEMENT CF
4553   0C13~            	ADC	A,C			; C -> A; ADD CF FOR ROUNDING
4554   0C13~            	LD	(CB_CPUMHZ),A		; SAVE IT
4555   0C13~            ;
4556   0C13~            	;  REINIT DELAY ROUTINE
4557   0C13~            	LD	A,(CB_CPUMHZ)		; CPU SPEED TO ACCUM AND INIT
4558   0C13~            	CALL	DELAY_INIT		; .. SPEED COMPENSATED DELAY
4559   0C13~            ;
4560   0C13~            SYS_SETCPUSPD3:
4561   0C13~            	XOR	A
4562   0C13~            	RET
4563   0C13             #ENDIF
4564   0C13             ;
4565   0C13~            #IF (CPUFAM == CPU_Z180)
4566   0C13~            	; VERIFY THAT REQUESTED SETTINGS ARE ALLOWED BY HARDWARE
4567   0C13~            	LD	A,L			; GET SPEED REQUESTED
4568   0C13~            	CP	$FF			; NO CHANGE?
4569   0C13~            	JR	Z,SYS_SETCPUSPD0A	; SKIP CHECK
4570   0C13~            	LD	A,(HB_CPUTYPE)		; 1=ORIG, 2=REVK, 3=REVN
4571   0C13~            	INC	L			; 1=HALF,2=FULL,3=DOUBLE
4572   0C13~            	CP	L			; TOO HIGH FOR CPU TYPE?
4573   0C13~            	JP	C,SYS_SETCPUSPD_ERR	; CPU CAN'T DO SPD MULT
4574   0C13~            	DEC	L			; RESTORE ORIG REQUEST
4575   0C13~            SYS_SETCPUSPD0A:
4576   0C13~            	LD	A,D			; MEM WS
4577   0C13~            	CP	$FF			; NO CHANGE?
4578   0C13~            	JR	Z,SYS_SETCPUSPD0B	; SKIP CHECK
4579   0C13~            	CP	4			; TOO HIGH?
4580   0C13~            	JP	NC,SYS_SETCPUSPD_ERR	; >3 IS TOO HIGH
4581   0C13~            SYS_SETCPUSPD0B:
4582   0C13~            	LD	A,D			; I/O WS
4583   0C13~            	CP	$FF			; NO CHANGE?
4584   0C13~            	JR	Z,SYS_SETCPUSPD0C	; SKIP CHECK
4585   0C13~            	CP	4			; TOO HIGH?
4586   0C13~            	JP	NC,SYS_SETCPUSPD_ERR	; >3 IS TOO HIGH
4587   0C13~            SYS_SETCPUSPD0C:
4588   0C13~            ;
4589   0C13~            	PUSH	DE			; SAVE WAIT STATES FOR NOW
4590   0C13~            	; BEFORE IMPLEMENTING THE NEW CPU SPEED, WE SWITCH THE
4591   0C13~            	; WAIT STATES TO MAXIMUM BECAUSE WE MAY BE IMPLEMENTING
4592   0C13~            	; SLOWER WAIT STATES REQUIRED BY THE NEW SPEED.  WE SAVE
4593   0C13~            	; THE ORIGINAL WAIT STATES REGISTER VALUE ON STACK
4594   0C13~            	IN0	A,(Z180_DCNTL)		; GET CURRENT REGISTER VALUE
4595   0C13~            	LD	E,A			; PUT IN E
4596   0C13~            	PUSH	DE			; SAVE FOR LATER
4597   0C13~            	OR	%11110000		; MAX WAIT STATES
4598   0C13~            	OUT0	(Z180_DCNTL),A		; DO IT
4599   0C13~            ;
4600   0C13~            	LD	A,L			; NEW CLK SPD TO ACCUM
4601   0C13~            	CP	$FF			; NO CHANGE?
4602   0C13~            	JR	Z,SYS_SETCPUSPD2B	; IF SO, SKIP TO WAIT STATES
4603   0C13~            ;
4604   0C13~            	LD	B,0			; B HAS BIT FOR CMR
4605   0C13~            	LD	C,0			; C HAS BIT FOR CCR
4606   0C13~            	CP	2			; DOUBLE SPEED?
4607   0C13~            	JR	C,SYS_SETCPUSPD1	; <2?, SKIP AHEAD
4608   0C13~            	LD	B,%10000000		; SET CMR BIT
4609   0C13~            SYS_SETCPUSPD1:
4610   0C13~            	CP	1			; FULL SPEED?
4611   0C13~            	JR	C,SYS_SETCPUSPD2	; <1?, SKIP AHEAD
4612   0C13~            	LD	C,%10000000		; SET CCR BIT
4613   0C13~            SYS_SETCPUSPD2:
4614   0C13~            ;
4615   0C13~            	; IMPLEMENT THE NEW CPU SPEED
4616   0C13~            	IN0	A,(Z180_CMR)
4617   0C13~            	AND	~%10000000
4618   0C13~            	OR	B
4619   0C13~            	OUT0	(Z180_CMR),A
4620   0C13~            	IN0	A,(Z180_CCR)
4621   0C13~            	AND	~%10000000
4622   0C13~            	OR	C
4623   0C13~            	OUT0	(Z180_CCR),A
4624   0C13~            ;
4625   0C13~            	; UPDATE THE CURRENT CPU SPEED IN HCB!
4626   0C13~            	LD	A,L			; SETTING TO A
4627   0C13~            	LD	HL,(HB_CPUOSC)		; START WITH CPU OSC VALUE
4628   0C13~            	; ADJUST HL TO REFLECT HALF SPEED OPERATION
4629   0C13~            	SRL	H			; ADJUST HL ASSUMING
4630   0C13~            	RR	L			; HALF SPEED OPERATION
4631   0C13~            	OR	A			; CHECK FOR HALF SPEED
4632   0C13~            	JR	Z,SETCPUSPD2A		; IF SO, DONE
4633   0C13~            	; ADJUST HL TO REFLECT FULL SPEED OPERATION
4634   0C13~            	SLA	L
4635   0C13~            	RL	H
4636   0C13~            	CP	1			; CHECK FOR FULL SPEED
4637   0C13~            	JR	Z,SETCPUSPD2A		; IF SO DONE
4638   0C13~            	; ADJUST HL TO REFLECT DOUBLE SPEED OPERATION
4639   0C13~            	SLA	L
4640   0C13~            	RL	H
4641   0C13~            ;
4642   0C13~            SETCPUSPD2A:
4643   0C13~            ;
4644   0C13~            ; HL SHOULD NOW HAVE FINAL CPU RUNNING SPEED IN KHZ.
4645   0C13~            ; UPDATE CB_CPUMHZ/CB_CPUKHZ WITH THIS VALUE.
4646   0C13~            ;
4647   0C13~            	LD	(CB_CPUKHZ),HL		; UPDATE CPUKHZ
4648   0C13~            	LD	DE,1000			; SET UP TO DIV BY 1000 FOR MHZ
4649   0C13~            	CALL	DIV16			; BC=CPU MHZ, HL=REMAINDER
4650   0C13~            	LD	DE,500			; SET UP TO ROUND UP
4651   0C13~            	XOR	A			; IF WITHIN 500 KHZ
4652   0C13~            	SBC	HL,DE			; REMAINDER - 500
4653   0C13~            	CCF				; COMPLEMENT CF
4654   0C13~            	ADC	A,C			; C -> A; ADD CF FOR ROUNDING
4655   0C13~            	LD	(CB_CPUMHZ),A		; SAVE IT
4656   0C13~            ;
4657   0C13~            SYS_SETCPUSPD2B:
4658   0C13~            	; NOW IMPLEMENT ANY WAIT STATE CHANGES.
4659   0C13~            	POP	HL			; INIT L WITH ORIG DCNTL VALUE
4660   0C13~            	POP	DE			; RECOVER WAIT STATES
4661   0C13~            	LD	A,D			; GET MEM WS
4662   0C13~            	CP	$FF			; SKIP?
4663   0C13~            	JR	Z,SYS_SETCPUSPD3	; IF SO, GO AHEAD
4664   0C13~            	AND	%00000011		; JUST TWO BITS
4665   0C13~            	RRCA				; MEM WS IS TOP TWO BITS
4666   0C13~            	RRCA
4667   0C13~            	LD	H,A			; MOVE WS BITS TO H
4668   0C13~            	LD	A,L			; CUR VALUE TO A
4669   0C13~            	AND	%00111111		; MASK OFF MEM WS BITS
4670   0C13~            	OR	H			; SET NEW MEM WS BITS
4671   0C13~            	LD	L,A			; BACK TO L
4672   0C13~            ;
4673   0C13~            SYS_SETCPUSPD3:
4674   0C13~            ;
4675   0C13~            	LD	A,E			; GET I/O WS
4676   0C13~            	CP	$FF			; SKIP?
4677   0C13~            	JR	Z,SYS_SETCPUSPD4	; IF SO, GO AHEAD
4678   0C13~            	DEC	A			; ADJUST FOR BUILT-IN I/O WS
4679   0C13~            	AND	%00000011		; JUST TWO BITS
4680   0C13~            	RRCA				; I/O WS IS BITS 5-4
4681   0C13~            	RRCA
4682   0C13~            	RRCA
4683   0C13~            	RRCA
4684   0C13~            	LD	H,A			; MOVE WS BITS TO H
4685   0C13~            	LD	A,L			; CUR VALUE TO A
4686   0C13~            	AND	%11001111		; MASK OFF I/O WS BITS
4687   0C13~            	OR	H			; SET NEW I/O WS BITS
4688   0C13~            	LD	L,A			; BACK TO L
4689   0C13~            ;
4690   0C13~            SYS_SETCPUSPD4:
4691   0C13~            	LD	A,L			; WORKING VALUE TO A
4692   0C13~            	OUT0	(Z180_DCNTL),A		; IMPLEMENT NEW VALUE
4693   0C13~            ;
4694   0C13~            	;  REINIT DELAY ROUTINE
4695   0C13~            	LD	A,(CB_CPUMHZ)		; CPU SPEED TO ACCUM AND INIT
4696   0C13~            	CALL	DELAY_INIT		; .. SPEED COMPENSATED DELAY
4697   0C13~            ;
4698   0C13~              #IF ((INTMODE == 2) & (Z180_TIMER))
4699   0C13~            	; THE Z180 TIMER IS BASED ON CPU SPEED.  SO HERE
4700   0C13~            	; WE RECOMPUTE THE TIMER CONSTANTS BASED ON THE NEW SPEED.
4701   0C13~            	XOR	A			; ALL BITS ZERO
4702   0C13~            	OUT0	(Z180_TCR),A		; ... INHIBITS TIMER OPERATION
4703   0C13~            	LD	HL,(CB_CPUKHZ)		; 50HZ = 18432000 / 20 / 50 / X, SO X = CPU KHZ
4704   0C13~            	OUT0	(Z180_TMDR0L),L		; INITIALIZE TIMER 0 DATA REGISTER
4705   0C13~            	OUT0	(Z180_TMDR0H),H
4706   0C13~            	DEC	HL			; RELOAD OCCURS *AFTER* ZERO
4707   0C13~            	OUT0	(Z180_RLDR0L),L		; INITIALIZE TIMER 0 RELOAD REGISTER
4708   0C13~            	OUT0	(Z180_RLDR0H),H
4709   0C13~            	LD	A,%00010001		; ENABLE TIMER0 INT AND DOWN COUNTING
4710   0C13~            	OUT0	(Z180_TCR),A
4711   0C13~              #ENDIF
4712   0C13~            ;
4713   0C13~              #IF (ASCIENABLE)
4714   0C13~            	; RESET THE ASCI PORTS IN CASE SPEED CHANGED!
4715   0C13~            	; N.B., THIS WILL FAIL IF THE CURRENT BAUD RATE
4716   0C13~            	; IS IMPOSSIBLE TO IMPLEMENT AT THE NEW CPU SPEED!!!
4717   0C13~            	LD	DE,-1
4718   0C13~            	LD	IY,ASCI0_CFG
4719   0C13~            	CALL	ASCI_INITDEV
4720   0C13~            	LD	DE,-1
4721   0C13~            	LD	IY,ASCI1_CFG
4722   0C13~            	CALL	ASCI_INITDEV
4723   0C13~              #ENDIF
4724   0C13~            ;
4725   0C13~            	XOR	A
4726   0C13~            	RET
4727   0C13             #ENDIF
4728   0C13             ;
4729   0C13             SYS_SETCPUSPD_ERR:
4730   0C13 F6 FF       	OR	$FF			; NOT SUPPORTED
4731   0C15 C9          	RET
4732   0C16             ;
4733   0C16             ; RETURN A BYTE OF MEMORY FROM SPECIFIED BANK
4734   0C16             ; ENTRY: D=BANK ID, HL=ADDRESS
4735   0C16             ; RETURN: E=BYTE VALUE
4736   0C16             ;
4737   0C16             ; IF WE ARE USING INTERRUPT MODE 1, WE NEED TO PREVENT INTERRUPTS
4738   0C16             ; BECAUSE THE LOW MEMORY BANK CONTAINING THE IM1 VECTOR WILL PROBABLY
4739   0C16             ; GET BANKED OUT DURING THE PEEK PROCESSING.
4740   0C16             ;
4741   0C16             SYS_PEEK:
4742   0C16             #IF (INTMODE == 1)
4743   0C16~              #IF (CPUFAM == CPU_Z280)
4744   0C16~            	PUSH	IY
4745   0C16~            	LD	C,Z280_MSR
4746   0C16~            	LDCTL	IY,(C)
4747   0C16~            	PUSH	IY
4748   0C16~            	HB_DI
4749   0C16               #ELSE
4750   0C16 ED 57       	LD	A,I			; SAVE THE INTERRUPT STATUS
4751   0C18 F3          	DI         			;  COPY IFF2 TO P/V FLAG
4752   0C19 F5          	PUSH	AF
4753   0C1A               #ENDIF
4754   0C1A             #ENDIF
4755   0C1A CD AA FE    	CALL	HBX_PEEK		; IMPLEMENTED IN PROXY
4756   0C1D             #IF (INTMODE == 1)
4757   0C1D~              #IF (CPUFAM == CPU_Z280)
4758   0C1D~            	LD	C,Z280_MSR
4759   0C1D~            	POP	IY
4760   0C1D~            	LDCTL	(C),IY
4761   0C1D~            	POP	IY
4762   0C1D               #ELSE
4763   0C1D F1          	POP	AF			; RECALL INITIAL INTERRUPT STATUS
4764   0C1E E2 22 0C    	JP	PO,$+4			; RETURN TO INITIAL STATE
4765   0C21 FB          	EI				; *** DO NOT USE HB_EI HERE ***
4766   0C22               #ENDIF
4767   0C22             #ENDIF
4768   0C22 AF          	XOR	A
4769   0C23 C9          	RET
4770   0C24             ;
4771   0C24             ; WRITE A BYTE OF MEMORY TO SPECIFIED BANK
4772   0C24             ; ENTRY: D=BANK ID, HL=ADDRESS IN HBIOS BANK, E=BYTE VALUE
4773   0C24             ;
4774   0C24             ; IF WE ARE USING INTERRUPT MODE 1, WE NEED TO PREVENT INTERRUPTS
4775   0C24             ; BECAUSE THE LOW MEMORY BANK CONTAINING THE IM1 VECTOR WILL PROBABLY
4776   0C24             ; GET BANKED OUT DURING THE POKE PROCESSING.
4777   0C24             ;
4778   0C24             SYS_POKE:
4779   0C24             #IF (INTMODE == 1)
4780   0C24~              #IF (CPUFAM == CPU_Z280)
4781   0C24~            	PUSH	IY
4782   0C24~            	LD	C,Z280_MSR
4783   0C24~            	LDCTL	IY,(C)
4784   0C24~            	PUSH	IY
4785   0C24~            	HB_DI
4786   0C24               #ELSE
4787   0C24 ED 57       	LD	A,I			; SAVE THE INTERRUPT STATUS
4788   0C26 F3          	HB_DI      			;  COPY IFF2 TO P/V FLAG
4789   0C27 F5          	PUSH	AF
4790   0C28               #ENDIF
4791   0C28             #ENDIF
4792   0C28 CD BC FE    	CALL	HBX_POKE		; IMPLEMENTED IN PROXY
4793   0C2B             #IF (INTMODE == 1)
4794   0C2B~              #IF (CPUFAM == CPU_Z280)
4795   0C2B~            	LD	C,Z280_MSR
4796   0C2B~            	POP	IY
4797   0C2B~            	LDCTL	(C),IY
4798   0C2B~            	POP	IY
4799   0C2B               #ELSE
4800   0C2B F1          	POP	AF			; RECALL INITIAL INTERRUPT STATUS
4801   0C2C E2 30 0C    	JP	PO,$+4			; RETURN TO INITIAL STATE
4802   0C2F FB          	EI				; *** DO NOT USE HB_EI HERE ***
4803   0C30               #ENDIF
4804   0C30             #ENDIF
4805   0C30 AF          	XOR	A
4806   0C31 C9          	RET
4807   0C32             ;
4808   0C32             ; INTERRUPT MANAGEMENT FUNCTIONS
4809   0C32             ; SUBFUNCTION IN C
4810   0C32             ;
4811   0C32             SYS_INT:
4812   0C32 79          	LD	A,C			; GET REQUESTED SUB-FUNCTION
4813   0C33 FE 00       	CP	BF_SYSINT_INFO
4814   0C35 28 0F       	JR	Z,SYS_INTINFO
4815   0C37 FE 10       	CP	BF_SYSINT_GET
4816   0C39 28 30       	JR	Z,SYS_INTGET
4817   0C3B FE 20       	CP	BF_SYSINT_SET
4818   0C3D 28 36       	JR	Z,SYS_INTSET
4819   0C3F             	SYSCHKERR(ERR_NOFUNC)		; SIGNAL ERROR
4819   0C3F             
4819   0C3F CD 60 23    
4819   0C42 3E FD       
4819   0C44 B7          
4820   0C45 C9          	RET
4821   0C46             ;
4822   0C46             ; GET INTERRUPT SYSTEM INFORMATION
4823   0C46             ; RETURN D:=INTERRUPT MODE, E:=INT VEC TABLE SIZE
4824   0C46             ;
4825   0C46             SYS_INTINFO:
4826   0C46 16 01       	LD	D,INTMODE		; D := ACTIVE INTERRUPT MODE
4827   0C48~            #IF (INTMODE == 0)
4828   0C48~            	LD	E,0			; 0 ENTRIES IF INTERRUPTS DISABLED
4829   0C48             #ENDIF
4830   0C48             #IF (INTMODE == 1)
4831   0C48 3A AA 0C    	LD	A,(HB_IM1CNT)		; RETURN IM1 CALL LIST SIZE
4832   0C4B 5F          	LD	E,A
4833   0C4C             #ENDIF
4834   0C4C~            #IF (INTMODE == 2)
4835   0C4C~            	LD	E,HBX_IVTCNT		; RETURN INT VEC TABLE SIZE
4836   0C4C             #ENDIF
4837   0C4C AF          	XOR	A			; INDICATE SUCCESS
4838   0C4D C9          	RET				; AND DONE
4839   0C4E             ;
4840   0C4E             ; ROUTINE SHARED BY INT GET/SET.  RETURNS ADDRESS OF VECTOR FOR SPECIFIED LIST / TABLE
4841   0C4E             ; POSITION.  ZF SET ON RETURN FOR SUCCESS, ELSE ERROR.
4842   0C4E             ;
4843   0C4E             SYS_INTVECADR:
4844   0C4E~            #IF (INTMODE == 0)
4845   0C4E~            	SYSCHKERR(ERR_BADCFG)		; SIGNAL ERROR. INVALID FOR INT MODE 0
4845   0C4E~            	SYSCHKERR(ERR_BADCFG)		; SIGNAL ERROR. INVALID FOR INT MODE 0
4845   0C4E~            	SYSCHKERR(ERR_BADCFG)		; SIGNAL ERROR. INVALID FOR INT MODE 0
4845   0C4E~            	SYSCHKERR(ERR_BADCFG)		; SIGNAL ERROR. INVALID FOR INT MODE 0
4845   0C4E~            	SYSCHKERR(ERR_BADCFG)		; SIGNAL ERROR. INVALID FOR INT MODE 0
4846   0C4E~            	RET
4847   0C4E             #ENDIF
4848   0C4E             #IF (INTMODE == 1)
4849   0C4E 3A AA 0C    	LD	A,(HB_IM1CNT)		; GET CURRENT ENTRY COUNT
4850   0C51 3C          	INC	A			; ALLOW FOR EXTRA ENTRY TO APPEND AT END
4851   0C52 4F          	LD	C,A			; SAVE IN C FOR COMPARE
4852   0C53             #ENDIF
4853   0C53~            #IF (INTMODE == 2)
4854   0C53~            	LD	C,HBX_IVTCNT		; GET CURRENT ENTRY COUNT
4855   0C53             #ENDIF
4856   0C53 7B          	LD	A,E			; INCOMING INDEX POSITION TO A
4857   0C54 B9          	CP	C			; COMPARE TO VECTOR COUNT
4858   0C55 38 07       	JR	C,SYS_INTGET1		; CONTINUE IF POSITION IN RANGE
4859   0C57             	SYSCHKERR(ERR_RANGE)		; ELSE ERROR
4859   0C57             
4859   0C57 CD 60 23    
4859   0C5A 3E FA       
4859   0C5C B7          
4860   0C5D C9          	RET
4861   0C5E             SYS_INTGET1:
4862   0C5E B7          	OR	A			; CLEAR CARRY
4863   0C5F 17          	RLA				; ADJUST FOR TABLE ENTRY
4864   0C60 17          	RLA				; SIZE OF 4 BYTES
4865   0C61 3C          	INC	A			; BUMP TO ADR FIELD
4866   0C62 26 00       	LD	H,0
4867   0C64 6F          	LD	L,A
4868   0C65 11 00 05    	LD	DE,HB_IVT		; DE := START OF VECTOR TABLE
4869   0C68 19          	ADD	HL,DE			; HL := ADR OF VECTOR
4870   0C69 AF          	XOR	A			; INDICATE SUCCESS
4871   0C6A C9          	RET
4872   0C6B             ;
4873   0C6B             ; RETURN THE INTERRUPT VECTOR FOR A SPECIFIED POSITION IN THE INT VECTOR LIST / TABLE
4874   0C6B             ; ENTRY: E=LIST/TABLE POSITION
4875   0C6B             ; RETURN: HL=INTERRUPT VECTOR
4876   0C6B             ;
4877   0C6B             SYS_INTGET:
4878   0C6B CD 4E 0C    	CALL	SYS_INTVECADR		; GET VECTOR ADDRESS
4879   0C6E C0          	RET	NZ			; BAIL OUT ON ERROR
4880   0C6F 7E          	LD	A,(HL)			; DEREF HL TO GET VECTOR
4881   0C70 23          	INC	HL
4882   0C71 66          	LD	H,(HL)
4883   0C72 6F          	LD	L,A
4884   0C73 AF          	XOR	A			; SIGNAL SUCCESS
4885   0C74 C9          	RET				; DONE
4886   0C75             ;
4887   0C75             ; SET AN INTERRUPT VECTOR FOR A SPECIFIED POSITION IN THE INT VECTOR LIST / TABLE
4888   0C75             ; ENTRY: E=LIST/TABLE POSITION, HL=NEW INTERRUPT VECTOR
4889   0C75             ; RETURN: HL=PREVIOUS INTERRUPT VECTOR
4890   0C75             ;
4891   0C75             SYS_INTSET:
4892   0C75 E5          	PUSH	HL			; SAVE NEW VECTOR
4893   0C76 CD 4E 0C    	CALL	SYS_INTVECADR		; GET VECTOR ADDRESS
4894   0C79 28 02       	JR	Z,SYS_INTSET1		; CONTINUE IF OK
4895   0C7B E1          	POP	HL			; FIX STACK
4896   0C7C C0          	RET	NZ			; BAIL OUT ON ERROR
4897   0C7D             SYS_INTSET1:
4898   0C7D E5          	PUSH	HL			; SAVE VECTOR ADDRESS
4899   0C7E 7E          	LD	A,(HL)			; DEREF HL TO GET PREV VECTOR
4900   0C7F 23          	INC	HL
4901   0C80 66          	LD	H,(HL)
4902   0C81 6F          	LD	L,A
4903   0C82 E3          	EX	(SP),HL			; (SP) := PREV VEC, HL := VEC ADR
4904   0C83 D1          	POP	DE			; DE := PREV VEC
4905   0C84 C1          	POP	BC			; BC := NEW VEC
4906   0C85 71          	LD	(HL),C			; SAVE LSB
4907   0C86 23          	INC	HL
4908   0C87 70          	LD	(HL),B			; SAVE MSB
4909   0C88 EB          	EX	DE,HL			; HL := PREV VEC
4910   0C89 AF          	XOR	A			; SIGNAL SUCCESS
4911   0C8A C9          	RET				; DONE
4912   0C8B             ;
4913   0C8B             ;==================================================================================================
4914   0C8B             ;   GLOBAL HBIOS FUNCTIONS
4915   0C8B             ;==================================================================================================
4916   0C8B             ;
4917   0C8B             ; COMMON ROUTINE THAT IS CALLED BY CHARACTER IO DRIVERS WHEN
4918   0C8B             ; AN IDLE CONDITION IS DETECTED (WAIT FOR INPUT/OUTPUT)
4919   0C8B             ;
4920   0C8B             CIO_IDLE:
4921   0C8B F5          	PUSH	AF			; PRESERVE AF
4922   0C8C 3A 5A 29    	LD	A,(IDLECOUNT)		; GET CURRENT IDLE COUNT
4923   0C8F 3D          	DEC	A			; DECREMENT
4924   0C90 32 5A 29    	LD	(IDLECOUNT),A		; SAVE UPDATED VALUE
4925   0C93 CC 76 07    	CALL	Z,IDLE			; IF ZERO, DO IDLE PROCESSING
4926   0C96 F1          	POP	AF			; RECOVER AF
4927   0C97 C9          	RET
4928   0C98             ;
4929   0C98             #IF (INTMODE == 1)
4930   0C98             ;
4931   0C98             ; ROUTINE BELOW IS USED TO ADD A NEW VECTOR TO THE IM1
4932   0C98             ; CALL LIST ABOVE.  ENTER WITH HL=VECTOR ADDRESS IN HBIOS
4933   0C98             ;
4934   0C98             HB_ADDIM1:
4935   0C98 EB          	EX	DE,HL			; VECTOR ADDRESS TO DE
4936   0C99 2A AC 0C    	LD	HL,(HB_IM1PTR)		; GET PTR FOR NEXT ENTRY
4937   0C9C 23          	INC	HL			; BUMP PTR TO ADDRESS FIELD OF CALL OPCODE
4938   0C9D 73          	LD	(HL),E			; ADD VECTOR ADDRESS
4939   0C9E 23          	INC	HL			; ...
4940   0C9F 72          	LD	(HL),D			; ...
4941   0CA0 23          	INC	HL			; BUMP PTR
4942   0CA1 23          	INC	HL			; BUMP PTR
4943   0CA2 22 AC 0C    	LD	(HB_IM1PTR),HL		; SAVE UPDATED POINTER
4944   0CA5 21 AA 0C    	LD	HL,HB_IM1CNT		; POINT TO ENTRY COUNT
4945   0CA8 34          	INC	(HL)			; INCREMENT
4946   0CA9 C9          	RET				; DONE
4947   0CAA             ;
4948   0CAA 00          HB_IM1CNT	.DB	0		; NUMBER OF ENTRIES IN CALL LIST
4949   0CAB 08          HB_IM1MAX	.DB	8		; MAX ENTRIES IN CALL LIST
4950   0CAC 00 05       HB_IM1PTR	.DW	HB_IVT		; POINTER FOR NEXT IM1 ENTRY
4951   0CAE             ;
4952   0CAE             #ENDIF
4953   0CAE             ;
4954   0CAE             ;
4955   0CAE             ;
4956   0CAE~            #IF (MEMMGR == MM_Z280)
4957   0CAE~            ;
4958   0CAE~            Z280_TIMINT:
4959   0CAE~            	; DISCARD REASON CODE
4960   0CAE~            	INC	SP
4961   0CAE~            	INC	SP
4962   0CAE~            ;
4963   0CAE~            	; SAVE INCOMING REGISTERS
4964   0CAE~            	PUSH	AF
4965   0CAE~            	PUSH	BC
4966   0CAE~            	PUSH	DE
4967   0CAE~            	PUSH	HL
4968   0CAE~            ;
4969   0CAE~            	; CALL PRIMARY TIMER LOGIC ON EVERY OTHER INT
4970   0CAE~            	LD	A,(Z280_TIMCTR)
4971   0CAE~            	XOR	$FF
4972   0CAE~            	LD	(Z280_TIMCTR),A
4973   0CAE~            	CALL	Z,HB_TIMINT
4974   0CAE~            ;
4975   0CAE~            	; SELECT I/O PAGE $FE (SAVING PREVIOUS VALUE)
4976   0CAE~            	LD	C,Z280_IOPR		; REG C POINTS TO I/O PAGE REGISTER
4977   0CAE~            	LDCTL	HL,(C)			; GET CURRENT I/O PAGE
4978   0CAE~            	PUSH	HL			; SAVE IT
4979   0CAE~            	LD	L,$FE			; NEW COUNTER/TIMER I/O PAGE
4980   0CAE~            	LDCTL	(C),HL
4981   0CAE~            ;
4982   0CAE~            	; CLEAR END OF COUNT CONDITION TO RESET INTERRUPT
4983   0CAE~            	IN	A,(Z280_CT0_CMDST)	; GET STATUS
4984   0CAE~            	RES	1,A			; CLEAR CC
4985   0CAE~            	OUT	(Z280_CT0_CMDST),A	; SET C/T 0
4986   0CAE~            ;
4987   0CAE~            	; RESTORE I/O PAGE
4988   0CAE~            	LD	C,Z280_IOPR		; REG C POINTS TO I/O PAGE REGISTER
4989   0CAE~            	POP	HL			; RECOVER ORIGINAL I/O PAGE
4990   0CAE~            	LDCTL	(C),HL
4991   0CAE~            ;
4992   0CAE~            	; RESTORE REGISTERS
4993   0CAE~            	POP	HL
4994   0CAE~            	POP	DE
4995   0CAE~            	POP	BC
4996   0CAE~            	POP	AF
4997   0CAE~            ;
4998   0CAE~            	RETIL
4999   0CAE~            ;
5000   0CAE~            Z280_TIMCTR	.DB	0		; USED TO DIVIDE TIMER INTS
5001   0CAE~            ;
5002   0CAE             #ENDIF
5003   0CAE             ;
5004   0CAE             ;
5005   0CAE             ;
5006   0CAE             HB_TIMINT:
5007   0CAE~            #IF FALSE	; *DEBUG*
5008   0CAE~            	LD	HL,HB_TIMDBGCNT
5009   0CAE~            	INC	(HL)
5010   0CAE~            	LD	A,(HL)
5011   0CAE~            	OUT	(DIAGPORT),A
5012   0CAE~            	JR	HB_TIMDBG1
5013   0CAE~            HB_TIMDBGCNT	.DB	0
5014   0CAE~            HB_TIMDBG1:
5015   0CAE             #ENDIF	; *DEBUG*
5016   0CAE             ;
5017   0CAE             ; TIMER HANDLER VECTORS
5018   0CAE             ; THESE CAN BE HOOKED AS DESIRED BY DRIVERS
5019   0CAE             ;
5020   0CAE             VEC_TICK:
5021   0CAE C3 B4 0C    	JP	HB_TICK			; TICK PROCESSING VECTOR
5022   0CB1             VEC_SECOND:
5023   0CB1 C3 C9 0C    	JP	HB_SECOND		; SECOND PROCESSING VECTOR
5024   0CB4             ;
5025   0CB4             ; TIMER HANDLERS
5026   0CB4             ;
5027   0CB4             HB_TICK:
5028   0CB4             	; INCREMENT TICK COUNTER (32 BIT)
5029   0CB4 21 5D 29    	LD	HL,HB_TICKS		; POINT TO TICK COUNTER
5030   0CB7 CD D8 1C    	CALL	INC32HL
5031   0CBA 21 61 29    	LD	HL,HB_SECTCK		; POINT TO SECONDS TICK COUNTER
5032   0CBD 35          	DEC	(HL)			; COUNTDOWN ONE SECOND OF TICKS
5033   0CBE 20 06       	JR	NZ,HB_TICK1		; NOT DONE, SKIP AHEAD
5034   0CC0 3E 32       	LD	A,TICKFREQ		; TICKS PER SECOND
5035   0CC2 77          	LD	(HL),A			; RESET COUNTDOWN REGISTER
5036   0CC3 CD B1 0C    	CALL	VEC_SECOND		; DO SECONDS PROCESSING VIA VECTOR
5037   0CC6             ;
5038   0CC6             HB_TICK1:
5039   0CC6             ;
5040   0CC6~            #IF (CPUFAM == CPU_Z180)
5041   0CC6~            	; ACK/RESET Z180 TIMER INTERRUPT
5042   0CC6~            	IN0	A,(Z180_TCR)
5043   0CC6~            	IN0	A,(Z180_TMDR0L)
5044   0CC6             #ENDIF
5045   0CC6             ;
5046   0CC6~            #IF (WDOGMODE != WDOG_NONE)
5047   0CC6~            	; PULSE WATCHDOG
5048   0CC6~            	OUT	(WDOGIO),A		; VALUE IS IRRELEVANT
5049   0CC6             #ENDIF
5050   0CC6             ;
5051   0CC6~            #IF MKYENABLE
5052   0CC6~            	CALL	MKY_INT
5053   0CC6             #ENDIF
5054   0CC6             ;
5055   0CC6 F6 FF       	OR	$FF			; NZ SET TO INDICATE INT HANDLED
5056   0CC8 C9          	RET
5057   0CC9             ;
5058   0CC9             HB_SECOND:
5059   0CC9             	; INCREMENT SECONDS COUNTER
5060   0CC9 21 62 29    	LD	HL,HB_SECS		; POINT TO SECONDS COUNTER
5061   0CCC C3 D8 1C    	JP	INC32HL			; INCREMENT AND RETURN
5062   0CCF             ;
5063   0CCF             ; BAD INTERRUPT HANDLER
5064   0CCF             ;
5065   0CCF             HB_BADINT:
5066   0CCF             
5067   0CCF~            #IF FALSE	; *DEBUG*
5068   0CCF~            	LD	HL,HB_BADINTCNT
5069   0CCF~            	INC	(HL)
5070   0CCF~            	LD	A,(HL)
5071   0CCF~            	OUT	(DIAGPORT),A
5072   0CCF~            	OR	$FF
5073   0CCF~            	RET
5074   0CCF~            HB_BADINTCNT	.DB	0
5075   0CCF             #ENDIF	; *DEBUG*
5076   0CCF             
5077   0CCF CD 1D 19    	CALL	NEWLINE2
5078   0CD2 CD 3B 19    	PRTS("+++ BAD INT $")
5078   0CD5 2B 2B 2B 20 
5078   0CD9 42 41 44 20 
5078   0CDD 49 4E 54 20 
5078   0CE1 24 
5079   0CE2 7D          	LD	A,L
5080   0CE3 0F          	RRCA
5081   0CE4 0F          	RRCA
5082   0CE5 CD 52 19    	CALL PRTHEXBYTE
5083   0CE8 CD 3B 19    	PRTS("H: $")
5083   0CEB 48 3A 20 24 
5084   0CEF             
5085   0CEF CD 36 1A    	CALL	XREGDMP
5086   0CF2             	;CALL	CONTINUE
5087   0CF2 F6 FF       	OR	$FF			; SIGNAL INTERRUPT HANDLED
5088   0CF4 C9          	RET
5089   0CF5             ;
5090   0CF5             ; Z280 BAD INT HANDLER
5091   0CF5             ;
5092   0CF5~            #IF (MEMMGR == MM_Z280)
5093   0CF5~            ;
5094   0CF5~            Z280_BADINT:
5095   0CF5~            	; SAVE REASON CODE FOR POSSIBLE RETURN VIA RETIL
5096   0CF5~            	EX	(SP),HL			; GET MSR, SAVE HL
5097   0CF5~            	LD	(HB_RCSAV),HL		; SAVE IT
5098   0CF5~            	POP	HL			; RECOVER HL, POP STACK
5099   0CF5~            	; SAVE MSR FOR POSSIBLE RETURN VIA RETIL
5100   0CF5~            	EX	(SP),HL			; GET MSR, SAVE HL
5101   0CF5~            	LD	(HB_MSRSAV),HL		; SAVE IT
5102   0CF5~            	POP	HL			; RECOVER HL, POP STACK
5103   0CF5~            ;
5104   0CF5~            	PUSH	DE
5105   0CF5~            	LD	DE,Z280_BADINTSTR
5106   0CF5~            	CALL	NEWLINE2
5107   0CF5~            	PRTS("+++ $")
5107   0CF5~            	PRTS("+++ $")
5108   0CF5~            	CALL	WRITESTR
5109   0CF5~            	POP	DE
5110   0CF5~            	CALL	XREGDMP
5111   0CF5~            ;
5112   0CF5~            	; RECOVER MSR, THEN RETURN VIA RETIL
5113   0CF5~            	PUSH	HL			; SAVE HL
5114   0CF5~            	LD	HL,(HB_RCSAV)		; GET SAVED REASON CODE
5115   0CF5~            	PRTS(" RC=$")
5115   0CF5~            	PRTS(" RC=$")
5116   0CF5~            	CALL	PRTHEXWORDHL		; DUMP MSR
5117   0CF5~            	LD	HL,(HB_MSRSAV)		; GET SAVED MSR
5118   0CF5~            	PRTS(" MSR=$")
5118   0CF5~            	PRTS(" MSR=$")
5119   0CF5~            	CALL	PRTHEXWORDHL		; DUMP MSR
5120   0CF5~            	EX	(SP),HL			; MSR TO STK, RECOVER HL
5121   0CF5~            ;
5122   0CF5~            	RETIL				; RETURN FROM INT
5123   0CF5~            ;
5124   0CF5~            Z280_SSTEP:
5125   0CF5~            	; SAVE HL AND MSR FOR POSSIBLE RETURN VIA RETIL
5126   0CF5~            	EX	(SP),HL			; GET MSR, SAVE HL
5127   0CF5~            	LD	(HB_MSRSAV),HL		; SAVE IT
5128   0CF5~            	POP	HL			; RECOVER HL, POP STACK
5129   0CF5~            ;
5130   0CF5~            	PUSH	DE
5131   0CF5~            	LD	DE,Z280_SSTEPSTR
5132   0CF5~            	JP	Z280_DIAG
5133   0CF5~            ;
5134   0CF5~            Z280_BRKHLT:
5135   0CF5~            	; SAVE HL AND MSR FOR POSSIBLE RETURN VIA RETIL
5136   0CF5~            	EX	(SP),HL			; GET MSR, SAVE HL
5137   0CF5~            	LD	(HB_MSRSAV),HL		; SAVE IT
5138   0CF5~            	POP	HL			; RECOVER HL, POP STACK
5139   0CF5~            ;
5140   0CF5~            	PUSH	DE
5141   0CF5~            	LD	DE,Z280_BRKHLTSTR
5142   0CF5~            	JP	Z280_DIAG
5143   0CF5~            ;
5144   0CF5~            Z280_DIVEXC:
5145   0CF5~            	; SAVE HL AND MSR FOR POSSIBLE RETURN VIA RETIL
5146   0CF5~            	EX	(SP),HL			; GET MSR, SAVE HL
5147   0CF5~            	LD	(HB_MSRSAV),HL		; SAVE IT
5148   0CF5~            	POP	HL			; RECOVER HL, POP STACK
5149   0CF5~            ;
5150   0CF5~            	PUSH	DE
5151   0CF5~            	LD	DE,Z280_DIVEXCSTR
5152   0CF5~            	JP	Z280_DIAG
5153   0CF5~            ;
5154   0CF5~            Z280_STKOVR:
5155   0CF5~            	; SAVE HL AND MSR FOR POSSIBLE RETURN VIA RETIL
5156   0CF5~            	EX	(SP),HL			; GET MSR, SAVE HL
5157   0CF5~            	LD	(HB_MSRSAV),HL		; SAVE IT
5158   0CF5~            	POP	HL			; RECOVER HL, POP STACK
5159   0CF5~            ;
5160   0CF5~            	PUSH	DE
5161   0CF5~            	LD	DE,Z280_STKOVRSTR
5162   0CF5~            	JP	Z280_DIAG
5163   0CF5~            ;
5164   0CF5~            Z280_ACCVIO:
5165   0CF5~            	; SAVE HL AND MSR FOR POSSIBLE RETURN VIA RETIL
5166   0CF5~            	EX	(SP),HL			; GET MSR, SAVE HL
5167   0CF5~            	LD	(HB_MSRSAV),HL		; SAVE IT
5168   0CF5~            	POP	HL			; RECOVER HL, POP STACK
5169   0CF5~            ;
5170   0CF5~            	PUSH	DE
5171   0CF5~            	LD	DE,Z280_ACCVIOSTR
5172   0CF5~            	JP	Z280_DIAG
5173   0CF5~            ;
5174   0CF5~            Z280_DIAG:
5175   0CF5~            	CALL	NEWLINE2
5176   0CF5~            	PRTS("+++ $")
5176   0CF5~            	PRTS("+++ $")
5177   0CF5~            	CALL	WRITESTR
5178   0CF5~            	POP	DE
5179   0CF5~            	CALL	XREGDMP
5180   0CF5~            ;
5181   0CF5~            	; RECOVER MSR, THEN RETURN VIA RETIL
5182   0CF5~            	PUSH	HL			; SAVE HL
5183   0CF5~            	LD	HL,(HB_MSRSAV)		; GET SAVED MSR
5184   0CF5~            	PRTS(" MSR=$")
5184   0CF5~            	PRTS(" MSR=$")
5185   0CF5~            	CALL	PRTHEXWORDHL		; DUMP MSR
5186   0CF5~            	EX	(SP),HL			; MSR TO STK, RECOVER HL
5187   0CF5~            ;
5188   0CF5~            	;RETIL
5189   0CF5~            	DI
5190   0CF5~            	HALT
5191   0CF5~            ;
5192   0CF5~            Z280_BADINTSTR	.TEXT	"BAD INT $"
5193   0CF5~            Z280_SSTEPSTR	.TEXT	"SINGLE STEP $"
5194   0CF5~            Z280_BRKHLTSTR	.TEXT	"BREAK HALT $"
5195   0CF5~            Z280_DIVEXCSTR	.TEXT	"DIVISION EXCEPTION $"
5196   0CF5~            Z280_STKOVRSTR	.TEXT	"STACK OVERFLOW $"
5197   0CF5~            Z280_ACCVIOSTR	.TEXT	"ACCESS VIOLATION $"
5198   0CF5~            ;
5199   0CF5             #ENDIF
5200   0CF5             ;
5201   0CF5             ; Z280 PRIVILEGED INSTRUCTION HANDLER
5202   0CF5             ;
5203   0CF5~            #IF (MEMMGR == MM_Z280)
5204   0CF5~            ;
5205   0CF5~            Z280_PRIVINST:
5206   0CF5~            	; SAVE HL AND MSR FOR POSSIBLE RETURN VIA RETIL
5207   0CF5~            	EX	(SP),HL			; GET MSR, SAVE HL
5208   0CF5~            	LD	(HB_MSRSAV),HL		; SAVE IT
5209   0CF5~            	POP	HL			; RECOVER HL, POP STACK
5210   0CF5~            	EX	(SP),HL			; GET ADR, SAVE HL
5211   0CF5~            ;
5212   0CF5~            	PUSH	AF
5213   0CF5~            	PUSH	BC
5214   0CF5~            	PUSH	DE
5215   0CF5~            ;
5216   0CF5~            	LDUP	A,(HL)			; BYTE FROM USER SPACE
5217   0CF5~            ;
5218   0CF5~            	; HANDLE DI
5219   0CF5~            	CP	$F3			; DI?
5220   0CF5~            	JR	NZ,Z280_PRIVINST2
5221   0CF5~            	HB_DI				; DO THE DI
5222   0CF5~            	INC	HL			; BUMP PAST IT
5223   0CF5~            	JR	Z280_PRIVINSTX
5224   0CF5~            ;
5225   0CF5~            Z280_PRIVINST2:
5226   0CF5~            	; HANDLE EI
5227   0CF5~            	CP	$FB			; EI?
5228   0CF5~            	JR	NZ,Z280_PRIVINST3
5229   0CF5~            	HB_EI				; DO THE EI
5230   0CF5~            	INC	HL			; BUMP PAST IT
5231   0CF5~            	JR	Z280_PRIVINSTX
5232   0CF5~            ;
5233   0CF5~            Z280_PRIVINST3:
5234   0CF5~            	; SOMETHING ELSE, DIAGNOSE & HALT SYSTEM
5235   0CF5~            	LD	DE,Z280_PRIVSTR
5236   0CF5~            	CALL	WRITESTR
5237   0CF5~            	CALL	PRTHEXWORDHL
5238   0CF5~            ;
5239   0CF5~            	; DUMP 16 BYTES OF USER ADDRESS SPACE
5240   0CF5~            	CALL	PC_SPACE
5241   0CF5~            	CALL	PC_LBKT
5242   0CF5~            	LD	B,$10
5243   0CF5~            Z280_PRIVINST4:
5244   0CF5~            	LDUP	A,(HL)			; BYTE FROM USER SPACE
5245   0CF5~            	CALL	PRTHEXBYTE
5246   0CF5~            	INC	HL
5247   0CF5~            	DJNZ	Z280_PRIVINST4
5248   0CF5~            	CALL	PC_RBKT
5249   0CF5~            ;
5250   0CF5~            	; GO NO FURTHER
5251   0CF5~            	DI
5252   0CF5~            	HALT
5253   0CF5~            ;
5254   0CF5~            Z280_PRIVINSTX:
5255   0CF5~            	; RESTORE REGISTERS
5256   0CF5~            	POP	DE
5257   0CF5~            	POP	BC
5258   0CF5~            	POP	AF
5259   0CF5~            ;
5260   0CF5~            	; RECOVER HL AND MSR, THEN RETURN VIA RETIL
5261   0CF5~            	EX	(SP),HL			; RECOVER HL, ADR TO STK
5262   0CF5~            	PUSH	HL			; SAVE HL
5263   0CF5~            	LD	HL,(HB_MSRSAV)		; GET SAVED MSR
5264   0CF5~            	EX	(SP),HL			; MSR TO STK, RECOVER HL
5265   0CF5~            	RETIL				; RETURN FROM INT
5266   0CF5~            ;
5267   0CF5~            HB_MSRSAV	.DW	0		; SAVED MSR
5268   0CF5~            HB_RCSAV	.DW	0		; SAVED REASON CODE
5269   0CF5~            ;
5270   0CF5~            Z280_PRIVSTR	.TEXT	"\r\n\r\n*** Privileged Instruction @$"
5271   0CF5~            ;
5272   0CF5             #ENDIF
5273   0CF5             ;
5274   0CF5             ; COMMON API FUNCTION DISPATCH CODE
5275   0CF5             ;
5276   0CF5             ; ON ENTRY B IS API FUNCTION NUMBER AND C IS UNIT #
5277   0CF5             ; (INDEX INTO XXX_TBL OF UNITS) AND IY POINTS TO START OF UNIT TABLE.
5278   0CF5             ; USE UNIT # IN C TO LOOKUP XXX_TBL ENTRY.  THE XXX_TBL
5279   0CF5             ; ENTRY CONTAINS THE START OF THE DRIVER FUNCTION TABLE AND
5280   0CF5             ; THE DEVICE SPECIFIC INSTANCE DATA (BLOB).  SET IY TO BLOB ADDRESS
5281   0CF5             ; AND CALL THE SPECIFIC FUNCTION REQUESTED IN THE DRIVER.
5282   0CF5             ;
5283   0CF5             HB_DISPCALL:
5284   0CF5 E5          	PUSH	HL			; SAVE INCOMING HL VALUE
5285   0CF6 CD FF 0C    	CALL	HB_DISPCALC		; IY = BLOB ADR, HL = FN ADR
5286   0CF9 20 02       	JR	NZ,HB_DISPCALL1		; ABORT ON ERROR
5287   0CFB E3          	EX	(SP),HL			; RESTORE HL & FN ADR TO TOS
5288   0CFC C9          	RET				; JUMP TO FN ADR
5289   0CFD             HB_DISPCALL1:
5290   0CFD E1          	POP	HL			; RECOVER HL
5291   0CFE C9          	RET				; AND DONE
5292   0CFF             ;
5293   0CFF             ; ENTRY: BC=FUNC/UNIT, IY=DISPATCH TABLE
5294   0CFF             ; EXIT: HL=FUNC ADR, IY=DATA BLOB ADR
5295   0CFF             ;
5296   0CFF             HB_DISPCALC:
5297   0CFF             	; CHECK INCOMING UNIT INDEX IN C FOR VALIDITY
5298   0CFF 79          	LD	A,C			; A := INCOMING DISK UNIT INDEX
5299   0D00 FD BE FF    	CP	(IY-1)			; COMPARE TO COUNT
5300   0D03 30 33       	JR	NC,HB_UNITERR		; HANDLE INVALID UNIT INDEX
5301   0D05             
5302   0D05             	; CHECK FUNCTION INDEX FOR VALIDITY
5303   0D05 78          	LD	A,B			; A := INCOMING FUNCTION NUMBER
5304   0D06 E6 0F       	AND	$0F			; LOW NIBBLE ONLY FOR FUNC INDEX
5305   0D08 FD BE FD    	CP	(IY-3)			; CHECK FN NUM AGAINST MAX
5306   0D0B 30 24       	JR	NC,HB_FUNCERR		; HANDLE FN NUM OUT OF RANGE ERROR
5307   0D0D             
5308   0D0D             	; BUMP IY TO ACTUAL XXX_TBL ENTRY FOR INCOMING UNIT INDEX
5309   0D0D C5          	PUSH	BC			; SAVE BC
5310   0D0E 06 00       	LD	B,0			; MSB IS ALWAYS ZERO
5311   0D10 CB 01       	RLC	C			; MULTIPLY UNIT INDEX
5312   0D12 CB 01       	RLC	C			; ... BY 4 FOR TABLE ENTRY OFFSET
5313   0D14 FD 09       	ADD	IY,BC			; SET IY TO ENTRY ADDRESS
5314   0D16 C1          	POP	BC			; RESTORE BC
5315   0D17             
5316   0D17             	; DERIVE DRIVER FUNC ADR TO CALL
5317   0D17             	;PUSH	HL			; SAVE INCOMING HL
5318   0D17 FD 6E 00    	LD	L,(IY+0)		; COPY DRIVER FUNC TABLE
5319   0D1A FD 66 01    	LD	H,(IY+1)		; ... START TO HL
5320   0D1D 07          	RLCA				; CONV UNIT (STILL IN A) TO FN ADR OFFSET
5321   0D1E CD D2 1A    	CALL	ADDHLA			; HL NOW HAS DRIVER FUNC TBL START ADR
5322   0D21 7E          	LD	A,(HL)			; DEREFERENCE HL
5323   0D22 23          	INC	HL			; ... TO GET
5324   0D23 66          	LD	H,(HL)			; ... ACTUAL
5325   0D24 6F          	LD	L,A			; ... TARGET FUNCTION ADDRESS
5326   0D25             	;EX	(SP),HL			; RESTORE HL, FUNC ADR ON STACK
5327   0D25             
5328   0D25             	; GET UNIT INSTANCE DATA BLOB ADDRESS TO IY
5329   0D25             	;PUSH	HL			; SAVE INCOMING HL
5330   0D25 E5          	PUSH	HL			; SAVE FUNC ADR
5331   0D26 FD 6E 02    	LD	L,(IY+2)		; HL := DATA BLOB ADDRESS
5332   0D29 FD 66 03    	LD	H,(IY+3)		; ...
5333   0D2C E3          	EX	(SP),HL			; RESTORE HL, BLOB ADR ON TOS
5334   0D2D FD E1       	POP	IY			; IY := BLOB ADR
5335   0D2F             
5336   0D2F AF          	XOR	A			; SIGNAL SUCCESS
5337   0D30 C9          	RET				; JUMP TO DRIVER FUNC ADR ON TOS
5338   0D31             ;
5339   0D31             HB_FUNCERR:
5340   0D31             	SYSCHKERR(ERR_NOFUNC)		; SIGNAL ERROR
5340   0D31             
5340   0D31 CD 60 23    
5340   0D34 3E FD       
5340   0D36 B7          
5341   0D37 C9          	RET
5342   0D38             ;
5343   0D38             HB_UNITERR:
5344   0D38             	SYSCHKERR(ERR_NOUNIT)		; SIGNAL ERROR
5344   0D38             
5344   0D38 CD 60 23    
5344   0D3B 3E FC       
5344   0D3D B7          
5345   0D3E C9          	RET
5346   0D3F             ;
5347   0D3F             ; ADD AN ENTRY TO THE UNIT TABLE AT ADDRESS IN HL
5348   0D3F             ;   BC: DRIVER FUNCTION TABLE
5349   0D3F             ;   DE: ADDRESS OF UNIT INSTANCE DATA
5350   0D3F             ; RETURN
5351   0D3F             ;   A: UNIT NUMBER ASSIGNED
5352   0D3F             ;
5353   0D3F             HB_ADDENT:
5354   0D3F 2B          	DEC	HL			; POINT TO ENTRY COUNT
5355   0D40 7E          	LD	A,(HL)			; GET ENTRY COUNT
5356   0D41 F5          	PUSH	AF			; SAVE VALUE TO RETURN AS ENTRY NUM AT END
5357   0D42 3C          	INC	A			; INCREMENT TO ACCOUNT FOR NEW ENTRY
5358   0D43 2B          	DEC	HL			; POINT TO ENTRY MAX
5359   0D44 BE          	CP	(HL)			; COMPARE MAX TO CURRENT COUNT (COUNT - MAX)
5360   0D45 D4 82 23    	CALL	NC,PANIC		; OVERFLOW
5361   0D48 23          	INC	HL			; POINT TO COUNT
5362   0D49 77          	LD	(HL),A			; SAVE NEW COUNT
5363   0D4A 23          	INC	HL			; POINT TO START OF TABLE
5364   0D4B 3D          	DEC	A			; CONVERT A FROM ENTRY COUNT TO ENTRY INDEX
5365   0D4C 07          	RLCA				; MULTIPLY BY 4
5366   0D4D 07          	RLCA				; ... TO GET BYTE OFFSET OF ENTRY
5367   0D4E CD D2 1A    	CALL	ADDHLA			; MAKE HL POINT TO ACTUAL ENTRY ADDRESS
5368   0D51 C5          	PUSH	BC			; GET TABLE ENTRY ADDRESS TO BC
5369   0D52 E3          	EX	(SP),HL			; ... AND DISPATCH ADDRESS TO HL
5370   0D53 C1          	POP	BC			; ... SO THAT DE:HL HAS 32 BIT ENTRY
5371   0D54 CD BA 1C    	CALL	ST32			; LD (BC),DE:HL STORES THE ENTRY
5372   0D57 F1          	POP	AF			; RETURN ENTRY INDEX (UNIT NUMBER ASSIGNED)
5373   0D58 C9          	RET
5374   0D59             ;
5375   0D59             ; ALLOCATE HL BYTES OF MEMORY ON THE HEAP
5376   0D59             ; RETURNS POINTER TO ALLOCATED SPACE IN HL
5377   0D59             ; ON SUCCESS RETURN A == 0, AND Z SET
5378   0D59             ; ON FAILURE A <> 0 AND NZ SET AND HL TRASHED
5379   0D59             ; ALL OTHER REGISTERS PRESERVED
5380   0D59             ;
5381   0D59             ; A 4 BYTE HEADER IS PLACED IN FRONT OF THE ALLOCATED MEMORY
5382   0D59             ;  - DWORD: SIZE OF MEMORY ALLOCATED (DOES NOT INCLUDE 4 BYTE HEADER)
5383   0D59             ;  - DWORD: ADDRESS WHERE ALLOC WAS CALLED (VALUE ON TOP OF STACK AT CALL)
5384   0D59             ;
5385   0D59             HB_ALLOC:
5386   0D59             	; SAVE ALLOC SIZE AND REFERENCE ADR FOR SUBSEQUENT HEADER CONSTRUCTION
5387   0D59 22 99 0D    	LD	(HB_TMPSZ),HL		; SAVE INCOMING SIZE REQUESTED
5388   0D5C             	; USE EX (SP),HL INSTEAD????
5389   0D5C E1          	POP	HL			; GET RETURN ADDRESS
5390   0D5D 22 9B 0D    	LD	(HB_TMPREF),HL		; SAVE AS REFERENCE
5391   0D60             	; USE EX (SP),HL INSTEAD????
5392   0D60 E5          	PUSH	HL			; PUT IT BACK ON STACK
5393   0D61 2A 99 0D    	LD	HL,(HB_TMPSZ)		; RECOVER INCOMING MEM SIZE PARM
5394   0D64             ;
5395   0D64             	; CALC NEW HEAP TOP AND HANDLE OUT-OF-SPACE ERROR
5396   0D64 D5          	PUSH	DE			; SAVE INCOMING DE
5397   0D65 11 04 00    	LD	DE,4			; SIZE OF HEADER
5398   0D68 19          	ADD	HL,DE			; ADD IT IN
5399   0D69 38 26       	JR	C,HB_ALLOC1		; ERROR ON OVERFLOW
5400   0D6B ED 5B 22 01 	LD	DE,(CB_HEAPTOP)		; CURRENT HEAP TOP
5401   0D6F 19          	ADD	HL,DE			; ADD IT IN, HL := NEW HEAP TOP
5402   0D70 38 1F       	JR	C,HB_ALLOC1		; ERROR ON OVERFLOW
5403   0D72 CB 7C       	BIT	7,H			; TEST PAST END OF BANK (>= 32K)
5404   0D74 20 1B       	JR	NZ,HB_ALLOC1		; ERROR IF PAST END
5405   0D76             ;
5406   0D76             	; SAVE NEW HEAP TOP
5407   0D76 ED 5B 22 01 	LD	DE,(CB_HEAPTOP)		; GET ORIGINAL HEAP TOP
5408   0D7A 22 22 01    	LD	(CB_HEAPTOP),HL		; SAVE NEW HEAP TOP
5409   0D7D             ;
5410   0D7D             	; SET HEADER VALUES
5411   0D7D EB          	EX	DE,HL			; HEADER ADR TO HL
5412   0D7E ED 5B 99 0D 	LD	DE,(HB_TMPSZ)		; GET THE ORIG SIZE REQUESTED
5413   0D82 73          	LD	(HL),E			; SAVE SIZE (LSB)
5414   0D83 23          	INC	HL			; BUMP HEADER POINTER
5415   0D84 72          	LD	(HL),D			; SAVE SIZE (MSB)
5416   0D85 23          	INC	HL			; BUMP HEADER POINTER
5417   0D86 ED 5B 9B 0D 	LD	DE,(HB_TMPREF)		; GET THE REFERENCE ADR
5418   0D8A 73          	LD	(HL),E			; SAVE REF ADR (LSB)
5419   0D8B 23          	INC	HL			; BUMP HEADER POINTER
5420   0D8C 72          	LD	(HL),D			; SAVE REF ADR (MSB)
5421   0D8D 23          	INC	HL			; BUMP HEADER POINTER
5422   0D8E             ;
5423   0D8E             	; RETURN SUCCESS, HL POINTS TO START OF ALLOCATED MEMORY (PAST HEADER)
5424   0D8E D1          	POP	DE			; RESTORE INCOMING DE
5425   0D8F AF          	XOR	A			; SIGNAL SUCCESS
5426   0D90 C9          	RET				; AND RETURN
5427   0D91             ;
5428   0D91             HB_ALLOC1:
5429   0D91             	; ERROR RETURN
5430   0D91 D1          	POP	DE			; RESTORE INCOMING DE
5431   0D92             	SYSCHKERR(ERR_NOMEM)		; SIGNAL ERROR
5431   0D92             
5431   0D92 CD 60 23    
5431   0D95 3E FB       
5431   0D97 B7          
5432   0D98 C9          	RET
5433   0D99             ;
5434   0D99 00 00       HB_TMPSZ	.DW	0
5435   0D9B 00 00       HB_TMPREF	.DW	0
5436   0D9D             ;
5437   0D9D             ;==================================================================================================
5438   0D9D             ;   Z280 INTERRUPT VECTOR TABLE
5439   0D9D             ;==================================================================================================
5440   0D9D             ;
5441   0D9D~            #IF (MEMMGR == MM_Z280)
5442   0D9D~            ;
5443   0D9D~            	; THE Z280 IVT MUST BE ON A 4K BOUNDARY.  IT HAS BEEN LOCATED
5444   0D9D~            	; HERE IN AN EFFORT TO MINIMIZE WASTED SPACE.  THERE SHOULD BE
5445   0D9D~            	; A LITTLE LESS THAN 4K OF CODE ABOVE.
5446   0D9D~            ;
5447   0D9D~            	.FILL	$1000 - ($ & $FFF)	; MUST BE 4K ALIGNED!
5448   0D9D~            ;
5449   0D9D~            Z280_IVT:
5450   0D9D~            	.DW	0, 0			; RESERVED
5451   0D9D~            	.DW	0			; NMI MSR
5452   0D9D~            	.DW	0			; NMI VECTOR
5453   0D9D~            	.DW	$0000			; INT A MSR
5454   0D9D~            	.DW	Z280_BADINT		; INT A VECTOR
5455   0D9D~            	.DW	$0000			; INT B MSR
5456   0D9D~            	.DW	Z280_BADINT		; INT B VECTOR
5457   0D9D~            	.DW	$0000			; INT C MSR
5458   0D9D~            	.DW	Z280_BADINT		; INT C VECTOR
5459   0D9D~            	.DW	$0000			; COUNTER/TIMER 0 MSR
5460   0D9D~            	.DW	Z280_BADINT		; COUNTER/TIMER 0 VECTOR
5461   0D9D~            	.DW	$0000			; COUNTER/TIMER 1 MSR
5462   0D9D~            	.DW	Z280_BADINT		; COUNTER/TIMER 1 VECTOR
5463   0D9D~            	.DW	0, 0			; RESERVED
5464   0D9D~            	.DW	$0000			; COUNTER/TIMER 2 MSR
5465   0D9D~            	.DW	Z280_BADINT		; COUNTER/TIMER 2 VECTOR
5466   0D9D~            	.DW	$0000			; DMA CHANNEL 0 MSR
5467   0D9D~            	.DW	Z280_BADINT		; DMA CHANNEL 0 VECTOR
5468   0D9D~            	.DW	$0000			; DMA CHANNEL 1 MSR
5469   0D9D~            	.DW	Z280_BADINT		; DMA CHANNEL 1 VECTOR
5470   0D9D~            	.DW	$0000			; DMA CHANNEL 2 MSR
5471   0D9D~            	.DW	Z280_BADINT		; DMA CHANNEL 2 VECTOR
5472   0D9D~            	.DW	$0000			; DMA CHANNEL 3 MSR
5473   0D9D~            	.DW	Z280_BADINT		; DMA CHANNEL 3 VECTOR
5474   0D9D~            	.DW	$0000			; UART RECEIVER MSR
5475   0D9D~            	.DW	Z280_BADINT		; UART RECEIVER VECTOR
5476   0D9D~            	.DW	$0000			; UART TRANSMITTER MSR
5477   0D9D~            	.DW	Z280_BADINT		; UART TRANSMITTER VECTOR
5478   0D9D~            	.DW	$0000			; SINGLE STEP TRAP MSR
5479   0D9D~            	.DW	Z280_SSTEP		; SINGLE STEP TRAP VECTOR
5480   0D9D~            	.DW	$0000			; BREAK ON HALT TRAP MSR
5481   0D9D~            	.DW	Z280_BRKHLT		; BREAK ON HALT TRAP VECTOR
5482   0D9D~            	.DW	$0000			; DIVISION EXCEPTION TRAP MSR
5483   0D9D~            	.DW	Z280_DIVEXC		; DIVISION EXCEPTION TRAP VECTOR
5484   0D9D~            	.DW	$0000			; STACK OVERFLOW WARNING TRAP MSR
5485   0D9D~            	.DW	Z280_STKOVR		; STACK OVERFLOW WARNING TRAP VECTOR
5486   0D9D~            	.DW	$0000			; ACCESS VIOLATION TRAP MSR
5487   0D9D~            	.DW	Z280_ACCVIO		; ACCESS VIOLATION TRAP VECTOR
5488   0D9D~            	.DW	$0000			; SYSTEM CALL TRAP MSR
5489   0D9D~            	.DW	Z280_SYSCALL		; SYSTEM CALL TRAP VECTOR
5490   0D9D~            	.DW	$0000			; PRIVILEGED INSTRUCTION TRAP MSR
5491   0D9D~            	.DW	Z280_PRIVINST		; PRIVILEGED INSTRUCTION TRAP VECTOR
5492   0D9D~            	.DW	$0000			; EPU <- MEMORY EXTENDED INSTRUCTION TRAP MSR
5493   0D9D~            	.DW	$0000			; EPU <- MEMORY EXTENDED INSTRUCTION TRAP VECTOR
5494   0D9D~            	.DW	$0000			; MEMORY <- EPU EXTENDED INSTRUCTION TRAP MSR
5495   0D9D~            	.DW	$0000			; MEMORY <- EPU EXTENDED INSTRUCTION TRAP VECTOR
5496   0D9D~            	.DW	$0000			; A <- EPU EXTENDED INSTRUCTION TRAP MSR
5497   0D9D~            	.DW	$0000			; A <- EPU EXTENDED INSTRUCTION TRAP VECTOR
5498   0D9D~            	.DW	$0000			; EPU INTERNAL OPERATION EXTENDED INSTRUCTION TRAP MSR
5499   0D9D~            	.DW	$0000			; EPU INTERNAL OPERATION EXTENDED INSTRUCTION TRAP VECTOR
5500   0D9D~            	.DW	0, 0			; RESERVED
5501   0D9D~            	.DW	0, 0			; RESERVED
5502   0D9D~            	; PROGRAM COUNTER VALUES FOR NMI/INTA (16)
5503   0D9D~            	.DW	HBX_IV00
5504   0D9D~            	.DW	HBX_IV01
5505   0D9D~            	.DW	HBX_IV02
5506   0D9D~            	.DW	HBX_IV03
5507   0D9D~            	.DW	HBX_IV04
5508   0D9D~            	.DW	HBX_IV05
5509   0D9D~            	.DW	HBX_IV06
5510   0D9D~            	.DW	HBX_IV07
5511   0D9D~            	.DW	HBX_IV08
5512   0D9D~            	.DW	HBX_IV09
5513   0D9D~            	.DW	HBX_IV0A
5514   0D9D~            	.DW	HBX_IV0B
5515   0D9D~            	.DW	HBX_IV0C
5516   0D9D~            	.DW	HBX_IV0D
5517   0D9D~            	.DW	HBX_IV0E
5518   0D9D~            	.DW	HBX_IV0F
5519   0D9D~            	; THE REMAINDER OF THE Z280 IVT IS TRUNCATED HERE BECAUSE IT
5520   0D9D~            	; TAKES A BUNCH OF SPACE AND IS NOT USED.  WE SUPPORT ONLY
5521   0D9D~            	; 16 VECTORED INTERRUPTS AND THEY MUST BE CONNECTED TO INTA.
5522   0D9D~            ;
5523   0D9D             #ENDIF
5524   0D9D             ;
5525   0D9D             ; Z280 BANK SELECTION (CALLED FROM PROXY)
5526   0D9D             ;
5527   0D9D~            #IF (MEMMGR == MM_Z280)
5528   0D9D~            ;
5529   0D9D~            ; REG A HAS BANK ID, REG B HAS INITIAL PDR TO PROGRAM
5530   0D9D~            ; REGISTERS AF, BC, HL DESTROYED
5531   0D9D~            ;
5532   0D9D~            ; THIS ROUTINE MAY BE RELOCATED TO RUN IN HIGH MEMORY IN CERTAIN CASES
5533   0D9D~            ; LIKE A SYSTEM RESTART.  IT MUST BE KEPT ENTIRELY RELOCATABLE.
5534   0D9D~            ;
5535   0D9D~            Z280_BNKSEL:
5536   0D9D~            	;; *DEBUG*
5537   0D9D~            	;CALL	PC_LBKT
5538   0D9D~            	;CALL	PRTHEXBYTE
5539   0D9D~            	;CALL	PC_RBKT
5540   0D9D~            
5541   0D9D~            	; SELECT I/O PAGE $FE (SAVING PREVIOUS VALUE)
5542   0D9D~            	LD	C,Z280_IOPR		; REG C POINTS TO I/O PAGE REGISTER
5543   0D9D~            	LDCTL	HL,(C)			; GET CURRENT I/O PAGE
5544   0D9D~            	PUSH	HL			; SAVE IT
5545   0D9D~            	LD	L,$FF			; NEW I/O PAGE
5546   0D9D~            	LDCTL	(C),HL
5547   0D9D~            ;
5548   0D9D~            	; CONVERT BANK ID TO TOP 12 BITS OF PHYSICAL ADDRESS
5549   0D9D~            	; WITH $0A IN THE LOW ORDER NIBBLE:
5550   0D9D~            	; BANK ID: R000 BBBB
5551   0D9D~            	; PDR: R000 0BBB B000 1010 (RCBUS)
5552   0D9D~            	; PDR: 0000 RBBB B000 1010 (ZZ80MB)
5553   0D9D~            ;
5554   0D9D~            	MULTU	A,$80			; HL=0R00 0BBB B000 0000
5555   0D9D~            	BIT	6,H			; RAM BIT SET?
5556   0D9D~            	JR	Z,Z280_BNKSEL2		; IF NOT, ALL DONE
5557   0D9D~            	RES	6,H			; OTHERWISE, MOVE RAM BIT
5558   0D9D~            	SET	RAMLOC-16,H		; HL=0000 RBBB B000 0000
5559   0D9D~            ;
5560   0D9D~            Z280_BNKSEL2:
5561   0D9D~            ;
5562   0D9D~            	; SET LOW NIBBLE
5563   0D9D~            	LD	A,$0A			; VALUE FOR LOW NIBBLE
5564   0D9D~            	ADD	HL,A			; ADD HL,A ; HL=0000 RBBB B000 1010
5565   0D9D~            ;
5566   0D9D~            	; POINT TO FIRST PDR TO PROGRAM
5567   0D9D~            	LD	A,B			; INITIAL PDR TO PROG
5568   0D9D~            	OUT	(Z280_MMUPDRPTR),A	; SET THE PDR POINTER
5569   0D9D~            ;
5570   0D9D~            	; PROGRAM 8 PDRS
5571   0D9D~            	LD	C,Z280_MMUBLKMOV	; PDR BLOCK MOVE PORT
5572   0D9D~            	;LD	B,8			; PROGRAM 8 PDRS
5573   0D9D~            	LD	A,$10			; PDR VALUE INCREMENT
5574   0D9D~            Z280_BNKSEL3:
5575   0D9D~            	; PROGRAM 8 PDR VALUES
5576   0D9D~            	; LOOP UNROLLED FOR SPEED
5577   0D9D~            	OUTW	(C),HL			; WRITE VALUE
5578   0D9D~            	ADD	HL,A			; BUMP VALUE
5579   0D9D~            	OUTW	(C),HL			; WRITE VALUE
5580   0D9D~            	ADD	HL,A			; BUMP VALUE
5581   0D9D~            	OUTW	(C),HL			; WRITE VALUE
5582   0D9D~            	ADD	HL,A			; BUMP VALUE
5583   0D9D~            	OUTW	(C),HL			; WRITE VALUE
5584   0D9D~            	ADD	HL,A			; BUMP VALUE
5585   0D9D~            	OUTW	(C),HL			; WRITE VALUE
5586   0D9D~            	ADD	HL,A			; BUMP VALUE
5587   0D9D~            	OUTW	(C),HL			; WRITE VALUE
5588   0D9D~            	ADD	HL,A			; BUMP VALUE
5589   0D9D~            	OUTW	(C),HL			; WRITE VALUE
5590   0D9D~            	ADD	HL,A			; BUMP VALUE
5591   0D9D~            	OUTW	(C),HL			; WRITE VALUE
5592   0D9D~            	ADD	HL,A			; BUMP VALUE
5593   0D9D~            	;DJNZ	Z280_BNKSEL3		; DO ALL PDRS
5594   0D9D~            ;
5595   0D9D~            	; RESTORE I/O PAGE
5596   0D9D~            	LD	C,Z280_IOPR		; REG C POINTS TO I/O PAGE REGISTER
5597   0D9D~            	POP	HL			; RECOVER ORIGINAL I/O PAGE
5598   0D9D~            	LDCTL	(C),HL
5599   0D9D~            ;
5600   0D9D~            	RET
5601   0D9D~            ;
5602   0D9D~            Z280_BNKSEL_LEN	.EQU	$ - Z280_BNKSEL
5603   0D9D~            ;
5604   0D9D             #ENDIF
5605   0D9D             ;
5606   0D9D             ; Z280 BANK COPY (CALLED FROM PROXY)
5607   0D9D             ;
5608   0D9D             ; USE Z280 PHYSICAL MEMORY DMA COPY TO PERFORM AN INTERBANK COPY.
5609   0D9D             ; COPY FROM (HB_SRCBNK):(HL) TO (HB_DSTBNK):(DE) FOR BC BYTES.  BOTH
5610   0D9D             ; HB_SRCBNK AND HB_DSTBNK MUST BE INITIALIZED PRIOR TO CALLING THIS
5611   0D9D             ; ROUTINE.
5612   0D9D             ;
5613   0D9D             ; ADDRESSES ARE TRANSLATED FROM LOGICAL (Z80) TO PHYSICAL (Z280) TO
5614   0D9D             ; SETUP THE DMA COPY PARAMETERS.  IF THE SOURCE OR DESTINATION RANGE
5615   0D9D             ; CROSSES OVER THE BANKED/COMMON BOUNDARY AT $8000, THEN SPECIAL STEPS
5616   0D9D             ; MUST BE TAKEN BECAUSE THE BANKED AND COMMON AEAS ARE PROBABLY NOT
5617   0D9D             ; SEQUENTIALLY LOCATED IN PHYSICAL MEMORY.  TWO ENTRY POINTS ARE
5618   0D9D             ; PROVIDED.  Z280_BNKCPY IS MUCH FASTER, BUT DOES NOT ACCOUNT FOR THE
5619   0D9D             ; COPY RANGES CROSSING OVER THE BANKED/COMMON BOUNDARY (WORKS GREAT
5620   0D9D             ; FOR ANY COPY KNOWN TO STAY WITHIN IT'S OWN AREA).  Z280_BNKCPYX
5621   0D9D             ; WILL HANDLE COPIES WHERE THE SOURCE AND/OR DESTINATION RANGES
5622   0D9D             ; CROSS OVER THE BANKED/COMMON MEMORY BOUNDARY.  IT DOES THIS BY
5623   0D9D             ; BREAKING UP THE COPY REQUESTS INTO MULTIPLE REQUESTS THAT ALL FIT
5624   0D9D             ; WITHIN A SINGLE BANKED/COMMON MEMORY SEGMENT AND CALLING Z280_BNKCPY
5625   0D9D             ; ITERATIVELY UNTIL THE COPY IS COMPLETE.
5626   0D9D             ;
5627   0D9D             ; THERE IS ESSENTIALLY NO PROTECTION FOR CALLING THESE ROUTINES WITH
5628   0D9D             ; INVALID PARAMETERS.  FOR EXAMPLE, A REQUEST TO COPY $2000 BYTES
5629   0D9D             ; STARTING AT $F000 EXCEEDS THE SIZE OF THE Z80 MEMORY SPACES AND
5630   0D9D             ; RESULTS IN UNDEFINED BEHAVIOR.
5631   0D9D             ;
5632   0D9D             ; THE COPY IS ALWAYS DONE FROM START TO END.  IF THE SOURCE AND
5633   0D9D             ; DESTINATION RANGES OVERLAP, THEN YOU MUST TAKE THIS INTO ACCOUNT.
5634   0D9D             ;
5635   0D9D             ; THE ROUTINE FUNCTIONS LOGICALLY LIKE THE Z80 LDIR INSTRUCTION.  ON
5636   0D9D             ; RETURN THE SOURCE (HL) AND DESTINATION (DE) REGISTERS WILL BE LEFT
5637   0D9D             ; POINTING TO THE NEXT BYTE THAT WOULD BE COPIED IF THE COPY ROUTINE
5638   0D9D             ; CONTINUED.  BC WILL BE 0.  AF IS UNDEFINED.
5639   0D9D             ;
5640   0D9D~            #IF (MEMMGR == MM_Z280)
5641   0D9D~            ;
5642   0D9D~            ; ADJUST THE LENGTH OF THE COPY SUCH THAT BOTH THE SOURCE AND
5643   0D9D~            ; DESTINATION RANGES DO NOT CROSS OVER THE BANKED/COMMON MEMORY
5644   0D9D~            ; BOUNDARY.  CALL Z280_BNKCPY TO DO AS MANY ITERATIONS AS NEEDED TO
5645   0D9D~            ; COMPLETE THE COPY.
5646   0D9D~            ;
5647   0D9D~            ;
5648   0D9D~            Z280_BNKCPYX:
5649   0D9D~            	LD	(Z280_BNKCPY_LEN),BC	; SAVE LENGTH
5650   0D9D~            ;
5651   0D9D~            	CALL	Z280_BNKCPY_XOVER	; ADJUST FOR XOVER AS NEEDED
5652   0D9D~            	EX	DE,HL			; SWAP SOURCE/DEST
5653   0D9D~            	CALL	Z280_BNKCPY_XOVER	; ADJUST FOR XOVER AS NEEDED
5654   0D9D~            	EX	DE,HL			; SWAP BACK
5655   0D9D~            ;
5656   0D9D~            	; DO THE WORK, SAVE THE LEN OF THIS ITERATION
5657   0D9D~            	PUSH	BC			; SAVE ITER LENGTH
5658   0D9D~            	CALL	Z280_BNKCPY		; DO THE WORK
5659   0D9D~            ;
5660   0D9D~            	;;; *DEBUG* SIMULATE CALL TO Z280_BNKCPY
5661   0D9D~            	;;CALL	NEWLINE
5662   0D9D~            	;;CALL	REGDMP			; *DEBUG*
5663   0D9D~            	;;ADD	HL,BC			; INCREMENT SRC ADR BY COUNT
5664   0D9D~            	;;EX	DE,HL			; SWAP
5665   0D9D~            	;;ADD	HL,BC			; INCREMENT DST ADR BY COUNT
5666   0D9D~            	;;EX	DE,HL			; SWAP BACK
5667   0D9D~            	;;LD	BC,0			; COUNT IS NOW ZERO
5668   0D9D~            	;;; END *DEBUG*
5669   0D9D~            ;
5670   0D9D~            	POP	BC			; RECOVER ITER LENGTH
5671   0D9D~            ;
5672   0D9D~            	; ACCUNT FOR WORK ACTUALLY PERFORMED
5673   0D9D~            	PUSH	HL			; SAVE SOURCE ADR
5674   0D9D~            	LD	HL,(Z280_BNKCPY_LEN)	; GET PENDING LENGTH
5675   0D9D~            	OR	A			; CLEAR CARRY
5676   0D9D~            	SBC	HL,BC			; SUBTRACT WHAT WE DID
5677   0D9D~            	PUSH	HL			; MOVE NEW PENDING LEN
5678   0D9D~            	POP	BC			; TO BC
5679   0D9D~            	POP	HL			; RECOVER SOURCE ADR
5680   0D9D~            ;
5681   0D9D~            	; SEE IF WE NEED TO ITERATE
5682   0D9D~            	LD	A,B			; IS LENGTH
5683   0D9D~            	OR	C			; ... NOW ZERO?
5684   0D9D~            	RET	Z			; IF SO, ALL DONE
5685   0D9D~            	JR	Z280_BNKCPYX		; ELSE ITERATE UNTIL DONE
5686   0D9D~            ;
5687   0D9D~            Z280_BNKCPY_LEN	.DW	0		; TEMP STORAGE FOR BC
5688   0D9D~            ;
5689   0D9D~            Z280_BNKCPY_XOVER:
5690   0D9D~            	; DETECT XOVER IN RANGE AND ADJUST COPY LEN IF SO
5691   0D9D~            	; HL=START, BC=LEN
5692   0D9D~            	; BC IS REDUCED AS NEEDED TO AVOID XOVER
5693   0D9D~            	BIT	7,H			; START ABOVE 32K?
5694   0D9D~            	RET	NZ			; YES, NO XOVER
5695   0D9D~            	PUSH	HL			; SAVE START ADR
5696   0D9D~            	ADD	HL,BC			; ADD COPY LEN
5697   0D9D~            	DEC	HL			; CONVERT TO "LAST" BYTE OF RANGE
5698   0D9D~            	BIT	7,H			; ABOVE 32K?
5699   0D9D~            	POP	HL			; RESTORE HL
5700   0D9D~            	RET	Z			; IF NOT, NO XOVER
5701   0D9D~            ;
5702   0D9D~            	; START IS BELOW 32K, END IS OVER 32K, XOVER IN SOURCE!
5703   0D9D~            	; REDUCE LENGTH TO AVOID IT
5704   0D9D~            	; COMPUTE (32K - START) FOR NEW LEN
5705   0D9D~            	PUSH	DE			; SAVE DEST (DE)
5706   0D9D~            	PUSH	HL			; SAVE START (HL)
5707   0D9D~            	LD	DE,$8000
5708   0D9D~            	EX	DE,HL			; DE=START, HL=32K
5709   0D9D~            	OR	A			; CLEAR CARRY
5710   0D9D~            	SBC	HL,DE			; HL = NEW LEN
5711   0D9D~            	PUSH	HL			; MOVE NEW LEN
5712   0D9D~            	POP	BC			; ... TO BC
5713   0D9D~            	POP	HL			; RECOVER START
5714   0D9D~            	POP	DE			; RECOVER DEST
5715   0D9D~            	RET				; RETURN
5716   0D9D~            ;
5717   0D9D~            Z280_BNKCPY:
5718   0D9D~            	; Z280 MEMORY TO MEMORY DMA
5719   0D9D~            	; USE FLOW THROUGH MODE
5720   0D9D~            	; SINGLE BYTE TRANSFER
5721   0D9D~            	; TRANSACTION DESCRIPTION REGISTER (TDR)
5722   0D9D~            	; %0000 0000 0000 0000
5723   0D9D~            	; - AUTO INCREMENT MEMORY
5724   0D9D~            	; - FLOWTHROUGH OPERATION
5725   0D9D~            	; - SINGLE TRANSACTION (CAN WE USE CONTINUOUS???)
5726   0D9D~            	; - 1 BYTE XFER SIZE
5727   0D9D~            ;
5728   0D9D~            	; SAVE INCOMING REGISTERS
5729   0D9D~            	PUSH	HL
5730   0D9D~            	PUSH	DE
5731   0D9D~            	PUSH	BC
5732   0D9D~            ;
5733   0D9D~            	PUSH	BC			; SAVE COUNT
5734   0D9D~            	PUSH	HL			; SAVE SOURCE ADDRESS
5735   0D9D~            ;
5736   0D9D~            	; SELECT I/O PAGE $FF
5737   0D9D~            	LD	C,Z280_IOPR		; I/O PAGE REGISTER
5738   0D9D~            	LDCTL	HL,(C)			; GET CURRENT I/O PAGE
5739   0D9D~            	LD	(IOPRSAV),HL		; SAVE IT
5740   0D9D~            	LD	L,$FF			; I/O PAGE $FF
5741   0D9D~            	LDCTL	(C),HL
5742   0D9D~            ;
5743   0D9D~            	LD	C,Z280_DMA0_DSTL	; START WITH DEST REG LO
5744   0D9D~            ;
5745   0D9D~            	LD	A,(HB_DSTBNK)		; DEST BANK TO ACCUM
5746   0D9D~            	CALL	Z2DMAADR		; SETUP DEST ADR REGS
5747   0D9D~            ;
5748   0D9D~            	POP	DE			; SRC ADR TO DE
5749   0D9D~            	LD	A,(HB_SRCBNK)		; DEST BANK TO ACCUM
5750   0D9D~            	CALL	Z2DMAADR		; SETUP SOURCE ADR REGS
5751   0D9D~            ;
5752   0D9D~            	POP	HL			; COUNT TO HL
5753   0D9D~            	OUTW	(C),HL
5754   0D9D~            	INC	C			; BUMP TO TDR
5755   0D9D~            ;
5756   0D9D~            	LD	HL,$8000		; ENABLE DMA0 TO RUN!
5757   0D9D~            	OUTW	(C),HL
5758   0D9D~            ;
5759   0D9D~            	; WAIT FOR XFER TO COMPLETE
5760   0D9D~            Z2DMALOOP:
5761   0D9D~            	INW	HL,(C)			; WORD INPUT
5762   0D9D~            	BIT	7,H			; CHECK EN BIT OF TDR
5763   0D9D~            	JR	NZ,Z2DMALOOP		; LOOP WHILE ACTIVE
5764   0D9D~            ;
5765   0D9D~            	; RESTORE I/O PAGE
5766   0D9D~            	LD	C,Z280_IOPR		; I/O PAGE REGISTER
5767   0D9D~            	LD	HL,(IOPRSAV)		; RESTORE I/O PAGE
5768   0D9D~            	LDCTL	(C),HL
5769   0D9D~            ;
5770   0D9D~            	; SETUP RETURN VALUES
5771   0D9D~            	POP	BC			; RECOVER ORIGINAL BC
5772   0D9D~            	POP	DE			; RECOVER ORIGINAL DE
5773   0D9D~            	POP	HL			; RECOVER ORIGINAL HL
5774   0D9D~            	ADD	HL,BC			; INCREMENT SRC ADR BY COUNT
5775   0D9D~            	EX	DE,HL			; SWAP
5776   0D9D~            	ADD	HL,BC			; INCREMENT DST ADR BY COUNT
5777   0D9D~            	EX	DE,HL			; SWAP BACK
5778   0D9D~            	LD	BC,0			; COUNT IS NOW ZERO
5779   0D9D~            ;
5780   0D9D~            	RET
5781   0D9D~            ;
5782   0D9D~            Z2DMAADR:
5783   0D9D~            	; SET ADDRESS REGISTERS, BANK IN A, ADDRESS IN DE
5784   0D9D~            	; C POINTS TO FIRST DMA ADR PORT TO SET
5785   0D9D~            	; A=R000 BBBB, DE=0AAA AAAA AAAA AAAA
5786   0D9D~            	; RC: DMA HI=0000 RBBB BAAA 1111 LO=1111 AAAA AAAA AAAA
5787   0D9D~            	; ZZ: DMA HI=R000 0BBB BAAA 1111 LO=1111 AAAA AAAA AAAA
5788   0D9D~            	BIT	7,D			; HIGH RAM?
5789   0D9D~            	JR	Z,Z2DMAADR1		; NO, SKIP
5790   0D9D~            	LD	A,$8F			; SUBSTITUTE COMMON RAM BANK ID
5791   0D9D~            ;
5792   0D9D~            Z2DMAADR1:
5793   0D9D~            	; ADR HI FROM A:DE
5794   0D9D~            	LD	L,D			; L=?AAA AAAA
5795   0D9D~            	LD	H,A			; H=R000 BBBB
5796   0D9D~            	SLA	L			; L=AAAA AAA0 ?
5797   0D9D~            	SRL	H			; H=0R00 0BBB B
5798   0D9D~            	RR	L			; L=BAAA AAAA 0
5799   0D9D~            	LD	A,$0F			; A=0000 1111
5800   0D9D~            	OR	L			; A=BAAA 1111
5801   0D9D~            	LD	L,A			; L=BAAA 1111
5802   0D9D~            ;
5803   0D9D~            	; MOVE THE RAM/ROM BIT.
5804   0D9D~            	; RCBUS DMA HI=0000 RBBB BAAA 1111 LO=1111 AAAA AAAA AAAA
5805   0D9D~            	; ZZ80MB DMA HI=R000 0BBB BAAA 1111 LO=1111 AAAA AAAA AAAA
5806   0D9D~            	BIT	6,H
5807   0D9D~            	JR	Z,Z2DMAADR2
5808   0D9D~            	RES	6,H
5809   0D9D~            	SET	RAMLOC-16,H
5810   0D9D~            ;
5811   0D9D~            Z2DMAADR2:
5812   0D9D~            	PUSH	HL			; SAVE IT FOR NOW
5813   0D9D~            
5814   0D9D~            	; ADR LO FROM DE:
5815   0D9D~            	LD	L,E			; L=AAAA AAAA
5816   0D9D~            	LD	A,$F0			; A=1111 0000
5817   0D9D~            	OR	D			; A=1111 AAAA
5818   0D9D~            	LD	H,A			; HL=1111 AAAA AAAA AAAA
5819   0D9D~            ;
5820   0D9D~            	; SET ADR LO REG
5821   0D9D~            	OUTW	(C),HL
5822   0D9D~            	INC	C			; BUMP TO ADR HI REG
5823   0D9D~            ;
5824   0D9D~            	; SET ADR HI REG
5825   0D9D~            	POP	HL			; RECOVER THE HI VAL
5826   0D9D~            	OUTW	(C),HL
5827   0D9D~            	INC	C			; BUMP TO NEXT REG
5828   0D9D~            ;
5829   0D9D~            	RET
5830   0D9D~            ;
5831   0D9D             #ENDIF
5832   0D9D             ;
5833   0D9D             ; Z280 SYSCALL VECTOR ENTRY POINT.  TAKES STACK PARAMETER AS A BRANCH
5834   0D9D             ; ADDRESS AND CALLS IT.  ALLOWS ANY USER MODE CODE TO CALL INTO AN
5835   0D9D             ; ARBITRARY LOCATION OF SYSTEM MODE CODE.
5836   0D9D             ;
5837   0D9D~            #IF (MEMMGR == MM_Z280)
5838   0D9D~            Z280_SYSCALL:
5839   0D9D~            	EX	(SP),HL
5840   0D9D~            	LD	(Z280_SYSCALL_GO+1),HL
5841   0D9D~            	POP	HL
5842   0D9D~            Z280_SYSCALL_GO:
5843   0D9D~            	CALL	$FFFF			; PARM SET ABOVE
5844   0D9D~            	RETIL				; RETURN FROM INT
5845   0D9D             #ENDIF
5846   0D9D             ;
5847   0D9D             ;==================================================================================================
5848   0D9D             ;   DEVICE DRIVERS
5849   0D9D             ;==================================================================================================
5850   0D9D             ;
5851   0D9D~            #IF (DSRTCENABLE)
5852   0D9D~            ORG_DSRTC	.EQU	$
5853   0D9D~              #INCLUDE "dsrtc.asm"
5854   0D9D~            SIZ_DSRTC	.EQU	$ - ORG_DSRTC
5855   0D9D~            		.ECHO	"DSRTC occupies "
5856   0D9D~            		.ECHO	SIZ_DSRTC
5857   0D9D~            		.ECHO	" bytes.\n"
5858   0D9D             #ENDIF
5859   0D9D             ;
5860   0D9D~            #IF (DS1501RTCENABLE)
5861   0D9D~            ORG_DS1501RTC	.EQU	$
5862   0D9D~              #INCLUDE "ds1501rtc.asm"
5863   0D9D~            SIZ_DS1501RTC	.EQU	$ - ORG_DS1501RTC
5864   0D9D~            		.ECHO	"DS1501RTC occupies "
5865   0D9D~            		.ECHO	SIZ_DS1501RTC
5866   0D9D~            		.ECHO	" bytes.\n"
5867   0D9D             #ENDIF
5868   0D9D             ;
5869   0D9D~            #IF (BQRTCENABLE)
5870   0D9D~            ORG_BQRTC	.EQU	$
5871   0D9D~              #INCLUDE "bqrtc.asm"
5872   0D9D~            SIZ_BQRTC	.EQU	$ - ORG_BQRTC
5873   0D9D~            		.ECHO	"BQRTC occupies "
5874   0D9D~            		.ECHO	SIZ_BQRTC
5875   0D9D~            		.ECHO	" bytes.\n"
5876   0D9D             #ENDIF
5877   0D9D~            #IF (SIMRTCENABLE)
5878   0D9D~            ORG_SIMRTC	.EQU	$
5879   0D9D~              #INCLUDE "simrtc.asm"
5880   0D9D~            SIZ_SIMRTC	.EQU	$ - ORG_SIMRTC
5881   0D9D~            		.ECHO	"SIMRTC occupies "
5882   0D9D~            		.ECHO	SIZ_SIMRTC
5883   0D9D~            		.ECHO	" bytes.\n"
5884   0D9D             #ENDIF
5885   0D9D~            #IF (DS7RTCENABLE & (DS7RTCMODE=DS7RTCMODE_PCF))
5886   0D9D~            ORG_PCF8584	.EQU	$
5887   0D9D~              #INCLUDE "pcf8584.asm"
5888   0D9D~            SIZ_PCF8584	.EQU	$ - ORG_PCF8584
5889   0D9D~            		.ECHO	"PCF8584 occupies "
5890   0D9D~            		.ECHO	SIZ_PCF8584
5891   0D9D~            		.ECHO	" bytes.\n"
5892   0D9D             #ENDIF
5893   0D9D             
5894   0D9D~            #IF (DS7RTCENABLE)
5895   0D9D~            ORG_DS7RTC	.EQU	$
5896   0D9D~              #INCLUDE "ds7rtc.asm"
5897   0D9D~            SIZ_DS7RTC	.EQU	$ - ORG_DS7RTC
5898   0D9D~            		.ECHO	"DS7RTC occupies "
5899   0D9D~            		.ECHO	SIZ_DS7RTC
5900   0D9D~            		.ECHO	" bytes.\n"
5901   0D9D             #ENDIF
5902   0D9D             ;
5903   0D9D~            #IF (INTRTCENABLE)
5904   0D9D~            ORG_INTRTC	.EQU	$
5905   0D9D~              #INCLUDE "intrtc.asm"
5906   0D9D~            SIZ_INTRTC	.EQU	$ - ORG_INTRTC
5907   0D9D~            		.ECHO	"INTRTC occupies "
5908   0D9D~            		.ECHO	SIZ_INTRTC
5909   0D9D~            		.ECHO	" bytes.\n"
5910   0D9D             #ENDIF
5911   0D9D             ;
5912   0D9D~            #IF (RP5RTCENABLE)
5913   0D9D~            ORG_RP5RTC	.EQU	$
5914   0D9D~              #INCLUDE "rp5rtc.asm"
5915   0D9D~            SIZ_RP5RTC	.EQU	$ - ORG_RP5RTC
5916   0D9D~            		.ECHO	"RP5RTC occupies "
5917   0D9D~            		.ECHO	SIZ_RP5RTC
5918   0D9D~            		.ECHO	" bytes.\n"
5919   0D9D             #ENDIF
5920   0D9D~            #IF (ASCIENABLE)
5921   0D9D~            ORG_ASCI	.EQU	$
5922   0D9D~              #INCLUDE "asci.asm"
5923   0D9D~            SIZ_ASCI	.EQU	$ - ORG_ASCI
5924   0D9D~            		.ECHO	"ASCI occupies "
5925   0D9D~            		.ECHO	SIZ_ASCI
5926   0D9D~            		.ECHO	" bytes.\n"
5927   0D9D             #ENDIF
5928   0D9D             ;
5929   0D9D~            #IF (Z2UENABLE)
5930   0D9D~            ORG_Z2U	.EQU	$
5931   0D9D~              #INCLUDE "z2u.asm"
5932   0D9D~            SIZ_Z2U	.EQU	$ - ORG_Z2U
5933   0D9D~            		.ECHO	"Z2U occupies "
5934   0D9D~            		.ECHO	SIZ_Z2U
5935   0D9D~            		.ECHO	" bytes.\n"
5936   0D9D             #ENDIF
5937   0D9D             ;
5938   0D9D             #IF (UARTENABLE)
5939   0D9D             ORG_UART	.EQU	$
5940   0D9D               #INCLUDE "uart.asm"
0001+  0D9D             ;
0002+  0D9D             ;==================================================================================================
0003+  0D9D             ; UART DRIVER (SERIAL PORT)
0004+  0D9D             ;==================================================================================================
0005+  0D9D             ;
0006+  0D9D             ;  SETUP PARAMETER WORD:
0007+  0D9D             ;  +-------+---+-------------------+ +---+---+-----------+---+-------+
0008+  0D9D             ;  |       |RTS| ENCODED BAUD RATE | |DTR|XON|  PARITY   |STP| 8/7/6 |
0009+  0D9D             ;  +-------+---+---+---------------+ ----+---+-----------+---+-------+
0010+  0D9D             ;    F   E   D   C   B   A   9   8     7   6   5   4   3   2   1   0
0011+  0D9D             ;       -- MSB (D REGISTER) --           -- LSB (E REGISTER) --
0012+  0D9D             ;
0013+  0D9D             ;  UART CONFIGURATION REGISTERS:
0014+  0D9D             ;  +-------+---+-------------------+ +---+---+-----------+---+-------+
0015+  0D9D             ;  | 0   0 |AFE|LP  OT2 OT1 RTS DTR| |DLB|BRK|STK EPS PEN|STB|  WLS  |
0016+  0D9D             ;  +-------+---+-------------------+ +---+---+-----------+---+-------+
0017+  0D9D             ;    F   E   D   C   B   A   9   8     7   6   5   4   3   2   1   0
0018+  0D9D             ;              -- MCR --                        -- LCR --
0019+  0D9D             ;
0020+  0D9D             ;
0021+  0D9D             UART_DEBUG		.EQU	FALSE
0022+  0D9D             ;
0023+  0D9D             UART_BUFSZ		.EQU	32	; RECEIVE RING BUFFER SIZE
0024+  0D9D             ;
0025+  0D9D             UART_NONE		.EQU	0	; UNKNOWN OR NOT PRESENT
0026+  0D9D             UART_8250		.EQU	1
0027+  0D9D             UART_16450		.EQU	2
0028+  0D9D             UART_16550		.EQU	3
0029+  0D9D             UART_16550A		.EQU	4
0030+  0D9D             UART_16550C		.EQU	5
0031+  0D9D             UART_16650		.EQU	6
0032+  0D9D             UART_16750		.EQU	7
0033+  0D9D             UART_16850		.EQU	8
0034+  0D9D             ;
0035+  0D9D             UART_RBR		.EQU	0	; DLAB=0: RCVR BUFFER REG (READ)
0036+  0D9D             UART_THR		.EQU	0	; DLAB=0: XMIT HOLDING REG (WRITE)
0037+  0D9D             UART_IER		.EQU	1	; DLAB=0: INT ENABLE REG (READ)
0038+  0D9D             UART_IIR		.EQU	2	; INT IDENT REGISTER (READ)
0039+  0D9D             UART_FCR		.EQU	2	; FIFO CONTROL REG (WRITE)
0040+  0D9D             UART_LCR		.EQU	3	; LINE CONTROL REG (READ/WRITE)
0041+  0D9D             UART_MCR		.EQU	4	; MODEM CONTROL REG (READ/WRITE)
0042+  0D9D             UART_LSR		.EQU	5	; LINE STATUS REG (READ)
0043+  0D9D             UART_MSR		.EQU	6	; MODEM STATUS REG (READ)
0044+  0D9D             UART_SCR		.EQU	7	; SCRATCH REGISTER (READ/WRITE)
0045+  0D9D             UART_DLL		.EQU	0	; DLAB=1: DIVISOR LATCH (LS) (READ/WRITE)
0046+  0D9D             UART_DLM		.EQU	1	; DLAB=1: DIVISOR LATCH (MS) (READ/WRITE)
0047+  0D9D             UART_EFR		.EQU	2	; LCR=$BF: ENHANCED FEATURE REG (READ/WRITE)
0048+  0D9D             ;
0049+  0D9D             ; THESE BITS ARE SET IN THE UART TYPE BYTE TO FURTHER
0050+  0D9D             ; IDENTIFY THE FEATURES OF THE CHIP
0051+  0D9D             ;
0052+  0D9D             UART_INTACT		.EQU	7	; INT RCV ACTIVE BIT
0053+  0D9D             UART_FIFOACT		.EQU	6	; FIFO ACTIVE BIT
0054+  0D9D             UART_AFCACT		.EQU	5	; AUTO FLOW CONTROL ACTIVE BIT
0055+  0D9D             ;
0056+  0D9D             UARTSBASE		.EQU	$68
0057+  0D9D             UARTCBASE		.EQU	$80
0058+  0D9D             UARTMBASE		.EQU	$18
0059+  0D9D             UART4BASE		.EQU	$C0
0060+  0D9D             UARTRBASE		.EQU	$A0
0061+  0D9D             UARTDBASE		.EQU	$80
0062+  0D9D             UARTHBASE		.EQU	$E8
0063+  0D9D             ;
0064+  0D9D~            #IF (UARTINTS)
0065+  0D9D~            ;
0066+  0D9D~              #IF ((INTMODE == 2) | (INTMODE == 3))
0067+  0D9D~            ;
0068+  0D9D~            UART0_IVT	.EQU	IVT(INT_UART0)
0069+  0D9D~            UART1_IVT	.EQU	IVT(INT_UART1)
0070+  0D9D~            ;
0071+  0D9D~              #ENDIF
0072+  0D9D~            ;
0073+  0D9D             #ENDIF
0074+  0D9D             
0075+  0D9D             ;
0076+  0D9D             #DEFINE	UART_INP(RID)	CALL UART_INP_IMP \ .DB RID
0077+  0D9D             #DEFINE	UART_OUTP(RID)	CALL UART_OUTP_IMP \ .DB RID
0078+  0D9D             ;
0079+  0D9D             ;
0080+  0D9D             ;
0081+  0D9D             UART_PREINIT:
0082+  0D9D~            #IF (UART4)
0083+  0D9D~            ;
0084+  0D9D~            ; INIT UART4 BOARD CONFIG REGISTER (NO HARM IF IT IS NOT THERE)
0085+  0D9D~            ;
0086+  0D9D~            	LD	A,$80			; SELECT 7.3728MHZ OSC & LOCK CONFIG REGISTER
0087+  0D9D~            	OUT	(UART4BASE+$0F),A	; DO IT
0088+  0D9D             #ENDIF
0089+  0D9D             ;
0090+  0D9D             ; SETUP THE DISPATCH TABLE ENTRIES
0091+  0D9D             ;
0092+  0D9D 06 02       	LD	B,UART_CNT		; LOOP CONTROL
0093+  0D9F 0E 00       	LD	C,0			; PHYSICAL UNIT INDEX
0094+  0DA1 AF          	XOR	A			; ZERO TO ACCUM
0095+  0DA2 32 92 10    	LD	(UART_DEV),A		; CURRENT DEVICE NUMBER
0096+  0DA5             UART_PREINIT0:	
0097+  0DA5 C5          	PUSH	BC			; SAVE LOOP CONTROL
0098+  0DA6 79          	LD	A,C			; PHYSICAL UNIT TO A
0099+  0DA7 07          	RLCA				; MULTIPLY BY CFG TABLE ENTRY SIZE (8 BYTES)
0100+  0DA8 07          	RLCA				; ...
0101+  0DA9 07          	RLCA				; ... TO GET OFFSET INTO CFG TABLE
0102+  0DAA 21 93 10    	LD	HL,UART_CFG		; POINT TO START OF CFG TABLE
0103+  0DAD CD D2 1A    	CALL	ADDHLA			; HL := ENTRY ADDRESS
0104+  0DB0 E5          	PUSH	HL			; SAVE IT
0105+  0DB1 E5          	PUSH	HL			; COPY CFG DATA PTR
0106+  0DB2 FD E1       	POP	IY			; ... TO IY
0107+  0DB4 CD CC 0D    	CALL	UART_INITUNIT		; HAND OFF TO GENERIC INIT CODE
0108+  0DB7 D1          	POP	DE			; GET ENTRY ADDRESS BACK, BUT PUT IN DE
0109+  0DB8 C1          	POP	BC			; RESTORE LOOP CONTROL
0110+  0DB9             ;
0111+  0DB9 FD 7E 01    	LD	A,(IY+1)		; GET THE UART TYPE DETECTED
0112+  0DBC B7          	OR	A			; SET FLAGS
0113+  0DBD 28 08       	JR	Z,UART_PREINIT2		; SKIP IT IF NOTHING FOUND
0114+  0DBF             ;	
0115+  0DBF C5          	PUSH	BC			; SAVE LOOP CONTROL
0116+  0DC0 01 01 0E    	LD	BC,UART_FNTBL		; BC := FUNCTION TABLE ADDRESS
0117+  0DC3 C4 C5 07    	CALL	NZ,CIO_ADDENT		; ADD ENTRY IF UART FOUND, BC:DE
0118+  0DC6 C1          	POP	BC			; RESTORE LOOP CONTROL
0119+  0DC7             ;
0120+  0DC7             UART_PREINIT2:	
0121+  0DC7 0C          	INC	C			; NEXT PHYSICAL UNIT
0122+  0DC8 10 DB       	DJNZ	UART_PREINIT0		; LOOP UNTIL DONE
0123+  0DCA             ;
0124+  0DCA~            #IF ((UARTINTS) & (INTMODE > 0))
0125+  0DCA~            	; *** FIXME *** WE SHOULD CHECK TO SEE IF ANY UNITS ARE ACTUALLY
0126+  0DCA~            	; USING INT RCV.  IF NOT, WE SHOULD NOT HOOK IM1!!!
0127+  0DCA~            ;
0128+  0DCA~            	; SETUP INT VECTORS AS APPROPRIATE
0129+  0DCA~            	LD	A,(UART_DEV)		; GET DEVICE COUNT
0130+  0DCA~            	OR	A			; SET FLAGS
0131+  0DCA~            	JR	Z,UART_PREINIT3		; IF ZERO, NO UART DEVICES, ABORT
0132+  0DCA~            ;
0133+  0DCA~              #IF (INTMODE == 1)
0134+  0DCA~            	; ADD IM1 INT CALL LIST ENTRY
0135+  0DCA~            	LD	HL,UART_INT		; GET INT VECTOR
0136+  0DCA~            	CALL	HB_ADDIM1		; ADD TO IM1 CALL LIST
0137+  0DCA~              #ENDIF
0138+  0DCA~            ;
0139+  0DCA~              #IF ((INTMODE == 2) | (INTMODE == 3))
0140+  0DCA~            	; SETUP IM2/3 VECTORS
0141+  0DCA~                #IF (UARTSBC)
0142+  0DCA~            	LD	HL,UART_INTSBC
0143+  0DCA~            	LD	(UART0_IVT),HL		; IVT INDEX
0144+  0DCA~                #ENDIF
0145+  0DCA~            ;
0146+  0DCA~                #IF (UARTCAS)
0147+  0DCA~            	LD	HL,UART_INTCAS
0148+  0DCA~            	LD	(UART1_IVT),HL		; IVT INDEX
0149+  0DCA~                #ENDIF
0150+  0DCA~            ;
0151+  0DCA~              #ENDIF
0152+  0DCA~            ;
0153+  0DCA             #ENDIF
0154+  0DCA             ;
0155+  0DCA             UART_PREINIT3:
0156+  0DCA AF          	XOR	A			; SIGNAL SUCCESS
0157+  0DCB C9          	RET				; AND RETURN
0158+  0DCC             ;
0159+  0DCC             ; UART INITIALIZATION ROUTINE
0160+  0DCC             ;
0161+  0DCC             UART_INITUNIT:
0162+  0DCC             	; DETECT THE UART TYPE
0163+  0DCC CD E8 0E    	CALL	UART_DETECT		; DETERMINE UART TYPE
0164+  0DCF FD 77 01    	LD	(IY+1),A		; AND SAVE IN CONFIG TABLE
0165+  0DD2 B7          	OR	A			; SET FLAGS
0166+  0DD3 C8          	RET	Z			; ABORT IF NOTHING THERE
0167+  0DD4             ;
0168+  0DD4             	; UPDATE WORKING UART DEVICE NUM
0169+  0DD4 21 92 10    	LD	HL,UART_DEV		; POINT TO CURRENT UART DEVICE NUM
0170+  0DD7 7E          	LD	A,(HL)			; PUT IN ACCUM
0171+  0DD8 34          	INC	(HL)			; INCREMENT IT (FOR NEXT LOOP)
0172+  0DD9 FD 77 00    	LD	(IY),A			; UDPATE UNIT NUM
0173+  0DDC             ;	
0174+  0DDC             	; SET DEFAULT CONFIG
0175+  0DDC 11 FF FF    	LD	DE,-1			; LEAVE CONFIG ALONE
0176+  0DDF C3 47 0E    	JP	UART_INITDEVX		; IMPLEMENT IT AND RETURN
0177+  0DE2             ;
0178+  0DE2             ;
0179+  0DE2             ;
0180+  0DE2             UART_INIT:
0181+  0DE2 06 02       	LD	B,UART_CNT		; COUNT OF POSSIBLE UART UNITS
0182+  0DE4 0E 00       	LD	C,0			; INDEX INTO UART CONFIG TABLE
0183+  0DE6             UART_INIT1:
0184+  0DE6 C5          	PUSH	BC			; SAVE LOOP CONTROL
0185+  0DE7             	
0186+  0DE7 79          	LD	A,C			; PHYSICAL UNIT TO A
0187+  0DE8 07          	RLCA				; MULTIPLY BY CFG TABLE ENTRY SIZE (8 BYTES)
0188+  0DE9 07          	RLCA				; ...
0189+  0DEA 07          	RLCA				; ... TO GET OFFSET INTO CFG TABLE
0190+  0DEB 21 93 10    	LD	HL,UART_CFG		; POINT TO START OF CFG TABLE
0191+  0DEE CD D2 1A    	CALL	ADDHLA			; HL := ENTRY ADDRESS
0192+  0DF1 E5          	PUSH	HL			; COPY CFG DATA PTR
0193+  0DF2 FD E1       	POP	IY			; ... TO IY
0194+  0DF4             	
0195+  0DF4 FD 7E 01    	LD	A,(IY+1)		; GET UART TYPE
0196+  0DF7 B7          	OR	A			; SET FLAGS
0197+  0DF8 C4 A2 0F    	CALL	NZ,UART_PRTCFG		; PRINT IF NOT ZERO
0198+  0DFB             
0199+  0DFB C1          	POP	BC			; RESTORE LOOP CONTROL
0200+  0DFC 0C          	INC	C			; NEXT UNIT
0201+  0DFD 10 E7       	DJNZ	UART_INIT1		; LOOP TILL DONE
0202+  0DFF             ;
0203+  0DFF AF          	XOR	A			; SIGNAL SUCCESS
0204+  0E00 C9          	RET				; DONE
0205+  0E01             ;
0206+  0E01             ; RECEIVE INTERRUPT HANDLER
0207+  0E01             ;
0208+  0E01~            #IF ((UARTINTS) & (INTMODE > 0))
0209+  0E01~            ;
0210+  0E01~            ; IM1 ENTRY POINT
0211+  0E01~            ;
0212+  0E01~            ; POLL ALL DEVICES THAT MIGHT ENABLE INTERRUPT DRIVEN
0213+  0E01~            ; RECEIVE.  HANDLE FIRST INTERRUPT ENCOUNTERED (IF ANY).
0214+  0E01~            ; MOST BOARDS REQUIRE UARTS THAT WILL HAVE AFC.  THE
0215+  0E01~            ; ONLY BOARDS THAT MAY NOT ARE THE SBC AND THE CAS.
0216+  0E01~            ;
0217+  0E01~            ; THIS COULD BE IMPROVED BY DYNAMICALLY SETTING UP THE
0218+  0E01~            ; POLLING CHAIN WHEN DEVICES ARE INITIALIZED SUCH THAT
0219+  0E01~            ; ONLY DEVICES ACTUALLY USING INTS ARE POLLED HERE.
0220+  0E01~            ;
0221+  0E01~              #IF (INTMODE == 1)
0222+  0E01~            
0223+  0E01~            UART_INT:
0224+  0E01~            ;
0225+  0E01~                #IF (UARTSBC)
0226+  0E01~            	LD	IY,UART_CFG_SBC
0227+  0E01~            	CALL	UART_INTRCV
0228+  0E01~            	RET	NZ
0229+  0E01~                #ENDIF
0230+  0E01~            ;
0231+  0E01~                #IF (UARTCAS)
0232+  0E01~            	LD	IY,UART_CFG_CAS
0233+  0E01~            	CALL	UART_INTRCV
0234+  0E01~            	RET	NZ
0235+  0E01~                #ENDIF
0236+  0E01~            ;
0237+  0E01~              #ENDIF
0238+  0E01~            ;
0239+  0E01~              #IF ((INTMODE == 2) | (INTMODE == 3))
0240+  0E01~            ;
0241+  0E01~                #IF (UARTSBC)
0242+  0E01~            UART_INTSBC:
0243+  0E01~            	LD	IY,UART_CFG_SBC
0244+  0E01~            	JR	UART_INTRCV
0245+  0E01~                #ENDIF
0246+  0E01~            ;
0247+  0E01~                #IF (UARTCAS)
0248+  0E01~            UART_INTCAS:
0249+  0E01~            	LD	IY,UART_CFG_CAS
0250+  0E01~            	JR	UART_INTRCV
0251+  0E01~                #ENDIF
0252+  0E01~            ;
0253+  0E01~              #ENDIF
0254+  0E01~            ;
0255+  0E01~            	XOR	A			; CLEAR ACCUM (INT NOT HANDLED)
0256+  0E01~            	RET				; DONE
0257+  0E01~            ;
0258+  0E01~            ; IM2 ENTRY POINTS
0259+  0E01~            ;
0260+  0E01~            
0261+  0E01~            ;
0262+  0E01~            ; HANDLE INT FOR A SPECIFIC CHANNEL
0263+  0E01~            ; BASED ON UNIT CFG POINTED TO BY IY
0264+  0E01~            ;
0265+  0E01~            UART_INTRCV:
0266+  0E01~            	; ARE INTERRUPTS IN USE ON THIS DEVICE?
0267+  0E01~            	LD	A,(IY+1)		; GET UART TYPE
0268+  0E01~            	AND	%10000000		; ISOLATE INT RCV BIT
0269+  0E01~            	RET	Z			; INTS NOT SUPPORTED
0270+  0E01~            	; CHECK TO SEE IF SOMETHING IS ACTUALLY THERE
0271+  0E01~            	LD	C,(IY+3)		; STATUS PORT TO C
0272+  0E01~            	IN	A,(C)			; GET LSR
0273+  0E01~            	AND	$01			; ISOLATE RECEIVE READY BIT
0274+  0E01~            	RET	Z			; NOTHING AVAILABLE ON CURRENT CHANNEL
0275+  0E01~            ;
0276+  0E01~            UART_INTRCV1:
0277+  0E01~            	; RECEIVE CHARACTER INTO BUFFER
0278+  0E01~            	LD	C,(IY+2)		; DATA PORT TO C
0279+  0E01~            	IN	A,(C)			; READ PORT
0280+  0E01~            	LD	B,A			; SAVE BYTE READ
0281+  0E01~            	LD	L,(IY+6)		; SET HL TO
0282+  0E01~            	LD	H,(IY+7)		; ... START OF BUFFER STRUCT
0283+  0E01~            	LD	A,(HL)			; GET COUNT
0284+  0E01~            	CP	UART_BUFSZ		; COMPARE TO BUFFER SIZE
0285+  0E01~            	JR	Z,UART_INTRCV4		; BAIL OUT IF BUFFER FULL, RCV BYTE DISCARDED
0286+  0E01~            	INC	A			; INCREMENT THE COUNT
0287+  0E01~            	LD	(HL),A			; AND SAVE IT
0288+  0E01~            
0289+  0E01~            
0290+  0E01~            	; *** FIXME *** THE FOLLOWING SHOULD ONLY BE DONE IF RTS FLOW CONTROL IS ON!!!
0291+  0E01~            	; SOMETHING LIKE THIS MAY WORK...
0292+  0E01~            	;BIT	5,(IY+5)
0293+  0E01~            	;JR	Z,UART_INTRCV2
0294+  0E01~            	
0295+  0E01~            	
0296+  0E01~            	CP	UART_BUFSZ / 2		; BUFFER GETTING FULL?
0297+  0E01~            	JR	NZ,UART_INTRCV2		; IF NOT, BYPASS CLEARING RTS
0298+  0E01~            	LD	C,(IY+3)		; LSR PORT TO C
0299+  0E01~            	DEC	C			; POINT TO MCR PORT
0300+  0E01~            	IN	A,(C)			; GET MCR VALUE
0301+  0E01~            	AND	~%00000010		; CLEAR RTS
0302+  0E01~            	OUT	(C),A			; AND SAVE IT
0303+  0E01~            ;	
0304+  0E01~            UART_INTRCV2:
0305+  0E01~            	INC	HL			; HL NOW HAS ADR OF HEAD PTR
0306+  0E01~            	PUSH	HL			; SAVE ADR OF HEAD PTR
0307+  0E01~            	LD	A,(HL)			; DEREFERENCE HL
0308+  0E01~            	INC	HL
0309+  0E01~            	LD	H,(HL)
0310+  0E01~            	LD	L,A			; HL IS NOW ACTUAL HEAD PTR
0311+  0E01~            	LD	(HL),B			; SAVE CHARACTER RECEIVED IN BUFFER AT HEAD
0312+  0E01~            	INC	HL			; BUMP HEAD POINTER
0313+  0E01~            	POP	DE			; RECOVER ADR OF HEAD PTR
0314+  0E01~            	LD	A,L			; GET LOW BYTE OF HEAD PTR
0315+  0E01~            	SUB	UART_BUFSZ+4		; SUBTRACT SIZE OF BUFFER AND POINTER
0316+  0E01~            	CP	E			; IF EQUAL TO START, HEAD PTR IS PAST BUF END
0317+  0E01~            	JR	NZ,UART_INTRCV3		; IF NOT, BYPASS
0318+  0E01~            	LD	H,D			; SET HL TO
0319+  0E01~            	LD	L,E			; ... HEAD PTR ADR
0320+  0E01~            	INC	HL			; BUMP PAST HEAD PTR
0321+  0E01~            	INC	HL
0322+  0E01~            	INC	HL
0323+  0E01~            	INC	HL			; ... SO HL NOW HAS ADR OF ACTUAL BUFFER START
0324+  0E01~            UART_INTRCV3:
0325+  0E01~            	EX	DE,HL			; DE := HEAD PTR VAL, HL := ADR OF HEAD PTR
0326+  0E01~            	LD	(HL),E			; SAVE UPDATED HEAD PTR
0327+  0E01~            	INC	HL
0328+  0E01~            	LD	(HL),D
0329+  0E01~            	; CHECK FOR MORE PENDING...
0330+  0E01~            	LD	C,(IY+3)		; STATUS PORT TO C
0331+  0E01~            	IN	A,(C)			; GET LSR
0332+  0E01~            	AND	$01			; ISOLATE RECEIVE READY BIT
0333+  0E01~            	JR	NZ,UART_INTRCV1		; IF SET, DO SOME MORE
0334+  0E01~            UART_INTRCV4:
0335+  0E01~            	OR	$FF			; NZ SET TO INDICATE INT HANDLED
0336+  0E01~            	RET
0337+  0E01~            ;
0338+  0E01             #ENDIF
0339+  0E01             ;
0340+  0E01             ; DRIVER FUNCTION TABLE
0341+  0E01             ;
0342+  0E01             UART_FNTBL:
0343+  0E01 0F 0E       	.DW	UART_IN
0344+  0E03 1B 0E       	.DW	UART_OUT
0345+  0E05 27 0E       	.DW	UART_IST
0346+  0E07 34 0E       	.DW	UART_OST
0347+  0E09 41 0E       	.DW	UART_INITDEV
0348+  0E0B D1 0E       	.DW	UART_QUERY
0349+  0E0D D9 0E       	.DW	UART_DEVICE
0350+  0E0F~            #IF (($ - UART_FNTBL) != (CIO_FNCNT * 2))
0351+  0E0F~            	.ECHO	"*** INVALID UART FUNCTION TABLE ***\n"
0352+  0E0F             #ENDIF
0353+  0E0F             ;
0354+  0E0F             ;
0355+  0E0F             ;
0356+  0E0F             UART_IN:
0357+  0E0F CD 27 0E    	CALL	UART_IST		; RECEIVED CHAR READY?
0358+  0E12 28 FB       	JR	Z,UART_IN		; LOOP IF NOT
0359+  0E14~            #IF ((UARTINTS) & (INTMODE > 0))
0360+  0E14~            	BIT	UART_INTACT,(IY+1)	; INT RCV BIT
0361+  0E14~            	JR	Z,UART_IN1		; NORMAL INPUT IF NOT SET
0362+  0E14~            	JR	UART_INTIN		; INT RCV INPUT
0363+  0E14             #ENDIF
0364+  0E14             ;
0365+  0E14             UART_IN1:
0366+  0E14 FD 4E 02    	LD	C,(IY+2)		; C := BASE UART PORT (WHICH IS ALSO RBR REG)
0367+  0E17 ED 58       	IN	E,(C)			; CHAR READ TO E
0368+  0E19 AF          	XOR	A			; SIGNAL SUCCESS
0369+  0E1A C9          	RET				; AND DONE
0370+  0E1B             ;
0371+  0E1B~            #IF ((UARTINTS) & (INTMODE > 0))
0372+  0E1B~            ;
0373+  0E1B~            UART_INTIN:
0374+  0E1B~            	HB_DI				; AVOID COLLISION WITH INT HANDLER
0375+  0E1B~            	LD	L,(IY+6)		; SET HL TO
0376+  0E1B~            	LD	H,(IY+7)		; ... START OF BUFFER STRUCT
0377+  0E1B~            	LD	A,(HL)			; GET COUNT
0378+  0E1B~            	DEC	A			; DECREMENT COUNT
0379+  0E1B~            	LD	(HL),A			; SAVE UPDATED COUNT
0380+  0E1B~            	
0381+  0E1B~            	
0382+  0E1B~            	; *** FIXME *** THE FOLLOWING SHOULD ONLY BE DONE IF RTS FLOW CONTROL IS ON!!!
0383+  0E1B~            	; SOMETHING LIKE THIS MAY WORK...
0384+  0E1B~            	;BIT	5,(IY+5)
0385+  0E1B~            	;JR	Z,UART_INTIN1
0386+  0E1B~            
0387+  0E1B~            	
0388+  0E1B~            	CP	UART_BUFSZ / 4		; BUFFER LOW THRESHOLD
0389+  0E1B~            	JR	NZ,UART_INTIN1		; IF NOT, BYPASS SETTING RTS
0390+  0E1B~            	LD	C,(IY+3)		; LSR PORT TO C
0391+  0E1B~            	DEC	C			; POINT TO MCR PORT
0392+  0E1B~            	IN	A,(C)			; GET MCR VALUE
0393+  0E1B~            	OR	%00000010		; SET RTS
0394+  0E1B~            	OUT	(C),A			; AND SAVE IT
0395+  0E1B~            ;
0396+  0E1B~            UART_INTIN1:
0397+  0E1B~            	INC	HL
0398+  0E1B~            	INC	HL
0399+  0E1B~            	INC	HL			; HL NOW HAS ADR OF TAIL PTR
0400+  0E1B~            	PUSH	HL			; SAVE ADR OF TAIL PTR
0401+  0E1B~            	LD	A,(HL)			; DEREFERENCE HL
0402+  0E1B~            	INC	HL
0403+  0E1B~            	LD	H,(HL)
0404+  0E1B~            	LD	L,A			; HL IS NOW ACTUAL TAIL PTR
0405+  0E1B~            	LD	C,(HL)			; C := CHAR TO BE RETURNED
0406+  0E1B~            	INC	HL			; BUMP TAIL PTR
0407+  0E1B~            	POP	DE			; RECOVER ADR OF TAIL PTR
0408+  0E1B~            	LD	A,L			; GET LOW BYTE OF TAIL PTR
0409+  0E1B~            	SUB	UART_BUFSZ+2		; SUBTRACT SIZE OF BUFFER AND POINTER
0410+  0E1B~            	CP	E			; IF EQUAL TO START, TAIL PTR IS PAST BUF END
0411+  0E1B~            	JR	NZ,UART_INTIN2		; IF NOT, BYPASS
0412+  0E1B~            	LD	H,D			; SET HL TO
0413+  0E1B~            	LD	L,E			; ... TAIL PTR ADR
0414+  0E1B~            	INC	HL			; BUMP PAST TAIL PTR
0415+  0E1B~            	INC	HL			; ... SO HL NOW HAS ADR OF ACTUAL BUFFER START
0416+  0E1B~            UART_INTIN2:
0417+  0E1B~            	EX	DE,HL			; DE := TAIL PTR VAL, HL := ADR OF TAIL PTR
0418+  0E1B~            	LD	(HL),E			; SAVE UPDATED TAIL PTR
0419+  0E1B~            	INC	HL
0420+  0E1B~            	LD	(HL),D
0421+  0E1B~            	LD	E,C			; MOVE CHAR TO RETURN TO E
0422+  0E1B~            	HB_EI				; INTERRUPTS OK AGAIN
0423+  0E1B~            	XOR	A			; SIGNAL SUCCESS
0424+  0E1B~            	RET				; AND DONE
0425+  0E1B~            ;
0426+  0E1B             #ENDIF
0427+  0E1B             ;
0428+  0E1B             ;
0429+  0E1B             ;
0430+  0E1B             UART_OUT:
0431+  0E1B CD 34 0E    	CALL	UART_OST		; READY FOR CHAR?
0432+  0E1E 28 FB       	JR	Z,UART_OUT		; LOOP IF NOT
0433+  0E20 FD 4E 02    	LD	C,(IY+2)		; C := BASE UART PORT (WHICH IS ALSO THR REG)
0434+  0E23 ED 59       	OUT	(C),E			; SEND CHAR FROM E
0435+  0E25 AF          	XOR	A			; SIGNAL SUCCESS
0436+  0E26 C9          	RET
0437+  0E27             ;
0438+  0E27             ;
0439+  0E27             ;
0440+  0E27             UART_IST:
0441+  0E27~            #IF ((UARTINTS) & (INTMODE > 0))
0442+  0E27~            	BIT	UART_INTACT,(IY+1)	; INT RCV BIT
0443+  0E27~            	JR	Z,UART_IST1		; NORMAL INPUT IF NOT SET
0444+  0E27~            	JR	UART_INTIST		; ELSE INT RCV
0445+  0E27             #ENDIF
0446+  0E27             ;
0447+  0E27             UART_IST1:
0448+  0E27 FD 4E 03    	LD	C,(IY+3)		; C := LINE STATUS REG (LSR)
0449+  0E2A ED 78       	IN	A,(C)			; GET STATUS
0450+  0E2C E6 01       	AND	$01			; ISOLATE BIT 0 (RECEIVE DATA READY)
0451+  0E2E CA 8B 0C    	JP	Z,CIO_IDLE		; NOT READY, RETURN VIA IDLE PROCESSING
0452+  0E31 AF          	XOR	A			; ZERO ACCUM
0453+  0E32 3C          	INC	A			; ACCUM := 1 TO SIGNAL 1 CHAR WAITING
0454+  0E33 C9          	RET				; DONE
0455+  0E34             ;
0456+  0E34~            #IF ((UARTINTS) & (INTMODE > 0))
0457+  0E34~            ;
0458+  0E34~            UART_INTIST:
0459+  0E34~            	LD	L,(IY+6)		; GET ADDRESS
0460+  0E34~            	LD	H,(IY+7)		; ... OF RECEIVE BUFFER
0461+  0E34~            	LD	A,(HL)			; BUFFER UTILIZATION COUNT
0462+  0E34~            	OR	A			; SET FLAGS
0463+  0E34~            	JP	Z,CIO_IDLE		; NOT READY, RETURN VIA IDLE PROCESSING
0464+  0E34~            	RET
0465+  0E34~            ;
0466+  0E34             #ENDIF
0467+  0E34             ;
0468+  0E34             ;
0469+  0E34             ;
0470+  0E34             UART_OST:
0471+  0E34 FD 4E 03    	LD	C,(IY+3)		; C := LINE STATUS REG (LSR)
0472+  0E37 ED 78       	IN	A,(C)			; GET STATUS
0473+  0E39 E6 20       	AND	$20			; ISOLATE BIT 5 ()
0474+  0E3B CA 8B 0C    	JP	Z,CIO_IDLE		; NOT READY, RETURN VIA IDLE PROCESSING
0475+  0E3E AF          	XOR	A			; ZERO ACCUM
0476+  0E3F 3C          	INC	A			; ACCUM := 1 TO SIGNAL 1 BUFFER POSITION
0477+  0E40 C9          	RET				; DONE
0478+  0E41             ;
0479+  0E41             ;
0480+  0E41             ;
0481+  0E41             ;
0482+  0E41             ; NOTE THAT THERE ARE TWO ENTRY POINTS.  INITDEV WILL DISABLE/ENABLE INTS
0483+  0E41             ; AND INITDEVX WILL NOT.  THIS IS DONE SO THAT THE PREINIT ROUTINE ABOVE
0484+  0E41             ; CAN AVOID ENABLING/DISABLING INTS.
0485+  0E41             ;
0486+  0E41             UART_INITDEV:
0487+  0E41 F3          	HB_DI				; DISABLE INTS
0488+  0E42 CD 47 0E    	CALL	UART_INITDEVX		; DO THE WORK
0489+  0E45 FB          	HB_EI				; INTS BACK ON
0490+  0E46 C9          	RET				; DONE
0491+  0E47             ;
0492+  0E47             UART_INITDEVX:
0493+  0E47             	; TEST FOR -1 WHICH MEANS USE CURRENT CONFIG (JUST REINIT)
0494+  0E47 7A          	LD	A,D			; TEST DE FOR
0495+  0E48 A3          	AND	E			; ... VALUE OF -1
0496+  0E49 3C          	INC	A			; ... SO Z SET IF -1
0497+  0E4A 20 06       	JR	NZ,UART_INITDEV1	; IF DE == -1, REINIT CURRENT CONFIG
0498+  0E4C             ;
0499+  0E4C             	; LOAD EXISTING CONFIG TO REINIT
0500+  0E4C FD 5E 04    	LD	E,(IY+4)		; LOW BYTE
0501+  0E4F FD 56 05    	LD	D,(IY+5)		; HIGH BYTE
0502+  0E52             ;
0503+  0E52             UART_INITDEV1:
0504+  0E52             	; DETERMINE DIVISOR
0505+  0E52 D5          	PUSH	DE			; SAVE CONFIG
0506+  0E53 CD 8F 0F    	CALL	UART_COMPDIV		; COMPUTE DIVISOR TO BC
0507+  0E56 D1          	POP	DE			; RESTORE CONFIG
0508+  0E57 C0          	RET	NZ			; ABORT IF COMPDIV FAILS!
0509+  0E58             ;
0510+  0E58             	; GOT A DIVISOR, COMMIT NEW CONFIG
0511+  0E58 FD 73 04    	LD	(IY+4),E		; SAVE LOW WORD
0512+  0E5B FD 72 05    	LD	(IY+5),D		; SAVE HI WORD
0513+  0E5E             ;
0514+  0E5E             	; START OF ACTUAL UART CONFIGURATION
0515+  0E5E 3E 80       	LD	A,80H			; DLAB IS BIT 7 OF LCR
0516+  0E60 CD 2B 10    	UART_OUTP(UART_LCR)		; DLAB ON
0516+  0E63 03          
0517+  0E64 78          	LD	A,B
0518+  0E65 CD 2B 10    	UART_OUTP(UART_DLM)		; SET DIVISOR (MS)
0518+  0E68 01          
0519+  0E69 79          	LD	A,C
0520+  0E6A CD 2B 10    	UART_OUTP(UART_DLL)		; SET DIVISOR (LS)
0520+  0E6D 00          
0521+  0E6E             ;
0522+  0E6E             	; FOR 750+, WE ENABLE THE 64-BYTE FIFO
0523+  0E6E             	; DLAB MUST STILL BE ON FOR ACCESS TO BIT 5
0524+  0E6E             	; WE DO *NOT* ENABLE ANY OTHER FCR BITS HERE
0525+  0E6E             	; BECAUSE IT WILL SCREW UP THE 2552!!!
0526+  0E6E 3E 20       	LD	A,%00100000
0527+  0E70 CD 2B 10    	UART_OUTP(UART_FCR)		; DO IT
0527+  0E73 02          
0528+  0E74             ;
0529+  0E74 AF          	XOR	A			; DLAB OFF NOW
0530+  0E75 CD 2B 10    	UART_OUTP(UART_LCR)		; DO IT
0530+  0E78 03          
0531+  0E79             ;
0532+  0E79 AF          	XOR	A			; IER VALUE FOR NO INTS
0533+  0E7A             ;
0534+  0E7A~            #IF ((UARTINTS) & (INTMODE > 0))
0535+  0E7A~            ;
0536+  0E7A~            	BIT	UART_INTACT,(IY+1)	; CHECK INT RCV BIT
0537+  0E7A~            	JR	Z,UART_INITDEV1A	; SKIP IF NOT SET
0538+  0E7A~            	INC	A			; DATA RCVD INT BIT OF IER
0539+  0E7A~            ;
0540+  0E7A~            UART_INITDEV1A:
0541+  0E7A~            ;
0542+  0E7A             #ENDIF
0543+  0E7A             ;
0544+  0E7A CD 2B 10    	UART_OUTP(UART_IER)		; SETUP IER REGISTER
0544+  0E7D 01          
0545+  0E7E             ;
0546+  0E7E             	; SETUP FCR, BIT 5 IS KEPT ON EVEN THOUGH IT IS PROBABLY
0547+  0E7E             	; IRRELEVANT BECAUSE IT ONLY APPLIES TO 750 AND DLAB IS
0548+  0E7E             	; NOW OFF, BUT DOESN'T HURT.
0549+  0E7E             	; BITS 7-6 DEFINE THE FIFO RECEIVE INTERRUPT THRESHOLD. WE
0550+  0E7E             	; USE A VALUE 0F %01 FOR THESE BITS WHICH REDUCES THE
0551+  0E7E             	; FREQUENCY OF INTERRUPTS DURING HEAVY RECEIVE OPERATIONS.
0552+  0E7E 3E 67       	LD	A,%01100111		; FIFO ENABLE & RESET
0553+  0E80 CD 2B 10    	UART_OUTP(UART_FCR)		; DO IT
0553+  0E83 02          
0554+  0E84             ;
0555+  0E84             	; SETUP LCR FROM SECOND CONFIG BYTE
0556+  0E84 FD 7E 04    	LD	A,(IY+4)		; GET CONFIG BYTE
0557+  0E87 E6 3F       	AND	~$C0			; ISOLATE PARITY, STOP/DATA BITS
0558+  0E89 CD 2B 10    	UART_OUTP(UART_LCR)		; SAVE IT
0558+  0E8C 03          
0559+  0E8D             ;
0560+  0E8D             	; SETUP MCR FROM FIRST CONFIG BYTE
0561+  0E8D FD 7E 05    	LD	A,(IY+5)		; GET CONFIG BYTE
0562+  0E90 E6 E0       	AND	~$1F			; REMOVE ENCODED BAUD RATE BITS
0563+  0E92 F6 03       	OR	$03			; FORCE RTS & DTR
0564+  0E94             ;
0565+  0E94             	; SOME NEWER UARTS USE MCR:3 TO ACTIVATE THE INTERRUPT LINE.
0566+  0E94             	; ALTHOUGH OTHER UARTS USE MCR:3 TO CONTROL A GPIO LINE CALLED
0567+  0E94             	; OUT2, NO ROMWBW HARDWARE USES THIS GPIO LINE.  SO, HERE, WE
0568+  0E94             	; JUST SET MCR:3 TO ACTIVATE THE INTERRUPT LINE.  NOTE THAT
0569+  0E94             	; EVEN IF WE ARE NOT USING INTERRUPTS FOR THIS UART, THE
0570+  0E94             	; INTERRUPT LINE MUST STILL BE ACTIVATED SO THAT IT WILL
0571+  0E94             	; PRESENT A DEASSERTED CONDITION TO THE CPU.  OTHERWISE, THE
0572+  0E94             	; INTERRUPT LINE MAY BE LEFT FLOATING WHICH IS DEFINITELY BAD.
0573+  0E94 F6 08       	OR	$08			; ACTIVATE INT LINE
0574+  0E96             ;
0575+  0E96             	; THE MCR REGISTER AFE BIT WILL NORMALLY BE SET/RESET BY THE
0576+  0E96             	; VALUE OF THE CONFIG BYTE.  HOWEVER, IF THE CHIP IS NOT AFC CAPABLE
0577+  0E96             	; WE ARE PROBABLY USING INT RCV FOR FLOW CONTROL.  ALTHOUGH THE
0578+  0E96             	; CHIP PROBABLY IGNORES THE AFE BIT, WE FORCE CLEAR IT ANYWAY. IT WOULD
0579+  0E96             	; BE BAD IF AFC AND INT RCV ARE ACTIVE AT THE SAME TIME.
0580+  0E96 FD CB 01 6E 	BIT	UART_AFCACT,(IY+1)	; IS AFC SUPPOSED TO BE ON?
0581+  0E9A 20 02       	JR	NZ,UART_INITDEV1B	; IF SO, AFE BIT IS OK BASED ON CONFIG BYTE
0582+  0E9C CB AF       	RES	5,A			; ELSE FORCE IT OFF
0583+  0E9E             ;
0584+  0E9E             UART_INITDEV1B:
0585+  0E9E CD 2B 10    	UART_OUTP(UART_MCR)		; SAVE MCR VALUE
0585+  0EA1 04          
0586+  0EA2             ;
0587+  0EA2             	; TEST FOR EFR CAPABLE CHIPS
0588+  0EA2 FD 7E 01    	LD	A,(IY+1)		; GET UART TYPE
0589+  0EA5 E6 0F       	AND	$0F			; ISOLATE LOW NIBBLE
0590+  0EA7 FE 06       	CP	UART_16650		; 16650?
0591+  0EA9 28 06       	JR	Z,UART_INITDEV2		; USE EFR REGISTER
0592+  0EAB FE 08       	CP	UART_16850		; 16850?
0593+  0EAD 28 02       	JR	Z,UART_INITDEV2		; USE EFR REGISTER
0594+  0EAF 18 1E       	JR	UART_INITDEV4		; NO EFR, SKIP AHEAD
0595+  0EB1             ;
0596+  0EB1             UART_INITDEV2:
0597+  0EB1             	; WE HAVE AN EFR CAPABLE CHIP, SET EFR REGISTER
0598+  0EB1             	; NOTE THAT AN EFR CAPABLE CHIP IMPLIES IT IS CAPABLE OF AFC!
0599+  0EB1 CD 1E 10    	UART_INP(UART_LCR)		; GET CURRENT LCR VALUE
0599+  0EB4 03          
0600+  0EB5 F5          	PUSH	AF			; SAVE IT
0601+  0EB6 3E BF       	LD	A,$BF			; VALUE TO ACCESS EFR
0602+  0EB8 CD 2B 10    	UART_OUTP(UART_LCR)		; SET VALUE IN LCR
0602+  0EBB 03          
0603+  0EBC FD 7E 05    	LD	A,(IY+5)		; GET CONFIG BYTE
0604+  0EBF CB 6F       	BIT	5,A			; AFC REQUESTED?
0605+  0EC1 3E C0       	LD	A,$C0			; ASSUME AFC ON
0606+  0EC3 20 01       	JR	NZ,UART_INITDEV3	; YES, IMPLEMENT IT
0607+  0EC5 AF          	XOR	A			; NO AFC REQEUST, EFR := 0
0608+  0EC6             ;
0609+  0EC6             UART_INITDEV3:
0610+  0EC6 CD 2B 10    	UART_OUTP(UART_EFR)		; SAVE IT
0610+  0EC9 02          
0611+  0ECA F1          	POP	AF			; RECOVER ORIGINAL LCR VALUE
0612+  0ECB CD 2B 10    	UART_OUTP(UART_LCR)		; AND PUT IT BACK
0612+  0ECE 03          
0613+  0ECF             ;
0614+  0ECF             UART_INITDEV4:
0615+  0ECF             ;
0616+  0ECF~            #IF ((UARTINTS) & (INTMODE > 0))
0617+  0ECF~            ;
0618+  0ECF~            	LD	A,(IY+7)		; MSB OF BUFFER
0619+  0ECF~            	OR	A			; SET FLAGS
0620+  0ECF~            	JR	Z,UART_INITDEV5		; BYPASS IF NO BUFFER
0621+  0ECF~            	; RESET THE RECEIVE BUFFER
0622+  0ECF~            	LD	E,(IY+6)
0623+  0ECF~            	LD	D,(IY+7)		; DE := _CNT
0624+  0ECF~            	XOR	A			; A := 0
0625+  0ECF~            	LD	(DE),A			; _CNT = 0
0626+  0ECF~            	INC	DE			; DE := ADR OF _HD
0627+  0ECF~            	PUSH	DE			; SAVE IT
0628+  0ECF~            	INC	DE
0629+  0ECF~            	INC	DE
0630+  0ECF~            	INC	DE
0631+  0ECF~            	INC	DE			; DE := ADR OF _BUF
0632+  0ECF~            	POP	HL			; HL := ADR OF _HD
0633+  0ECF~            	LD	(HL),E
0634+  0ECF~            	INC	HL
0635+  0ECF~            	LD	(HL),D			; _HD := _BUF
0636+  0ECF~            	INC	HL
0637+  0ECF~            	LD	(HL),E
0638+  0ECF~            	INC	HL
0639+  0ECF~            	LD	(HL),D			; _TL := _BUF
0640+  0ECF~            ;
0641+  0ECF~            UART_INITDEV5:
0642+  0ECF~            ;
0643+  0ECF             #ENDIF
0644+  0ECF             ;
0645+  0ECF             ;
0646+  0ECF~            #IF (UART_DEBUG)
0647+  0ECF~            	PRTS(" [$")
0647+  0ECF~            	PRTS(" [$")
0648+  0ECF~            	
0649+  0ECF~            	; DEBUG: DUMP UART TYPE
0650+  0ECF~            	LD	A,(IY+1)
0651+  0ECF~            	CALL	PRTHEXBYTE
0652+  0ECF~            
0653+  0ECF~            	; DEBUG: DUMP IIR
0654+  0ECF~            	UART_INP(UART_IIR)
0654+  0ECF~            	UART_INP(UART_IIR)
0655+  0ECF~            	CALL	PC_SPACE
0656+  0ECF~            	CALL	PRTHEXBYTE
0657+  0ECF~            
0658+  0ECF~            	; DEBUG: DUMP LCR
0659+  0ECF~            	UART_INP(UART_LCR)
0659+  0ECF~            	UART_INP(UART_LCR)
0660+  0ECF~            	CALL	PC_SPACE
0661+  0ECF~            	CALL	PRTHEXBYTE
0662+  0ECF~            
0663+  0ECF~            	; DEBUG: DUMP MCR
0664+  0ECF~            	UART_INP(UART_MCR)
0664+  0ECF~            	UART_INP(UART_MCR)
0665+  0ECF~            	CALL	PC_SPACE
0666+  0ECF~            	CALL	PRTHEXBYTE
0667+  0ECF~            
0668+  0ECF~            	; DEBUG: DUMP EFR
0669+  0ECF~            	UART_INP(UART_LCR)
0669+  0ECF~            	UART_INP(UART_LCR)
0670+  0ECF~            	PUSH	AF
0671+  0ECF~            	LD	A,$BF
0672+  0ECF~            	UART_OUTP(UART_LCR)
0672+  0ECF~            	UART_OUTP(UART_LCR)
0673+  0ECF~            	UART_INP(UART_EFR)
0673+  0ECF~            	UART_INP(UART_EFR)
0674+  0ECF~            	LD	H,A
0675+  0ECF~            	EX	(SP),HL
0676+  0ECF~            	LD	A,H
0677+  0ECF~            	UART_OUTP(UART_LCR)
0677+  0ECF~            	UART_OUTP(UART_LCR)
0678+  0ECF~            	POP	AF
0679+  0ECF~            	CALL	PC_SPACE
0680+  0ECF~            	CALL	PRTHEXBYTE
0681+  0ECF~            	
0682+  0ECF~            	PRTC(']')
0682+  0ECF~            	PRTC(']')
0683+  0ECF             #ENDIF
0684+  0ECF             ;
0685+  0ECF AF          	XOR	A			; SIGNAL SUCCESS
0686+  0ED0 C9          	RET
0687+  0ED1             ;
0688+  0ED1             ;
0689+  0ED1             ;
0690+  0ED1             UART_QUERY:
0691+  0ED1 FD 5E 04    	LD	E,(IY+4)		; FIRST CONFIG BYTE TO E
0692+  0ED4 FD 56 05    	LD	D,(IY+5)		; SECOND CONFIG BYTE TO D
0693+  0ED7 AF          	XOR	A			; SIGNAL SUCCESS
0694+  0ED8 C9          	RET				; DONE
0695+  0ED9             ;
0696+  0ED9             ;
0697+  0ED9             ;
0698+  0ED9             UART_DEVICE:
0699+  0ED9 16 00       	LD	D,CIODEV_UART		; D := DEVICE TYPE
0700+  0EDB FD 5E 00    	LD	E,(IY)			; E := PHYSICAL UNIT
0701+  0EDE 0E 00       	LD	C,$00			; C := DEVICE TYPE, 0x00 IS RS-232
0702+  0EE0 FD 66 01    	LD	H,(IY+1)		; H := UART TYPE BYTE
0703+  0EE3 FD 6E 02    	LD	L,(IY+2)		; L := BASE I/O ADDRESS
0704+  0EE6 AF          	XOR	A			; SIGNAL SUCCESS
0705+  0EE7 C9          	RET
0706+  0EE8             ;
0707+  0EE8             ; UART DETECTION ROUTINE
0708+  0EE8             ;
0709+  0EE8             UART_DETECT:
0710+  0EE8 CD FC 0E    	CALL	UART_CHIP		; DETECT CHIP VARIANT
0711+  0EEB             	;LD	A,UART_16550A		; *DEBUG*
0712+  0EEB B7          	OR	A
0713+  0EEC C8          	RET	Z			; DONE IF NO CHIP
0714+  0EED 4F          	LD	C,A			; PUT CHIP VARIANT IN C
0715+  0EEE             ;
0716+  0EEE~            #IF ((UARTINTS) & (INTMODE > 0))
0717+  0EEE~            ;
0718+  0EEE~            	; CHECK TO SEE IF INT RCV WANTED ON THIS DEVICE
0719+  0EEE~            	PUSH	AF			; SAVE CHIP ID
0720+  0EEE~            	CP	UART_16550C		; 16550C OR LATER?
0721+  0EEE~            	JR	NC,UART_DETECT1		; NO INTS, USE AFC INSTEAD
0722+  0EEE~            	LD	A,(IY+7)		; MSB OF RING BUFFER
0723+  0EEE~            	OR	A			; SET FLAGS
0724+  0EEE~            	JR	Z,UART_DETECT1		; NO BUFFER, NO INTS ALLOWED
0725+  0EEE~            	SET	UART_INTACT,C		; SET INT RCV BIT
0726+  0EEE~            ;
0727+  0EEE~            UART_DETECT1:
0728+  0EEE~            	POP	AF			; RESTORE CHIP ID
0729+  0EEE~            ;
0730+  0EEE             #ENDIF
0731+  0EEE             ;
0732+  0EEE FE 03       	CP	UART_16550		; 16550 OR GREATER?
0733+  0EF0 38 08       	JR	C,UART_DETECT2		; NO MORE FEATURES
0734+  0EF2 CB F1       	SET	UART_FIFOACT,C		; RECORD FIFO FEATURE
0735+  0EF4 FE 05       	CP	UART_16550C		; 16550C OR GREATER?
0736+  0EF6 38 02       	JR	C,UART_DETECT2		; NO MORE FEATURES
0737+  0EF8 CB E9       	SET	UART_AFCACT,C		; RECORD AFC FEATURE
0738+  0EFA             ;
0739+  0EFA             UART_DETECT2:
0740+  0EFA 79          	LD	A,C			; RETURN RESULT IN A
0741+  0EFB C9          	RET
0742+  0EFC             ;
0743+  0EFC             ; DETERMINE THE UART CHIP VARIANT AND RETURN IN A
0744+  0EFC             ;
0745+  0EFC             UART_CHIP:
0746+  0EFC             ;
0747+  0EFC             	; SEE IF UART IS THERE BY CHECKING DLAB FUNCTIONALITY
0748+  0EFC AF          	XOR	A			; ZERO ACCUM
0749+  0EFD CD 2B 10    	UART_OUTP(UART_IER)		; IER := 0
0749+  0F00 01          
0750+  0F01 3E 80       	LD	A,$80			; DLAB BIT ON
0751+  0F03 CD 2B 10    	UART_OUTP(UART_LCR)		; OUTPUT TO LCR (DLAB REGS NOW ACTIVE)
0751+  0F06 03          
0752+  0F07 3E 5A       	LD	A,$5A			; LOAD TEST VALUE
0753+  0F09 CD 2B 10    	UART_OUTP(UART_DLM)		; OUTPUT TO DLM
0753+  0F0C 01          
0754+  0F0D CD 1E 10    	UART_INP(UART_DLM)		; READ IT BACK
0754+  0F10 01          
0755+  0F11 FE 5A       	CP	$5A			; CHECK FOR TEST VALUE
0756+  0F13 C2 74 0F    	JP	NZ,UART_CHIP_NONE	; NOPE, UNKNOWN UART OR NOT PRESENT
0757+  0F16 AF          	XOR	A			; DLAB BIT OFF
0758+  0F17 CD 2B 10    	UART_OUTP(UART_LCR)		; OUTPUT TO LCR (DLAB REGS NOW INACTIVE)
0758+  0F1A 03          
0759+  0F1B CD 1E 10    	UART_INP(UART_IER)		; READ IER
0759+  0F1E 01          
0760+  0F1F FE 5A       	CP	$5A			; CHECK FOR TEST VALUE
0761+  0F21 CA 74 0F    	JP	Z,UART_CHIP_NONE	; IF STILL $5A, UNKNOWN OR NOT PRESENT
0762+  0F24             ;
0763+  0F24             	; TEST FOR FUNCTIONAL SCRATCH REG, IF NOT, WE HAVE AN 8250
0764+  0F24 3E 5A       	LD	A,$5A			; LOAD TEST VALUE
0765+  0F26 CD 2B 10    	UART_OUTP(UART_SCR)		; PUT IT IN SCRATCH REGISTER
0765+  0F29 07          
0766+  0F2A CD 1E 10    	UART_INP(UART_SCR)		; READ IT BACK
0766+  0F2D 07          
0767+  0F2E FE 5A       	CP	$5A			; CHECK IT
0768+  0F30 20 45       	JR	NZ,UART_CHIP_8250	; STUPID 8250
0769+  0F32             ;
0770+  0F32             	; TEST FOR EFR REGISTER WHICH IMPLIES 16650/850
0771+  0F32 3E BF       	LD	A,$BF			; VALUE TO ENABLE EFR
0772+  0F34 CD 2B 10    	UART_OUTP(UART_LCR)		; WRITE IT TO LCR
0772+  0F37 03          
0773+  0F38 CD 1E 10    	UART_INP(UART_SCR)		; READ SCRATCH REGISTER
0773+  0F3B 07          
0774+  0F3C FE 5A       	CP	$5A			; SPR STILL THERE?
0775+  0F3E 20 1D       	JR	NZ,UART_CHIP1		; NOPE, HIDDEN, MUST BE 16650/850
0776+  0F40             ;
0777+  0F40             	; RESET LCR TO DEFAULT (DLAB OFF)
0778+  0F40             	;LD	A,$80			; DLAB BIT ON
0779+  0F40 AF          	XOR	A			; DLAB BIT OFF
0780+  0F41 CD 2B 10    	UART_OUTP(UART_LCR)		; RESET LCR
0780+  0F44 03          
0781+  0F45             ;
0782+  0F45             	; TEST FCR TO ISOLATE 16450/550/550A
0783+  0F45 3E E7       	LD	A,$E7			; TEST VALUE
0784+  0F47 CD 2B 10    	UART_OUTP(UART_FCR)		; PUT IT IN FCR
0784+  0F4A 02          
0785+  0F4B CD 1E 10    	UART_INP(UART_IIR)		; READ BACK FROM IIR
0785+  0F4E 02          
0786+  0F4F CB 77       	BIT	6,A			; BIT 6 IS FIFO ENABLE, LO BIT
0787+  0F51 28 27       	JR	Z,UART_CHIP_16450	; IF NOT SET, MUST BE 16450
0788+  0F53 CB 7F       	BIT	7,A			; BIT 7 IS FIFO ENABLE, HI BIT
0789+  0F55 28 26       	JR	Z,UART_CHIP_16550	; IF NOT SET, MUST BE 16550
0790+  0F57 CB 6F       	BIT	5,A			; BIT 5 IS 64 BYTE FIFO
0791+  0F59 28 09       	JR	Z,UART_CHIP2		; IF NOT SET, MUST BE 16550A/C
0792+  0F5B 18 2C       	JR	UART_CHIP_16750	; ONLY THING LEFT IS 16750
0793+  0F5D             ;
0794+  0F5D             UART_CHIP1:	; PICK BETWEEN 16650/850
0795+  0F5D             	; RESET LCR TO DEFAULT (DLAB OFF)
0796+  0F5D AF          	XOR	A			; DLAB BIT OFF
0797+  0F5E CD 2B 10    	UART_OUTP(UART_LCR)		; RESET LCR
0797+  0F61 03          
0798+  0F62             	; NOT SURE HOW TO DIFFERENTIATE 16650 FROM 16850 YET
0799+  0F62 18 22       	JR	UART_CHIP_16650	; ASSUME 16650
0800+  0F64             ;
0801+  0F64             UART_CHIP2:	; PICK BETWEEN 16550A/C
0802+  0F64             	; SET AFC BIT IN FCR
0803+  0F64 3E 20       	LD	A,$20			; SET AFC BIT, MCR:5
0804+  0F66 CD 2B 10    	UART_OUTP(UART_MCR)		; WRITE NEW FCR VALUE
0804+  0F69 04          
0805+  0F6A             ;
0806+  0F6A             	; READ IT BACK, IF SET, WE HAVE 16550C
0807+  0F6A CD 1E 10    	UART_INP(UART_MCR)		; READ BACK MCR
0807+  0F6D 04          
0808+  0F6E CB 6F       	BIT	5,A			; CHECK AFC BIT
0809+  0F70 28 0E       	JR	Z,UART_CHIP_16550A	; NOT SET, SO 16550A
0810+  0F72 18 0F       	JR	UART_CHIP_16550C	; IS SET, SO 16550C
0811+  0F74             ;
0812+  0F74             UART_CHIP_NONE:
0813+  0F74             ;
0814+  0F74~            #IF (UARTSBCFORCE)
0815+  0F74~            	; SIMH DOES NOT EMULATE A UART WELL ENOUGH TO BE DETECTED, SO
0816+  0F74~            	; THIS BIT OF CODE CAN BE ENABLED TO FORCE THE PRIMARY SBC
0817+  0F74~            	; UART TO BE HANDLED AS AN 8250.
0818+  0F74~            	LD	A,(IY+2)		; BASE IO PORT
0819+  0F74~            	CP	UARTSBASE		; IS THIS PRIMARY SBC PORT?
0820+  0F74~            	JR	Z,UART_CHIP_8250	; SPECIAL CASE FOR PRIMARY UART!
0821+  0F74             #ENDIF
0822+  0F74             ;
0823+  0F74 3E 00       	LD	A,UART_NONE		; NO UART DETECTED AT THIS PORT
0824+  0F76 C9          	RET
0825+  0F77             ;
0826+  0F77             UART_CHIP_8250:
0827+  0F77 3E 01       	LD	A,UART_8250
0828+  0F79 C9          	RET
0829+  0F7A             ;
0830+  0F7A             UART_CHIP_16450:
0831+  0F7A 3E 02       	LD	A,UART_16450
0832+  0F7C C9          	RET
0833+  0F7D             ;
0834+  0F7D             UART_CHIP_16550:
0835+  0F7D 3E 03       	LD	A,UART_16550
0836+  0F7F C9          	RET
0837+  0F80             ;
0838+  0F80             UART_CHIP_16550A:
0839+  0F80 3E 04       	LD	A,UART_16550A
0840+  0F82 C9          	RET
0841+  0F83             ;
0842+  0F83             UART_CHIP_16550C:
0843+  0F83 3E 05       	LD	A,UART_16550C
0844+  0F85 C9          	RET
0845+  0F86             ;
0846+  0F86             UART_CHIP_16650:
0847+  0F86 3E 06       	LD	A,UART_16650
0848+  0F88 C9          	RET
0849+  0F89             ;
0850+  0F89             UART_CHIP_16750:
0851+  0F89 3E 07       	LD	A,UART_16750
0852+  0F8B C9          	RET
0853+  0F8C             ;
0854+  0F8C             UART_CHIP_16850:
0855+  0F8C 3E 08       	LD	A,UART_16850
0856+  0F8E C9          	RET
0857+  0F8F             ;
0858+  0F8F             ; COMPUTE DIVISOR TO BC
0859+  0F8F             ;
0860+  0F8F             UART_COMPDIV:
0861+  0F8F             	; WE WANT TO DETERMINE A DIVISOR FOR THE UART CLOCK
0862+  0F8F             	; THAT RESULTS IN THE DESIRED BAUD RATE.
0863+  0F8F             	; BAUD RATE = UART CLK / DIVISOR, OR TO SOLVE FOR DIVISOR
0864+  0F8F             	; DIVISOR = UART CLK / BAUDRATE.
0865+  0F8F             	; THE UART CLOCK IS THE UART OSC PRESCALED BY 16.  ALSO, WE CAN
0866+  0F8F             	; TAKE ADVANTAGE OF ENCODED BAUD RATES ALWAYS BEING A FACTOR OF 75.
0867+  0F8F             	; SO, WE CAN USE (UART OSC / 16 / 75) / (BAUDRATE / 75)
0868+  0F8F             ;
0869+  0F8F             	; FIRST WE DECODE THE BAUDRATE, BUT WE USE A CONSTANT OF 1 INSTEAD
0870+  0F8F             	; OF THE NORMAL 75.  THIS PRODUCES (BAUDRATE / 75).
0871+  0F8F             ;
0872+  0F8F 7A          	LD	A,D			; GET CONFIG MSB
0873+  0F90 E6 1F       	AND	$1F			; ISOLATE ENCODED BAUD RATE
0874+  0F92 6F          	LD	L,A			; PUT IN L
0875+  0F93 26 00       	LD	H,0			; H IS ALWAYS ZERO
0876+  0F95 11 01 00    	LD	DE,1			; USE 1 FOR ENCODING CONSTANT
0877+  0F98 CD 43 1E    	CALL	DECODE			; DE:HL := BAUD RATE, ERRORS IGNORED
0878+  0F9B EB          	EX	DE,HL			; DE := (BAUDRATE / 75), DISCARD HL
0879+  0F9C 21 00 06    	LD	HL,UARTOSC / 16 / 75	; HL := (UART OSC / 16 / 75)
0880+  0F9F C3 57 1B    	JP	DIV16			; BC := HL/DE == DIVISOR AND RETURN
0881+  0FA2             ;
0882+  0FA2             ;
0883+  0FA2             ;
0884+  0FA2             UART_PRTCFG:
0885+  0FA2             	; ANNOUNCE PORT
0886+  0FA2 CD 20 19    	CALL	NEWLINE			; FORMATTING
0887+  0FA5 CD 3B 19    	PRTS("UART$")			; FORMATTING
0887+  0FA8 55 41 52 54 
0887+  0FAC 24 
0888+  0FAD FD 7E 00    	LD	A,(IY)			; DEVICE NUM
0889+  0FB0 CD B2 1B    	CALL	PRTDECB			; PRINT DEVICE NUM
0890+  0FB3 CD 3B 19    	PRTS(": IO=0x$")		; FORMATTING
0890+  0FB6 3A 20 49 4F 
0890+  0FBA 3D 30 78 24 
0891+  0FBE FD 7E 02    	LD	A,(IY+2)		; GET BASE PORT
0892+  0FC1 CD 52 19    	CALL	PRTHEXBYTE		; PRINT BASE PORT
0893+  0FC4             
0894+  0FC4             	; PRINT THE UART TYPE
0895+  0FC4 CD D7 18    	CALL	PC_SPACE		; FORMATTING
0896+  0FC7 FD 7E 01    	LD	A,(IY+1)		; GET UART TYPE BYTE
0897+  0FCA E6 0F       	AND	$0F			; LOW BITS ONLY
0898+  0FCC 07          	RLCA				; MAKE IT A WORD OFFSET
0899+  0FCD 21 39 10    	LD	HL,UART_TYPE_MAP	; POINT HL TO TYPE MAP TABLE
0900+  0FD0 CD D2 1A    	CALL	ADDHLA			; HL := ENTRY
0901+  0FD3 5E          	LD	E,(HL)			; DEREFERENCE
0902+  0FD4 23          	INC	HL			; ...
0903+  0FD5 56          	LD	D,(HL)			; ... TO GET STRING POINTER
0904+  0FD6 CD 12 1A    	CALL	WRITESTR		; PRINT IT
0905+  0FD9             ;
0906+  0FD9             	; ALL DONE IF NO UART WAS DETECTED
0907+  0FD9 FD 7E 01    	LD	A,(IY+1)		; GET UART TYPE BYTE
0908+  0FDC B7          	OR	A			; SET FLAGS
0909+  0FDD C8          	RET	Z			; IF ZERO, NOT PRESENT
0910+  0FDE             ;
0911+  0FDE CD 3B 19    	PRTS(" MODE=$")			; FORMATTING
0911+  0FE1 20 4D 4F 44 
0911+  0FE5 45 3D 24 
0912+  0FE8 FD 5E 04    	LD	E,(IY+4)		; LOAD CONFIG
0913+  0FEB FD 56 05    	LD	D,(IY+5)		; ... WORD TO DE
0914+  0FEE CD 51 25    	CALL	PS_PRTSC0		; PRINT CONFIG
0915+  0FF1             ;
0916+  0FF1             	; PRINT FEATURES ENABLED
0917+  0FF1 FD CB 01 7E 	BIT	UART_INTACT,(IY+1)	; GET INT RCV BIT
0918+  0FF5 28 08       	JR	Z,UART_PRTCFG1
0919+  0FF7 CD 3B 19    	PRTS(" INT$")
0919+  0FFA 20 49 4E 54 
0919+  0FFE 24 
0920+  0FFF             ;
0921+  0FFF             UART_PRTCFG1:
0922+  0FFF FD CB 01 76 	BIT	UART_FIFOACT,(IY+1)	; GET FIFO BIT
0923+  1003 28 09       	JR	Z,UART_PRTCFG2
0924+  1005 CD 3B 19    	PRTS(" FIFO$")
0924+  1008 20 46 49 46 
0924+  100C 4F 24 
0925+  100E             ;
0926+  100E             UART_PRTCFG2:
0927+  100E FD CB 01 6E 	BIT	UART_AFCACT,(IY+1)	; GET AFC BIT
0928+  1012 28 08       	JR	Z,UART_PRTCFG3
0929+  1014 CD 3B 19    	PRTS(" AFC$")
0929+  1017 20 41 46 43 
0929+  101B 24 
0930+  101C             ;
0931+  101C             UART_PRTCFG3:
0932+  101C             ;
0933+  101C AF          	XOR	A
0934+  101D C9          	RET
0935+  101E             ;
0936+  101E             ; ROUTINES TO READ/WRITE PORTS INDIRECTLY
0937+  101E             ;
0938+  101E             ; READ VALUE OF UART PORT ON TOS INTO REGISTER A
0939+  101E             ;
0940+  101E             UART_INP_IMP:
0941+  101E E3          	EX	(SP),HL		; SWAP HL AND TOS
0942+  101F C5          	PUSH	BC		; PRESERVE BC
0943+  1020 FD 7E 02    	LD	A,(IY+2)	; GET UART IO BASE PORT
0944+  1023 B6          	OR	(HL)		; OR IN REGISTER ID BITS
0945+  1024 4F          	LD	C,A		; C := PORT
0946+  1025 ED 78       	IN	A,(C)		; READ PORT INTO A
0947+  1027 C1          	POP	BC		; RESTORE BC
0948+  1028 23          	INC	HL		; BUMP HL PAST REG ID PARM
0949+  1029 E3          	EX	(SP),HL		; SWAP BACK HL AND TOS
0950+  102A C9          	RET
0951+  102B             ;
0952+  102B             ; WRITE VALUE IN REGISTER A TO UART PORT ON TOS
0953+  102B             ;
0954+  102B             UART_OUTP_IMP:
0955+  102B E3          	EX	(SP),HL		; SWAP HL AND TOS
0956+  102C C5          	PUSH	BC		; PRESERVE BC
0957+  102D 47          	LD	B,A		; PUT VALUE TO WRITE IN B
0958+  102E FD 7E 02    	LD	A,(IY+2)	; GET UART IO BASE PORT
0959+  1031 B6          	OR	(HL)		; OR IN REGISTER ID BITS
0960+  1032 4F          	LD	C,A		; C := PORT
0961+  1033 ED 41       	OUT	(C),B		; WRITE VALUE TO PORT
0962+  1035 C1          	POP	BC		; RESTORE BC
0963+  1036 23          	INC	HL		; BUMP HL PAST REG ID PARM
0964+  1037 E3          	EX	(SP),HL		; SWAP BACK HL AND TOS
0965+  1038 C9          	RET
0966+  1039             ;
0967+  1039             ;
0968+  1039             ;
0969+  1039             UART_TYPE_MAP:
0970+  1039 4B 10       			.DW	UART_STR_NONE
0971+  103B 59 10       			.DW	UART_STR_8250
0972+  103D 5E 10       			.DW	UART_STR_16450
0973+  103F 64 10       			.DW	UART_STR_16550
0974+  1041 6A 10       			.DW	UART_STR_16550A
0975+  1043 71 10       			.DW	UART_STR_16550C
0976+  1045 78 10       			.DW	UART_STR_16650
0977+  1047 7E 10       			.DW	UART_STR_16750
0978+  1049 84 10       			.DW	UART_STR_16850
0979+  104B             
0980+  104B 3C 4E 4F 54 UART_STR_NONE		.DB	"<NOT PRESENT>$"
0980+  104F 20 50 52 45 
0980+  1053 53 45 4E 54 
0980+  1057 3E 24 
0981+  1059 38 32 35 30 UART_STR_8250		.DB	"8250$"
0981+  105D 24 
0982+  105E 31 36 34 35 UART_STR_16450		.DB	"16450$"
0982+  1062 30 24 
0983+  1064 31 36 35 35 UART_STR_16550		.DB	"16550$"
0983+  1068 30 24 
0984+  106A 31 36 35 35 UART_STR_16550A		.DB	"16550A$"
0984+  106E 30 41 24 
0985+  1071 31 36 35 35 UART_STR_16550C		.DB	"16550C$"
0985+  1075 30 43 24 
0986+  1078 31 36 36 35 UART_STR_16650		.DB	"16650$"
0986+  107C 30 24 
0987+  107E 31 36 37 35 UART_STR_16750		.DB	"16750$"
0987+  1082 30 24 
0988+  1084 31 36 38 35 UART_STR_16850		.DB	"16850$"
0988+  1088 30 24 
0989+  108A             ;
0990+  108A 4E 4F 4E 45 UART_PAR_MAP		.DB	"NONENMNS"
0990+  108E 4E 4D 4E 53 
0991+  1092             ;
0992+  1092             ; WORKING VARIABLES
0993+  1092             ;
0994+  1092 00          UART_DEV		.DB	0		; DEVICE NUM USED DURING INIT
0995+  1093             ;
0996+  1093             ; UART PORT TABLE
0997+  1093             ;
0998+  1093             UART_CFG:
0999+  1093~            #IF (UARTSBC)
1000+  1093~            UART_CFG_SBC:
1001+  1093~            	; SBC/ZETA ONBOARD SERIAL PORT
1002+  1093~            	.DB	0				; DEVICE NUMBER (UPDATED DURING INIT)
1003+  1093~            	.DB	0				; UART TYPE
1004+  1093~            	.DB	UARTSBASE			; IO PORT BASE (RBR, THR)
1005+  1093~            	.DB	UARTSBASE + UART_LSR		; LINE STATUS PORT (LSR)
1006+  1093~            	.DW	UARTCFG				; LINE CONFIGURATION
1007+  1093~            	.DW	UARTSBC_RCVBUF			; POINTER TO RCV BUFFER STRUCT
1008+  1093             #ENDIF
1009+  1093~            #IF (UARTCAS)
1010+  1093~            UART_CFG_CAS:
1011+  1093~            	; CASSETTE INTERFACE SERIAL PORT
1012+  1093~            	.DB	0				; DEVICE NUMBER (UPDATED DURING INIT)
1013+  1093~            	.DB	0				; UART TYPE
1014+  1093~            	.DB	UARTCBASE			; IO PORT BASE (RBR, THR)
1015+  1093~            	.DB	UARTCBASE + UART_LSR		; LINE STATUS PORT (LSR)
1016+  1093~            	.DW	UARTCASSPD			; LINE CONFIGURATION
1017+  1093~            	.DW	UARTCAS_RCVBUF			; POINTER TO RCV BUFFER STRUCT
1018+  1093             #ENDIF
1019+  1093~            #IF (UARTMFP)
1020+  1093~            UART_CFG_MFP:
1021+  1093~            	; MF/PIC SERIAL PORT
1022+  1093~            	.DB	0				; DEVICE NUMBER (UPDATED DURING INIT)
1023+  1093~            	.DB	0				; UART TYPE
1024+  1093~            	.DB	UARTMBASE			; IO PORT BASE (RBR, THR)
1025+  1093~            	.DB	UARTMBASE + UART_LSR		; LINE STATUS PORT (LSR)
1026+  1093~            	.DW	UARTCFG				; LINE CONFIGURATION
1027+  1093~            	.DW	0				; SHOULD NEVER NEED INT HANDLER
1028+  1093             #ENDIF
1029+  1093~            #IF (UART4)
1030+  1093~            	; 4UART SERIAL PORT A
1031+  1093~            	.DB	0				; DEVICE NUMBER (UPDATED DURING INIT)
1032+  1093~            	.DB	0				; UART TYPE
1033+  1093~            	.DB	UART4BASE+0			; IO PORT BASE (RBR, THR)
1034+  1093~            	.DB	UART4BASE+0 + UART_LSR		; LINE STATUS PORT (LSR)
1035+  1093~            	.DW	UARTCFG				; LINE CONFIGURATION
1036+  1093~            	.DW	0				; SHOULD NEVER NEED INT HANDLER
1037+  1093~            	; 4UART SERIAL PORT B
1038+  1093~            	.DB	0				; DEVICE NUMBER (UPDATED DURING INIT)
1039+  1093~            	.DB	0				; UART TYPE
1040+  1093~            	.DB	UART4BASE+8			; IO PORT BASE (RBR, THR)
1041+  1093~            	.DB	UART4BASE+8 + UART_LSR		; LINE STATUS PORT (LSR)
1042+  1093~            	.DW	UARTCFG				; LINE CONFIGURATION
1043+  1093~            	.DW	0				; SHOULD NEVER NEED INT HANDLER
1044+  1093~            	; 4UART SERIAL PORT C
1045+  1093~            	.DB	0				; DEVICE NUMBER (UPDATED DURING INIT)
1046+  1093~            	.DB	0				; UART TYPE
1047+  1093~            	.DB	UART4BASE+16			; IO PORT BASE (RBR, THR)
1048+  1093~            	.DB	UART4BASE+16 + UART_LSR		; LINE STATUS PORT (LSR)
1049+  1093~            	.DW	UARTCFG				; LINE CONFIGURATION
1050+  1093~            	.DW	0				; SHOULD NEVER NEED INT HANDLER
1051+  1093~            	; 4UART SERIAL PORT D
1052+  1093~            	.DB	0				; DEVICE NUMBER (UPDATED DURING INIT)
1053+  1093~            	.DB	0				; UART TYPE
1054+  1093~            	.DB	UART4BASE+24			; IO PORT BASE (RBR, THR)
1055+  1093~            	.DB	UART4BASE+24 + UART_LSR		; LINE STATUS PORT (LSR)
1056+  1093~            	.DW	UARTCFG				; LINE CONFIGURATION
1057+  1093~            	.DW	0				; SHOULD NEVER NEED INT HANDLER
1058+  1093             #ENDIF
1059+  1093~            #IF (UARTRC)
1060+  1093~            	; UARTRC SERIAL PORT A
1061+  1093~            	.DB	0				; DEVICE NUMBER (UPDATED DURING INIT)
1062+  1093~            	.DB	0				; UART TYPE
1063+  1093~            	.DB	UARTRBASE			; IO PORT BASE (RBR, THR)
1064+  1093~            	.DB	UARTRBASE + UART_LSR		; LINE STATUS PORT (LSR)
1065+  1093~            	.DW	UARTCFG				; LINE CONFIGURATION
1066+  1093~            	.DW	0				; SHOULD NEVER NEED INT HANDLER
1067+  1093~            	; UARTRC SERIAL PORT B
1068+  1093~            	.DB	0				; DEVICE NUMBER (UPDATED DURING INIT)
1069+  1093~            	.DB	0				; UART TYPE
1070+  1093~            	.DB	UARTRBASE+8			; IO PORT BASE (RBR, THR)
1071+  1093~            	.DB	UARTRBASE+8 + UART_LSR		; LINE STATUS PORT (LSR)
1072+  1093~            	.DW	UARTCFG				; LINE CONFIGURATION
1073+  1093~            	.DW	0				; SHOULD NEVER NEED INT HANDLER
1074+  1093             #ENDIF
1075+  1093~            #IF (UARTDUAL)
1076+  1093~            	; DUAL UART CHANNEL A
1077+  1093~            	.DB	0				; DEVICE NUMBER (UPDATED DURING INIT)
1078+  1093~            	.DB	0				; UART TYPE
1079+  1093~            	.DB	UARTDBASE			; IO PORT BASE (RBR, THR)
1080+  1093~            	.DB	UARTDBASE + UART_LSR		; LINE STATUS PORT (LSR)
1081+  1093~            	.DW	UARTCFG				; LINE CONFIGURATION
1082+  1093~            	.DW	0				; SHOULD NEVER NEED INT HANDLER
1083+  1093~            	; DUAL UART CHANNEL B
1084+  1093~            	.DB	0				; DEVICE NUMBER (UPDATED DURING INIT)
1085+  1093~            	.DB	0				; UART TYPE
1086+  1093~            	.DB	UARTDBASE+8			; IO PORT BASE (RBR, THR)
1087+  1093~            	.DB	UARTDBASE+8 + UART_LSR		; LINE STATUS PORT (LSR)
1088+  1093~            	.DW	UARTCFG				; LINE CONFIGURATION
1089+  1093~            	.DW	0				; SHOULD NEVER NEED INT HANDLER
1090+  1093             #ENDIF
1091+  1093             #IF (UARTHEATH)
1092+  1093             	; DUAL UART CHANNEL A
1093+  1093 00          	.DB	0				; DEVICE NUMBER (UPDATED DURING INIT)
1094+  1094 00          	.DB	0				; UART TYPE
1095+  1095 E8          	.DB	UARTHBASE			; IO PORT BASE (RBR, THR)
1096+  1096 ED          	.DB	UARTHBASE + UART_LSR		; LINE STATUS PORT (LSR)
1097+  1097 03 19       	.DW	UARTCFG				; LINE CONFIGURATION
1098+  1099 00 00       	.DW	0				; SHOULD NEVER NEED INT HANDLER
1099+  109B             	; DUAL UART CHANNEL B
1100+  109B 00          	.DB	0				; DEVICE NUMBER (UPDATED DURING INIT)
1101+  109C 00          	.DB	0				; UART TYPE
1102+  109D E0          	.DB	UARTHBASE-8			; IO PORT BASE (RBR, THR)
1103+  109E E5          	.DB	UARTHBASE-8 + UART_LSR		; LINE STATUS PORT (LSR)
1104+  109F 03 19       	.DW	UARTCFG				; LINE CONFIGURATION
1105+  10A1 00 00       	.DW	0				; SHOULD NEVER NEED INT HANDLER
1106+  10A3             #ENDIF
1107+  10A3             ;
1108+  10A3             UART_CNT	.EQU	($ - UART_CFG) / 8
1109+  10A3             ;
1110+  10A3             #IF ((!UARTINTS) | (INTMODE == 0))
1111+  10A3             ;
1112+  10A3             UARTSBC_RCVBUF	.EQU	0
1113+  10A3             UARTCAS_RCVBUF	.EQU	0
1114+  10A3             ;
1115+  10A3~            #ELSE
1116+  10A3~            ;
1117+  10A3~            ; UART SBC RECEIVE BUFFER
1118+  10A3~            ;
1119+  10A3~              #IF (UARTSBC)
1120+  10A3~            ;
1121+  10A3~            UARTSBC_RCVBUF:
1122+  10A3~            UARTSBC_CNT	.DB	0		; CHARACTERS IN RING BUFFER
1123+  10A3~            UARTSBC_HD	.DW	UARTSBC_BUF	; BUFFER HEAD POINTER
1124+  10A3~            UARTSBC_TL	.DW	UARTSBC_BUF	; BUFFER TAIL POINTER
1125+  10A3~            UARTSBC_BUF	.FILL	UART_BUFSZ,0	; RECEIVE RING BUFFER
1126+  10A3~            ;
1127+  10A3~              #ENDIF
1128+  10A3~            ;
1129+  10A3~            ; UART CASSETTE RECEIVE BUFFER
1130+  10A3~            ;
1131+  10A3~              #IF (UARTCAS)
1132+  10A3~            ;
1133+  10A3~            UARTCAS_RCVBUF:
1134+  10A3~            UARTCAS_CNT	.DB	0		; CHARACTERS IN RING BUFFER
1135+  10A3~            UARTCAS_HD	.DW	UARTCAS_BUF	; BUFFER HEAD POINTER
1136+  10A3~            UARTCAS_TL	.DW	UARTCAS_BUF	; BUFFER TAIL POINTER
1137+  10A3~            UARTCAS_BUF	.FILL	UART_BUFSZ,0	; RECEIVE RING BUFFER
1138+  10A3~            ;
1139+  10A3~              #ENDIF
1140+  10A3~            ;
1141+  10A3             #ENDIF
5941   10A3             SIZ_UART	.EQU	$ - ORG_UART
5942   10A3             		.ECHO	"UART occupies "
5943   10A3             		.ECHO	SIZ_UART
5944   10A3             		.ECHO	" bytes.\n"
5945   10A3             #ENDIF
5946   10A3             ;
5947   10A3~            #IF (DUARTENABLE)
5948   10A3~            ORG_DUART	.EQU	$
5949   10A3~              #INCLUDE "duart.asm"
5950   10A3~            SIZ_DUART	.EQU	$ - ORG_DUART
5951   10A3~            		.ECHO	"DUART occupies "
5952   10A3~            		.ECHO	SIZ_DUART
5953   10A3~            		.ECHO	" bytes.\n"
5954   10A3             #ENDIF
5955   10A3             ;
5956   10A3~            #IF (SIOENABLE)
5957   10A3~            ORG_SIO		.EQU	$
5958   10A3~              #INCLUDE "sio.asm"
5959   10A3~            SIZ_SIO		.EQU	$ - ORG_SIO
5960   10A3~            		.ECHO	"SIO occupies "
5961   10A3~            		.ECHO	SIZ_SIO
5962   10A3~            		.ECHO	" bytes.\n"
5963   10A3             #ENDIF
5964   10A3             ;
5965   10A3~            #IF (ACIAENABLE)
5966   10A3~            ORG_ACIA	.EQU	$
5967   10A3~              #INCLUDE "acia.asm"
5968   10A3~            SIZ_ACIA	.EQU	$ - ORG_ACIA
5969   10A3~            		.ECHO	"ACIA occupies "
5970   10A3~            		.ECHO	SIZ_ACIA
5971   10A3~            		.ECHO	" bytes.\n"
5972   10A3             #ENDIF
5973   10A3             ;
5974   10A3~            #IF (PIOENABLE)
5975   10A3~            ORG_PIO		.EQU	$
5976   10A3~              #INCLUDE "pio.asm"
5977   10A3~            SIZ_PIO		.EQU	$ - ORG_PIO
5978   10A3~            		.ECHO	"PIO occupies "
5979   10A3~            		.ECHO	SIZ_PIO
5980   10A3~            		.ECHO	" bytes.\n"
5981   10A3             #ENDIF
5982   10A3             ;
5983   10A3~            #IF (LPTENABLE)
5984   10A3~            ORG_LPT		.EQU	$
5985   10A3~              #INCLUDE "lpt.asm"
5986   10A3~            SIZ_LPT		.EQU	$ - ORG_LPT
5987   10A3~            		.ECHO	"LPT occupies "
5988   10A3~            		.ECHO	SIZ_LPT
5989   10A3~            		.ECHO	" bytes.\n"
5990   10A3             #ENDIF
5991   10A3             ;
5992   10A3~            #IF (PIO_4P | PIO_ZP | PIO_SBC)
5993   10A3~            ORG_PIO		.EQU	$
5994   10A3~              #INCLUDE "pio.asm"
5995   10A3~            SIZ_PIO		.EQU	$ - ORG_PIO
5996   10A3~            		.ECHO	"PIO occupies "
5997   10A3~            		.ECHO	SIZ_PIO
5998   10A3~            		.ECHO	" bytes.\n"
5999   10A3             #ENDIF
6000   10A3             ;
6001   10A3~            #IF (UFENABLE)
6002   10A3~            ORG_UF	.EQU	$
6003   10A3~              #INCLUDE "uf.asm"
6004   10A3~            SIZ_UF	.EQU	$ - ORG_UF
6005   10A3~            		.ECHO	"UF occupies "
6006   10A3~            		.ECHO	SIZ_UF
6007   10A3~            		.ECHO	" bytes.\n"
6008   10A3             #ENDIF
6009   10A3             ;
6010   10A3~            #IF (VGAENABLE)
6011   10A3~            ORG_VGA	.EQU	$
6012   10A3~              #INCLUDE "vga.asm"
6013   10A3~            SIZ_VGA	.EQU	$ - ORG_VGA
6014   10A3~            		.ECHO	"VGA occupies "
6015   10A3~            		.ECHO	SIZ_VGA
6016   10A3~            		.ECHO	" bytes.\n"
6017   10A3             #ENDIF
6018   10A3             ;
6019   10A3~            #IF (CVDUENABLE)
6020   10A3~            ORG_CVDU	.EQU	$
6021   10A3~              #INCLUDE "cvdu.asm"
6022   10A3~            SIZ_CVDU	.EQU	$ - ORG_CVDU
6023   10A3~            		.ECHO	"CVDU occupies "
6024   10A3~            		.ECHO	SIZ_CVDU
6025   10A3~            		.ECHO	" bytes.\n"
6026   10A3             #ENDIF
6027   10A3             ;
6028   10A3~            #IF (VDUENABLE)
6029   10A3~            ORG_VDU		.EQU	$
6030   10A3~              #INCLUDE "vdu.asm"
6031   10A3~            SIZ_VDU		.EQU	$ - ORG_VDU
6032   10A3~            		.ECHO	"VDU occupies "
6033   10A3~            		.ECHO	SIZ_VDU
6034   10A3~            		.ECHO	" bytes.\n"
6035   10A3             #ENDIF
6036   10A3             ;
6037   10A3~            #IF (TMSENABLE)
6038   10A3~            ORG_TMS		.EQU	$
6039   10A3~              #INCLUDE "tms.asm"
6040   10A3~            SIZ_TMS		.EQU	$ - ORG_TMS
6041   10A3~            		.ECHO	"TMS occupies "
6042   10A3~            		.ECHO	SIZ_TMS
6043   10A3~            		.ECHO	" bytes.\n"
6044   10A3             #ENDIF
6045   10A3             ;
6046   10A3~            #IF (GDCENABLE)
6047   10A3~            ORG_GDC	.EQU	$
6048   10A3~              #INCLUDE "gdc.asm"
6049   10A3~            SIZ_GDC	.EQU	$ - ORG_GDC
6050   10A3~            		.ECHO	"GDC occupies "
6051   10A3~            		.ECHO	SIZ_GDC
6052   10A3~            		.ECHO	" bytes.\n"
6053   10A3             #ENDIF
6054   10A3             ;
6055   10A3~            #IF (DMAENABLE)
6056   10A3~            ORG_DMA	.EQU	$
6057   10A3~            #INCLUDE "dma.asm"
6058   10A3~            SIZ_DMA	.EQU	$ - ORG_DMA
6059   10A3~            		.ECHO	"DMA occupies "
6060   10A3~            		.ECHO	SIZ_DMA
6061   10A3~            		.ECHO	" bytes.\n"
6062   10A3             #ENDIF
6063   10A3             ;
6064   10A3             ; FONTS AREA
6065   10A3             ;
6066   10A3             ORG_FONTS	.EQU	$
6067   10A3             ;
6068   10A3             	.ECHO	"FONTS"
6069   10A3             ;
6070   10A3~            #IFDEF USEFONT8X8
6071   10A3~            FONT8X8:
6072   10A3~              #IF USELZSA2
6073   10A3~                #INCLUDE "font8x8c.asm"
6074   10A3~              #ELSE
6075   10A3~                #INCLUDE "font8x8u.asm"
6076   10A3~              #ENDIF
6077   10A3~            	.ECHO	" 8X8"
6078   10A3             #ENDIF
6079   10A3             ;
6080   10A3~            #IFDEF USEFONT8X11
6081   10A3~            FONT8X11:
6082   10A3~              #IF USELZSA2
6083   10A3~                #INCLUDE "font8x11c.asm"
6084   10A3~              #ELSE
6085   10A3~                #INCLUDE "font8x11u.asm"
6086   10A3~              #ENDIF
6087   10A3~            	.ECHO	" 8X11"
6088   10A3             #ENDIF
6089   10A3             ;
6090   10A3~            #IFDEF USEFONT8X16
6091   10A3~            FONT8X16:
6092   10A3~              #IF USELZSA2
6093   10A3~                #INCLUDE "font8x16c.asm"
6094   10A3~              #ELSE
6095   10A3~                #INCLUDE "font8x16u.asm"
6096   10A3~              #ENDIF
6097   10A3~            	.ECHO	" 8X16"
6098   10A3             #ENDIF
6099   10A3             ;
6100   10A3~            #IFDEF USEFONTCGA
6101   10A3~            FONTCGA:
6102   10A3~              #IF USELZSA2
6103   10A3~                #INCLUDE "fontcgac.asm"
6104   10A3~              #ELSE
6105   10A3~                #INCLUDE "fontcgau.asm"
6106   10A3~              #ENDIF
6107   10A3~            	.ECHO	" CGA"
6108   10A3             #ENDIF
6109   10A3             ;
6110   10A3             SIZ_FONTS	.EQU	$ - ORG_FONTS
6111   10A3             		.ECHO	" occupy "
6112   10A3             		.ECHO	SIZ_FONTS
6113   10A3             		.ECHO	" bytes.\n"
6114   10A3             ;
6115   10A3~            #IF (CVDUENABLE | VGAENABLE) | GDCENABLE | (TMSENABLE & ((TMSMODE == TMSMODE_MSXKBD) | (TMSMODE == TMSMODE_MBC)))
6116   10A3~            ORG_KBD		.EQU	$
6117   10A3~              #INCLUDE "kbd.asm"
6118   10A3~            SIZ_KBD		.EQU	$ - ORG_KBD
6119   10A3~            		.ECHO	"KBD occupies "
6120   10A3~            		.ECHO	SIZ_KBD
6121   10A3~            		.ECHO	" bytes.\n"
6122   10A3             #ENDIF
6123   10A3             ;
6124   10A3~            #IF (VDUENABLE | (TMSENABLE & (TMSMODE == TMSMODE_N8)))
6125   10A3~            ORG_PPK		.EQU	$
6126   10A3~              #INCLUDE "ppk.asm"
6127   10A3~            SIZ_PPK		.EQU	$ - ORG_PPK
6128   10A3~            		.ECHO	"PPK occupies "
6129   10A3~            		.ECHO	SIZ_PPK
6130   10A3~            		.ECHO	" bytes.\n"
6131   10A3             #ENDIF
6132   10A3             ;
6133   10A3~            #IF (MKYENABLE)
6134   10A3~            ORG_MKY		.EQU	$
6135   10A3~              #INCLUDE "mky.asm"
6136   10A3~            SIZ_MKY		.EQU	$ - ORG_MKY
6137   10A3~            		.ECHO	"MKY occupies "
6138   10A3~            		.ECHO	SIZ_MKY
6139   10A3~            		.ECHO	" bytes.\n"
6140   10A3             #ENDIF
6141   10A3             ;
6142   10A3~            #IF (PRPENABLE)
6143   10A3~            ORG_PRP		.EQU	$
6144   10A3~              #INCLUDE "prp.asm"
6145   10A3~            SIZ_PRP		.EQU	$ - ORG_PRP
6146   10A3~            		.ECHO	"PRP occupies "
6147   10A3~            		.ECHO	SIZ_PRP
6148   10A3~            		.ECHO	" bytes.\n"
6149   10A3             #ENDIF
6150   10A3             ;
6151   10A3~            #IF (PPPENABLE)
6152   10A3~            ORG_PPP		.EQU	$
6153   10A3~              #INCLUDE "ppp.asm"
6154   10A3~            SIZ_PPP		.EQU	$ - ORG_PPP
6155   10A3~            		.ECHO	"PPP occupies "
6156   10A3~            		.ECHO	SIZ_PPP
6157   10A3~            		.ECHO	" bytes.\n"
6158   10A3             #ENDIF
6159   10A3             ;
6160   10A3             #IF (MDENABLE)
6161   10A3             ORG_MD		.EQU	$
6162   10A3               #INCLUDE "md.asm"
0001+  10A3             ;
0002+  10A3             ;==================================================================================================
0003+  10A3             ;   MD DISK DRIVER (MEMORY DISK)
0004+  10A3             ;==================================================================================================
0005+  10A3             ;
0006+  10A3             ; MD DEVICE CONFIGURATION
0007+  10A3             ;
0008+  10A3             ;
0009+  10A3             ;       DISK DEVICE TYPE ID	MEDIA ID		ATTRIBUTE
0010+  10A3             ;--------------------------------------------------------------------------------------------------
0011+  10A3             ;	0x00 MEMORY DISK	0x02 RAM DRIVE		%00101000 HD STYLE, NON-REMOVABLE, TYPE-RAM
0012+  10A3             ;	0x00 MEMORY DISK	0x01 ROM DRIVE		%00100000 HD STYLE, NON-REMOVABLE, TYPE-ROM
0013+  10A3             ;	0x00 MEMORY DISK	0x01 ROM DRIVE		%00111000 HD STYLE, NON-REMOVABLE, TYPE-FLASH
0014+  10A3             ;
0015+  10A3             ;MD_DEVCNT	.EQU	2		; NUMBER OF MD DEVICES SUPPORTED
0016+  10A3             MD_CFGSIZ	.EQU	8		; SIZE OF CFG TBL ENTRIES
0017+  10A3             ;
0018+  10A3             MD_DEV		.EQU	0		; OFFSET OF DEVICE NUMBER (BYTE)
0019+  10A3             MD_STAT		.EQU	1		; OFFSET OF STATUS (BYTE)
0020+  10A3             MD_LBA		.EQU	2		; OFFSET OF LBA (DWORD)
0021+  10A3             MD_MID		.EQU	6		; OFFSET OF MEDIA ID (BYTE)
0022+  10A3             MD_ATTRIB	.EQU	7		; OFFSET OF ATTRIBUTE (BYTE)
0023+  10A3             ;
0024+  10A3             MD_AROM		.EQU	%00100000	; ROM ATTRIBUTE
0025+  10A3             MD_ARAM		.EQU	%00101000	; RAM ATTRIBUTE
0026+  10A3             MD_AFSH		.EQU	%00111000	; FLASH ATTRIBUTE
0027+  10A3             ;
0028+  10A3             MD_FDBG		.EQU	0		; FLASH DEBUG CODE
0029+  10A3             MD_FVBS		.EQU	1		; FLASH VERBOSE OUTPUT
0030+  10A3             MD_FVAR		.EQU	1		; FLASH VERIFY AFTER WRITE
0031+  10A3             ;
0032+  10A3             ; DEVICE CONFIG TABLE (RAM DEVICE FIRST TO MAKE IT ALWAYS FIRST DRIVE)
0033+  10A3             ;
0034+  10A3             MD_CFGTBL:
0035+  10A3             #IF (MDRAM)
0036+  10A3             	; DEVICE 0 (RAM)
0037+  10A3 00          	.DB	0			; DEVICE NUMBER
0038+  10A4 00          	.DB	0			; DEVICE STATUS
0039+  10A5 00 00 00 00 	.DW	0,0			; CURRENT LBA
0040+  10A9 02          	.DB	MID_MDRAM		; DEVICE MEDIA ID
0041+  10AA 28          	.DB	MD_ARAM			; DEVICE ATTRIBUTE
0042+  10AB             #ENDIF
0043+  10AB             ;
0044+  10AB             #IF (MDROM)
0045+  10AB             	; DEVICE 1 (ROM)
0046+  10AB 01          	.DB	1			; DEVICE NUMBER
0047+  10AC 00          	.DB	0			; DEVICE STATUS
0048+  10AD 00 00 00 00 	.DW	0,0			; CURRENT LBA
0049+  10B1 01          	.DB	MID_MDROM		; DEVICE MEDIA ID
0050+  10B2 20          	.DB	MD_AROM			; DEVICE ATTRIBUTE
0051+  10B3             #ENDIF
0052+  10B3             ;
0053+  10B3             MD_DEVCNT	.EQU	($ - MD_CFGTBL) / MD_CFGSIZ
0054+  10B3             ;
0055+  10B3~            #IF ($ - MD_CFGTBL) != (MD_DEVCNT * MD_CFGSIZ)
0056+  10B3~            	.ECHO	"*** INVALID MD CONFIG TABLE ***\n"
0057+  10B3             #ENDIF
0058+  10B3             ;
0059+  10B3 FF          	.DB	$FF			; END MARKER
0060+  10B4             ;
0061+  10B4             ;
0062+  10B4             ;
0063+  10B4             MD_INIT:
0064+  10B4~            #IF (MDFFENABLE)
0065+  10B4~            	CALL	MD_FINIT		; PROBE FLASH CAPABILITY
0066+  10B4             #ENDIF
0067+  10B4             ;
0068+  10B4 CD 20 19    	CALL	NEWLINE			; FORMATTING
0069+  10B7 CD 3B 19    	PRTS("MD: UNITS=$")
0069+  10BA 4D 44 3A 20 
0069+  10BE 55 4E 49 54 
0069+  10C2 53 3D 24 
0070+  10C5 3E 02       	LD	A,MD_DEVCNT
0071+  10C7 CD B2 1B    	CALL	PRTDECB
0072+  10CA             ;
0073+  10CA             #IF (MDROM)
0074+  10CA CD 3B 19    	PRTS(" ROMDISK=$")
0074+  10CD 20 52 4F 4D 
0074+  10D1 44 49 53 4B 
0074+  10D5 3D 24 
0075+  10D7             ;	LD	HL,ROMSIZE - 128
0076+  10D7 3A 0C 01    	LD	A,(HCB + HCB_ROMBANKS)	; GET NUMBER OF BANKS
0077+  10DA D6 04       	SUB	(TOT_ROM_RB)
0078+  10DC 6F          	LD	L,A
0079+  10DD 26 00       	LD	H,0			; CALCULATE RAM SIZE
0080+  10DF 29          	ADD	HL,HL			; X2
0081+  10E0 29          	ADD	HL,HL			; X4
0082+  10E1 29          	ADD	HL,HL			; X8
0083+  10E2 29          	ADD	HL,HL			; X16
0084+  10E3 29          	ADD	HL,HL			; X32
0085+  10E4 CD BE 1B    	CALL	PRTDEC
0086+  10E7 CD 3B 19    	PRTS("KB$")
0086+  10EA 4B 42 24    
0087+  10ED             #ENDIF
0088+  10ED             ;
0089+  10ED             #IF (MDRAM)
0090+  10ED CD 3B 19    	PRTS(" RAMDISK=$")
0090+  10F0 20 52 41 4D 
0090+  10F4 44 49 53 4B 
0090+  10F8 3D 24 
0091+  10FA             ;	LD	HL,RAMSIZE - 256
0092+  10FA 3A 0B 01    	LD	A,(HCB + HCB_RAMBANKS)	; GET NUMBER OF BANKS
0093+  10FD D6 08       	SUB	(TOT_RAM_RB)		; LESS RESERVED BANKS
0094+  10FF 6F          	LD	L,A
0095+  1100 26 00       	LD	H,0			; CALCULATE RAM SIZE
0096+  1102 29          	ADD	HL,HL			; X2
0097+  1103 29          	ADD	HL,HL			; X4
0098+  1104 29          	ADD	HL,HL			; X8
0099+  1105 29          	ADD	HL,HL			; X16
0100+  1106 29          	ADD	HL,HL			; X32
0101+  1107 CD BE 1B    	CALL	PRTDEC
0102+  110A CD 3B 19    	PRTS("KB$")
0102+  110D 4B 42 24    
0103+  1110             #ENDIF
0104+  1110             ;
0105+  1110             ; SETUP THE DIO TABLE ENTRIES
0106+  1110             ;
0107+  1110~            #IF (MDROM & MDFFENABLE)
0108+  1110~            	LD	A,(MD_FFSEN)		; IF FLASH 
0109+  1110~            	OR	A			; FILESYSTEM 
0110+  1110~            	JR	NZ,MD_INIT1		; CAPABLE, 
0111+  1110~            	LD	A,MD_AFSH		; UPDATE ROM DIO
0112+  1110~            	LD	(MD_CFGTBL + MD_CFGSIZ + MD_ATTRIB),A
0113+  1110~            MD_INIT1:
0114+  1110             #ENDIF
0115+  1110             ;
0116+  1110 11 A3 10    	LD	DE,MD_CFGTBL
0117+  1113             ;
0118+  1113             MD_INIT2:
0119+  1113 1A          	LD	A,(DE)			; FIRST BYTE OF CONFIG
0120+  1114 FE FF       	CP	$FF			; END OF TABLE?
0121+  1116 20 02       	JR	NZ,MD_INIT3		; IF NOT END OF TABLE, CONTINUE
0122+  1118 AF          	XOR	A			; SIGNAL SUCCESS
0123+  1119 C9          	RET				; AND RETURN
0124+  111A             ;
0125+  111A             MD_INIT3:
0126+  111A 01 2A 11    	LD	BC,MD_FNTBL		; BC IS FUNT TBL
0127+  111D D5          	PUSH	DE			; SAVE CFG PTR
0128+  111E CD 5A 08    	CALL	DIO_ADDENT		; ADD DIO TBL ENTRY
0129+  1121 D1          	POP	DE			; RECOVER CFG PTR
0130+  1122 EB          	EX	DE,HL			; CFG PTR TO HL
0131+  1123 01 08 00    	LD	BC,MD_CFGSIZ		; ENTRY SIZ TO BC
0132+  1126 09          	ADD	HL,BC			; BUMP TO NEXT ENTRY
0133+  1127 EB          	EX	DE,HL			; CFG PTR BACK TO DE
0134+  1128 18 E9       	JR	MD_INIT2		; REPEAT
0135+  112A             ;
0136+  112A             ;
0137+  112A             ;
0138+  112A             MD_FNTBL:
0139+  112A 49 11       	.DW	MD_STATUS
0140+  112C 49 11       	.DW	MD_RESET
0141+  112E 9E 11       	.DW	MD_SEEK
0142+  1130 B3 11       	.DW	MD_READ
0143+  1132 BF 11       	.DW	MD_WRITE
0144+  1134 42 11       	.DW	MD_VERIFY
0145+  1136 42 11       	.DW	MD_FORMAT
0146+  1138 89 11       	.DW	MD_DEVICE
0147+  113A 97 11       	.DW	MD_MEDIA
0148+  113C 42 11       	.DW	MD_DEFMED
0149+  113E 4B 11       	.DW	MD_CAP
0150+  1140 76 11       	.DW	MD_GEOM
0151+  1142~            #IF (($ - MD_FNTBL) != (DIO_FNCNT * 2))
0152+  1142~            	.ECHO	"*** INVALID MD FUNCTION TABLE ***\n"
0153+  1142             #ENDIF
0154+  1142             ;
0155+  1142             ;
0156+  1142             ;
0157+  1142             MD_VERIFY:
0158+  1142             MD_FORMAT:
0159+  1142             MD_DEFMED:
0160+  1142             	SYSCHKERR(ERR_NOTIMPL)		; INVALID SUB-FUNCTION
0160+  1142             
0160+  1142 CD 60 23    
0160+  1145 3E FE       
0160+  1147 B7          
0161+  1148 C9          	RET
0162+  1149             ;
0163+  1149             ;
0164+  1149             ;
0165+  1149             MD_STATUS:
0166+  1149             ;	XOR	A			; ALWAYS OK
0167+  1149             ;	RET
0168+  1149             ;
0169+  1149             ;
0170+  1149             ;
0171+  1149             MD_RESET:
0172+  1149 AF          	XOR	A			; ALWAYS OK
0173+  114A C9          	RET
0174+  114B             ;
0175+  114B             ;
0176+  114B             ;	
0177+  114B             MD_CAP:					; ASSUMES THAT UNIT 0 IS RAM, UNIT 1 IS ROM
0178+  114B FD 7E 00    	LD	A,(IY+MD_DEV)		; GET DEVICE NUMBER
0179+  114E B7          	OR	A			; SET FLAGS
0180+  114F 28 0A       	JR	Z,MD_CAP0		; UNIT 0
0181+  1151 3D          	DEC	A			; TRY UNIT 1
0182+  1152 28 0E       	JR	Z,MD_CAP1		; UNIT 1
0183+  1154             	SYSCHKERR(ERR_NOUNIT)		; INVALID UNIT
0183+  1154             
0183+  1154 CD 60 23    
0183+  1157 3E FC       
0183+  1159 B7          
0184+  115A C9          	RET
0185+  115B             MD_CAP0:
0186+  115B 3A 0B 01    	LD	A,(HCB + HCB_RAMBANKS)	; POINT TO RAM BANK COUNT
0187+  115E 06 08       	LD	B,TOT_RAM_RB		; SET # RESERVED RAM BANKS
0188+  1160 18 05       	JR	MD_CAP2
0189+  1162             MD_CAP1:
0190+  1162 3A 0C 01    	LD	A,(HCB + HCB_ROMBANKS)	; POINT TO ROM BANK COUNT
0191+  1165 06 04       	LD	B,TOT_ROM_RB		; SET # RESERVED ROM BANKS
0192+  1167             MD_CAP2:
0193+  1167 90          	SUB	B			; SUBTRACT OUT RESERVED BANKS
0194+  1168 67          	LD	H,A			; H := # BANKS
0195+  1169 1E 40       	LD	E,64			; # 512 BYTE BLOCKS / BANK
0196+  116B CD 3E 1B    	CALL	MULT8			; HL := TOTAL # 512 BYTE BLOCKS
0197+  116E 11 00 00    	LD	DE,0			; NEVER EXCEEDS 64K, ZERO HIGH WORD
0198+  1171 01 00 02    	LD	BC,512			; 512 BYTE SECTOR
0199+  1174 AF          	XOR	A
0200+  1175 C9          	RET
0201+  1176             ;
0202+  1176             ;
0203+  1176             ;
0204+  1176             MD_GEOM:
0205+  1176             	; RAM/ROM DISKS ALLOW CHS STYLE ACCESS BY EMULATING
0206+  1176             	; A DISK DEVICE WITH 1 HEAD AND 16 SECTORS / TRACK.
0207+  1176 CD 4B 11    	CALL	MD_CAP			; HL := CAPACITY IN BLOCKS
0208+  1179 C5          	PUSH	BC			; SAVE SECTOR SIZE
0209+  117A 16 81       	LD	D,1 | $80		; HEADS / CYL := 1 BY DEFINITION, SET LBA CAPABILITY BIT
0210+  117C 1E 10       	LD	E,16			; SECTORS / TRACK := 16 BY DEFINITION
0211+  117E 06 04       	LD	B,4			; PREPARE TO DIVIDE BY 16
0212+  1180             MD_GEOM1:
0213+  1180 CB 3C       	SRL	H			; SHIFT H
0214+  1182 CB 1D       	RR	L			; SHIFT L
0215+  1184 10 FA       	DJNZ	MD_GEOM1		; DO 4 BITS TO DIVIDE BY 16
0216+  1186 C1          	POP	BC			; RECOVER SECTOR SIZE
0217+  1187 AF          	XOR	A			; SIGNAL SUCCESS
0218+  1188 C9          	RET				; DONE
0219+  1189             ;
0220+  1189             ;
0221+  1189             ;
0222+  1189             MD_DEVICE:
0223+  1189 16 00       	LD	D,DIODEV_MD		; D := DEVICE TYPE - ALL ARE MEMORY DISKS
0224+  118B FD 5E 00    	LD	E,(IY+MD_DEV)		; GET DEVICE NUMBER
0225+  118E FD 4E 07    	LD	C,(IY+MD_ATTRIB)	; GET ATTRIBUTE
0226+  1191 26 00       	LD	H,0			; H := 0, DRIVER HAS NO MODES
0227+  1193 2E 00       	LD	L,0			; L := 0, NO BASE I/O ADDRESS
0228+  1195 AF          	XOR	A			; SIGNAL SUCCESS
0229+  1196 C9          	RET
0230+  1197             ;
0231+  1197             ;
0232+  1197             ;
0233+  1197             MD_MEDIA:
0234+  1197 FD 5E 06    	LD	E,(IY+MD_MID)		; GET MEDIA ID
0235+  119A 16 00       	LD	D,0			; D:0=0 MEANS NO MEDIA CHANGE
0236+  119C AF          	XOR	A			; SIGNAL SUCCESS
0237+  119D C9          	RET
0238+  119E             ;
0239+  119E             ;
0240+  119E             ;
0241+  119E             MD_SEEK:
0242+  119E CB 7A       	BIT	7,D			; CHECK FOR LBA FLAG
0243+  11A0 CC 4D 29    	CALL	Z,HB_CHS2LBA		; CLEAR MEANS CHS, CONVERT TO LBA
0244+  11A3 CB BA       	RES	7,D			; CLEAR FLAG REGARDLESS (DOES NO HARM IF ALREADY LBA)
0245+  11A5 FD 75 02    	LD	(IY+MD_LBA+0),L		; SAVE NEW LBA
0246+  11A8 FD 74 03    	LD	(IY+MD_LBA+1),H		; ...
0247+  11AB FD 73 04    	LD	(IY+MD_LBA+2),E		; ...
0248+  11AE FD 72 05    	LD	(IY+MD_LBA+3),D		; ...
0249+  11B1 AF          	XOR	A			; SIGNAL SUCCESS
0250+  11B2 C9          	RET				; AND RETURN
0251+  11B3             ;
0252+  11B3             ;
0253+  11B3             ;
0254+  11B3             MD_READ:
0255+  11B3 CD A3 08    	CALL	HB_DSKREAD		; HOOK HBIOS DISK READ SUPERVISOR
0256+  11B6             ;
0257+  11B6             ;	HL  POINTS TO HB_WRKBUF
0258+  11B6             ;
0259+  11B6~            #IF (MDFFENABLE)
0260+  11B6~            	LD	A,(IY+MD_ATTRIB)	; GET ADR OF SECTOR READ FUNC
0261+  11B6~            	LD	BC,MD_RDSECF		; 
0262+  11B6~            	CP	MD_AFSH			; RAM / ROM = MD_RDSEC
0263+  11B6~            	JR	Z,MD_RD1		; FLASH     = MD_RDSECF
0264+  11B6             #ENDIF
0265+  11B6 01 02 12    	LD	BC,MD_RDSEC
0266+  11B9             MD_RD1:
0267+  11B9 ED 43 5C 12 	LD	(MD_RWFNADR),BC		; SAVE IT AS PENDING IO FUNC
0268+  11BD 18 17       	JR	MD_RW			; CONTINUE TO GENERIC R/W ROUTINE
0269+  11BF             ;
0270+  11BF             ;
0271+  11BF             ;
0272+  11BF             MD_WRITE:
0273+  11BF CD F6 08    	CALL	HB_DSKWRITE		; HOOK HBIOS DISK WRITE SUPERVISOR
0274+  11C2             ;
0275+  11C2~            #IF (MDFFENABLE)
0276+  11C2~            	LD	A,(IY+MD_ATTRIB)	; GET ADR OF SECTOR WRITE FUNC
0277+  11C2~            	LD	BC,MD_WRSECF		; 
0278+  11C2~            	CP	MD_AFSH			; RAM / ROM = MD_WRSEC
0279+  11C2~            	JR	Z,MD_WR1		; FLASH     = MD_WRSECF
0280+  11C2             #ENDIF
0281+  11C2 01 19 12    	LD	BC,MD_WRSEC
0282+  11C5             MD_WR1:
0283+  11C5             
0284+  11C5 ED 43 5C 12 	LD	(MD_RWFNADR),BC		; SAVE IT AS PENDING IO FUNC
0285+  11C9 FD 7E 07    	LD	A,(IY+MD_ATTRIB)	; IF THE DEVICES ATTRIBUTE
0286+  11CC FE 20       	CP	MD_AROM			; IS NOT ROM THEN WE CAN
0287+  11CE 20 06       	JR	NZ,MD_RW		; WRITE TO IT
0288+  11D0 1E 00       	LD	E,0			; UNIT IS READ ONLY, ZERO SECTORS WRITTEN
0289+  11D2 3E F6       	LD	A,ERR_READONLY		; SIGNAL ERROR
0290+  11D4 B7          	OR	A			; SET FLAGS
0291+  11D5 C9          	RET				; AND DONE
0292+  11D6             ;
0293+  11D6             ;
0294+  11D6             ;
0295+  11D6             MD_RW:
0296+  11D6 22 5E 12    	LD	(MD_DSKBUF),HL		; SAVE DISK BUFFER ADDRESS
0297+  11D9 7B          	LD	A,E			; BLOCK COUNT TO A
0298+  11DA B7          	OR	A			; SET FLAGS
0299+  11DB C8          	RET	Z			; ZERO SECTOR I/O, RETURN W/ E=0 & A=0
0300+  11DC 47          	LD	B,A			; INIT SECTOR DOWNCOUNTER
0301+  11DD 0E 00       	LD	C,0			; INIT SECTOR READ/WRITE COUNT
0302+  11DF             MD_RW1:
0303+  11DF C5          	PUSH	BC			; SAVE COUNTERS
0304+  11E0             ;
0305+  11E0~            #IF (DSKYENABLE)
0306+  11E0~            	LD	A,MD_LBA
0307+  11E0~            	CALL	LDHLIYA
0308+  11E0~            	CALL	HB_DSKACT		; SHOW ACTIVITY
0309+  11E0             #ENDIF
0310+  11E0             ;
0311+  11E0 2A 5C 12    	LD	HL,(MD_RWFNADR)		; GET PENDING IO FUNCTION ADDRESS
0312+  11E3~            #IF (MDFFENABLE)
0313+  11E3~            	PUSH	IX
0314+  11E3~            	CALL	JPHL			; ... AND CALL IT
0315+  11E3~            	POP	IX
0316+  11E3             #ELSE
0317+  11E3 CD CD 1A    	CALL	JPHL			; ... AND CALL IT
0318+  11E6             #ENDIF
0319+  11E6 20 0E       	JR	NZ,MD_RW2		; IF ERROR, SKIP INCREMENT
0320+  11E8             	; INCREMENT LBA
0321+  11E8 3E 02       	LD	A,MD_LBA		; LBA OFFSET IN CFG ENTRY
0322+  11EA CD 45 29    	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
0323+  11ED CD D8 1C    	CALL	INC32HL			; INCREMENT THE VALUE
0324+  11F0             	; INCREMENT DMA
0325+  11F0 21 5F 12    	LD	HL,MD_DSKBUF+1		; POINT TO MSB OF BUFFER ADR
0326+  11F3 34          	INC	(HL)			; BUMP DMA BY
0327+  11F4 34          	INC	(HL)			; ... 512 BYTES
0328+  11F5 AF          	XOR	A			; SIGNAL SUCCESS
0329+  11F6             MD_RW2:
0330+  11F6 C1          	POP	BC			; RECOVER COUNTERS
0331+  11F7 20 03       	JR	NZ,MD_RW3		; IF ERROR, BAIL OUT
0332+  11F9 0C          	INC	C			; BUMP COUNT OF SECTORS READ
0333+  11FA 10 E3       	DJNZ	MD_RW1			; LOOP AS NEEDED
0334+  11FC             MD_RW3:
0335+  11FC 59          	LD	E,C			; SECTOR READ COUNT TO E
0336+  11FD 2A 5E 12    	LD	HL,(MD_DSKBUF)		; CURRENT DMA TO HL
0337+  1200 B7          	OR	A			; SET FLAGS BASED ON RETURN CODE
0338+  1201 C9          	RET				; AND RETURN, A HAS RETURN CODE
0339+  1202             ;
0340+  1202             ; READ FLASH
0341+  1202             ;
0342+  1202~            #IF (MDFFENABLE)
0343+  1202~            MD_RDSECF:				; CALLED FROM MD_RW
0344+  1202~            ;
0345+  1202~            	CALL	MD_IOSETUPF		; SETUP SOURCE ADDRESS
0346+  1202~            ;
0347+  1202~            	PUSH	HL			; IS THE SECTOR
0348+  1202~            	LD	HL,(MD_LBA4K)		; WE WANT TO
0349+  1202~            	XOR	A			; READ ALREADY
0350+  1202~            	SBC	HL,BC			; IN THE 4K
0351+  1202~            	POP	HL			; BLOCK WE HAVE
0352+  1202~            	JR	Z,MD_SECM		; IN THE BUFFER?
0353+  1202~            ;
0354+  1202~            					; DESIRED SECTOR IS NOT IN BUFFER
0355+  1202~            	LD	(MD_LBA4K),BC		; WE WILL READ IN A NEW 4K SECTOR.
0356+  1202~            					; SAVE THE 4K LBA FOR FUTURE CHECKS
0357+  1202~            ;
0358+  1202~            	CALL	MD_CALBAS		; SETUP BANK AND SECTOR
0359+  1202~            ;
0360+  1202~            	LD	IX,MD_F4KBUF		; SET DESTINATION ADDRESS
0361+  1202~            	LD	HL,MD_FREAD_R		; PUT ROUTINE TO CALL
0362+  1202~            	CALL	MD_FNCALL		; EXECUTE: READ 4K SECTOR
0363+  1202~            ;
0364+  1202~            MD_SECM:
0365+  1202~            	LD	A,(IY+MD_LBA+0)		; GET SECTOR WITHIN 4K BLOCK
0366+  1202~            	AND	%00000111		; AND CALCULATE OFFSET OFFSET
0367+  1202~            	ADD	A,A
0368+  1202~            	LD	D,A			; FROM THE START
0369+  1202~            	LD	E,0
0370+  1202~            ;
0371+  1202~            	LD	HL,MD_F4KBUF		; POINT TO THE SECTOR WE 
0372+  1202~            	ADD	HL,DE			; WANT TO COPY
0373+  1202~            	LD	DE,(MD_DSKBUF)
0374+  1202~            ;
0375+  1202~            #IF (DMAENABLE & (DMAMODE!=DMAMODE_NONE))
0376+  1202~            #IF (DMA_FBACK)
0377+  1202~            	LD	A,(DMA_FAIL_FLAG)
0378+  1202~            	OR	A
0379+  1202~            	JR	NZ,MD_NODMA
0380+  1202~            #ENDIF
0381+  1202~            	LD	BC,512-1		; COPY ONE 512B SECTOR FROM THE
0382+  1202~            	JP	DMALDIR			; 4K SECTOR TO THE DISK BUFFER
0383+  1202~            #ENDIF
0384+  1202~            MD_NODMA:
0385+  1202~            #IF (!(DMAENABLE & (DMAMODE!=DMAMODE_NONE)))	
0386+  1202~            	LD	BC,512			; COPY ONE 512B SECTOR FROM THE
0387+  1202~            	LDIR				; 4K SECTOR TO THE DISK BUFFER
0388+  1202~            	XOR	A
0389+  1202~            	RET
0390+  1202~            #ELSE
0391+  1202~            #IF  (DMA_FBACK)
0392+  1202~            	LD	BC,512			; COPY ONE 512B SECTOR FROM THE
0393+  1202~            	LDIR				; 4K SECTOR TO THE DISK BUFFER
0394+  1202~            	XOR	A
0395+  1202~            	RET
0396+  1202~            #ENDIF
0397+  1202~            #ENDIF
0398+  1202~            ;
0399+  1202~            ; SETUP DE:HL AS THE SECTOR ADDRESS TO READ OR WRITE
0400+  1202~            ;
0401+  1202~            ; ON EXIT
0402+  1202~            ;  BC    = LBA 4K BLOCK WE ARE ACCESSING
0403+  1202~            ;  DE:HL = MEMORY ADDRESS TO ACCESS IN FLASH
0404+  1202~            ;
0405+  1202~            MD_IOSETUPF:
0406+  1202~            	LD	L,(IY+MD_LBA+0)		; HL := LOW WORD OF LBA
0407+  1202~            	LD	H,(IY+MD_LBA+1)		
0408+  1202~            	INC	H			; SKIP FIRST 128MB (256 SECTORS)
0409+  1202~            ;
0410+  1202~            	LD	A,L			; SAVE LBA 4K
0411+  1202~            	AND	%11111000		; BLOCK WE ARE
0412+  1202~            	LD	C,A			; GOING TO
0413+  1202~            	LD	B,H			; ACCESS
0414+  1202~            ;
0415+  1202~            	LD	D,0			; CONVERT LBA
0416+  1202~            	LD	E,H			; TO ADDRESS
0417+  1202~            	LD	H,L			; MULTIPLY BY 512
0418+  1202~            	LD	L,D			; DE:HL = HLX512
0419+  1202~            	SLA	H
0420+  1202~            	RL	E
0421+  1202~            	RL	D	
0422+  1202~            ;
0423+  1202~            	RET
0424+  1202~            ;
0425+  1202~            ;======================================================================
0426+  1202~            ; CALCULATE BANK AND ADDRESS DATA FROM MEMORY ADDRESS
0427+  1202~            ;
0428+  1202~            ; ON ENTRY DE:HL CONTAINS 32 BIT MEMORY ADDRESS.
0429+  1202~            ; ON EXIT  B     CONTAINS BANK SELECT BYTE
0430+  1202~            ;          C     CONTAINS HIGH BYTE OF SECTOR ADDRESS
0431+  1202~            ;
0432+  1202~            ; DDDDDDDDEEEEEEEE HHHHHHHHLLLLLLLL
0433+  1202~            ; 3322222222221111 1111110000000000
0434+  1202~            ; 1098765432109876 5432109876543210
0435+  1202~            ; XXXXXXXXXXXXSSSS SSSSXXXXXXXXXXXX < S = SECTOR
0436+  1202~            ; XXXXXXXXXXXXBBBB BXXXXXXXXXXXXXXX < B = BANK
0437+  1202~            ;======================================================================
0438+  1202~            ;
0439+  1202~            MD_CALBAS:
0440+  1202~            ;
0441+  1202~            #IF (MD_FDBG==1)
0442+  1202~            	CALL	PC_SPACE		; DISPLAY SECTOR
0443+  1202~            	CALL	PRTHEX32		; SECTOR ADDRESS 
0444+  1202~            	CALL	PC_SPACE		; IN DE:HL
0445+  1202~            #ENDIF
0446+  1202~            ;
0447+  1202~            	PUSH	HL
0448+  1202~            	LD	A,E			; BOTTOM PORTION OF SECTOR
0449+  1202~            	AND	$0F			; ADDRESS THAT GETS WRITTEN
0450+  1202~            	RLC	H			; WITH ERASE COMMAND BYTE
0451+  1202~            	RLA				; A15 GETS DROPPED OFF AND
0452+  1202~            	LD	B,A			; ADDED TO BANK SELECT
0453+  1202~            ;
0454+  1202~            	LD	A,H			; TOP SECTION OF SECTOR
0455+  1202~            	RRA				; ADDRESS THAT GETS WRITTEN
0456+  1202~            	AND	$70			; TO BANK SELECT PORT
0457+  1202~            	LD	C,A
0458+  1202~            
0459+  1202~            	POP	HL
0460+  1202~            ;
0461+  1202~            	LD	(MD_FBAS),BC		; SAVE BANK AND SECTOR FOR USE IN FLASH ROUTINES
0462+  1202~            ;
0463+  1202~            #IF (MD_FDBG==1)
0464+  1202~            	CALL	PRTHEXWORD		; DISPLAY BANK AND
0465+  1202~            	CALL	PC_SPACE		; SECTOR RESULT
0466+  1202~            #ENDIF
0467+  1202~            
0468+  1202~            	RET
0469+  1202~            ;
0470+  1202~            ; WRITE FLASH
0471+  1202~            ;
0472+  1202~            MD_WRSECF:				; CALLED FROM MD_RW
0473+  1202~            	CALL	MD_IOSETUPF		; SETUP DESTINATION ADDRESS
0474+  1202~            ;
0475+  1202~            	PUSH	HL			; IS THE SECTOR
0476+  1202~            	LD	HL,(MD_LBA4K)		; WE WANT TO
0477+  1202~            	XOR	A			; WRITE ALREADY
0478+  1202~            	SBC	HL,BC			; IN THE 4K 
0479+  1202~            	POP	HL			; BLOCK WE HAVE
0480+  1202~            	JR	Z,MD_SECM1		; IN THE BUFFER
0481+  1202~            ;
0482+  1202~            	LD	(MD_LBA4K),BC		; SAVE 4K LBA
0483+  1202~            ;
0484+  1202~            	CALL	MD_CALBAS		; SETUP BANK AND SECTOR
0485+  1202~            ;
0486+  1202~            	LD	IX,MD_F4KBUF		; SET DESTINATION ADDRESS
0487+  1202~            	LD	HL,MD_FREAD_R		; PUT ROUTINE TO CALL
0488+  1202~            	CALL	MD_FNCALL		; EXECUTE: READ 4K SECTOR
0489+  1202~            ;
0490+  1202~            MD_SECM1:				; DESIRED SECTOR IS IN BUFFER
0491+  1202~            	LD	HL,MD_FERAS_R		; PUT ROUTINE TO CALL
0492+  1202~            	CALL	MD_FNCALL		; EXECUTE: ERASE 4K SECTOR
0493+  1202~            	OR	A
0494+  1202~            	RET	NZ			; RETURN IF ERROR
0495+  1202~            	;
0496+  1202~            	; COPY 512B SECTOR INTO 4K SECTOR
0497+  1202~            	;
0498+  1202~            	LD	A,(IY+MD_LBA+0)		; GET SECTOR WITHIN 4K BLOCK
0499+  1202~            	AND	%00000111		; AND CALCULATE OFFSET OFFSET
0500+  1202~            	ADD	A,A
0501+  1202~            	LD	D,A			; FROM THE START
0502+  1202~            	LD	E,0
0503+  1202~            ;
0504+  1202~            	LD	HL,MD_F4KBUF		; POINT TO THE SECTOR WE 
0505+  1202~            	ADD	HL,DE			; WANT TO COPY
0506+  1202~            	EX	DE,HL
0507+  1202~            ;
0508+  1202~            	LD	HL,(MD_DSKBUF)
0509+  1202~            #IF (DMAENABLE & (DMAMODE!=DMAMODE_NONE))
0510+  1202~            #IF (DMA_FBACK)
0511+  1202~            	LD	A,(DMA_FAIL_FLAG)
0512+  1202~            	OR	A
0513+  1202~            	JR	NZ,MD_NODMA1
0514+  1202~            #ENDIF
0515+  1202~            	LD	BC,512-1		; COPY ONE 512B SECTOR FROM THE
0516+  1202~            	CALL	DMALDIR			; THE DISK BUFFER TO 4K SECTOR
0517+  1202~            	RET	NZ			; EXIT IF DMA COPY ERROR
0518+  1202~            	JR	MD_NODMAERR
0519+  1202~            #ENDIF
0520+  1202~            MD_NODMA1:
0521+  1202~            #IF (!(DMAENABLE & (DMAMODE!=DMAMODE_NONE)))
0522+  1202~            	LD	BC,512			; COPY ONE 512B SECTOR FROM THE
0523+  1202~            	LDIR
0524+  1202~            #ELSE
0525+  1202~            #IF  (DMA_FBACK)			; THE DISK BUFFER TO 4K SECTOR
0526+  1202~            	LD	BC,512
0527+  1202~            	LDIR
0528+  1202~            #ENDIF
0529+  1202~            #ENDIF
0530+  1202~            MD_NODMAERR:
0531+  1202~            	LD	IX,MD_F4KBUF		; SET SOURCE ADDRESS
0532+  1202~            	LD	HL,MD_FWRIT_R		; PUT ROUTINE TO CALL
0533+  1202~            	CALL	MD_FNCALL		; EXECUTE: WRITE 4K SECTOR
0534+  1202~            ;
0535+  1202~            	XOR	A			; PRESUME SUCCESS STATUS
0536+  1202~            ;
0537+  1202~            #IF (MD_FVAR==1)
0538+  1202~            	LD	IX,MD_F4KBUF		; SET SOURCE ADDRESS
0539+  1202~            	LD	HL,MD_FVERI_R		; PUT ROUTINE TO CALL
0540+  1202~            	CALL	MD_FNCALL		; EXECUTE: VERIFY 4K SECTOR
0541+  1202~            ;
0542+  1202~            	OR	A
0543+  1202~            	RET	Z			; RETURN IF SUCCESSFUL
0544+  1202~            ;
0545+  1202~            	LD	IX,MD_F4KBUF		; SET SOURCE ADDRESS		; RETRY
0546+  1202~            	LD	HL,MD_FWRIT_R		; PUT ROUTINE TO CALL		; WRITE
0547+  1202~            	CALL	MD_FNCALL		; EXECUTE: WRITE 4K SECTOR	; ONCE
0548+  1202~            ;
0549+  1202~            	LD	IX,MD_F4KBUF		; SET SOURCE ADDRESS		; VERIFY
0550+  1202~            	LD	HL,MD_FVERI_R		; PUT ROUTINE TO CALL		; AGAIN
0551+  1202~            	CALL	MD_FNCALL		; EXECUTE: VERIFY 4K SECTOR
0552+  1202~            ;
0553+  1202~            	OR	A			; SET FINAL STATUS AFTER RETRY
0554+  1202~            #ENDIF
0555+  1202~            ;
0556+  1202~            	RET
0557+  1202~            ;
0558+  1202~            MD_LBA4K	.DW	$FFFF		; LBA OF CURRENT SECTOR
0559+  1202~            MD_FBAS		.DW	$FFFF		; BANK AND SECTOR
0560+  1202             #ENDIF
0561+  1202             ;
0562+  1202             ; READ RAM / ROM 
0563+  1202             ;
0564+  1202             MD_RDSEC:
0565+  1202 CD 31 12    	CALL	MD_IOSETUP		; SETUP FOR MEMORY COPY
0566+  1205~            #IF (MDTRACE >= 2)
0567+  1205~            	LD	(MD_SRC),HL
0568+  1205~            	LD	(MD_DST),DE
0569+  1205~            	LD	(MD_LEN),BC
0570+  1205             #ENDIF
0571+  1205 C5          	PUSH	BC
0572+  1206 4F          	LD	C,A			; SOURCE BANK
0573+  1207 06 8D       	LD	B,BID_BIOS		; DESTINATION BANK IS RAM BANK 1 (HBIOS)
0574+  1209~            #IF (MDTRACE >= 2)
0575+  1209~            	LD	(MD_SRCBNK),BC
0576+  1209~            	CALL	MD_PRT
0577+  1209             #ENDIF
0578+  1209 79          	LD	A,C			; GET SOURCE BANK
0579+  120A 32 E4 FF    	LD	(HB_SRCBNK),A		; SET IT
0580+  120D 78          	LD	A,B			; GET DESTINATION BANK
0581+  120E 32 E7 FF    	LD	(HB_DSTBNK),A		; SET IT
0582+  1211 C1          	POP	BC
0583+  1212             #IF (INTMODE == 1)
0584+  1212 F3          	DI
0585+  1213             #ENDIF
0586+  1213 CD F6 FF    	CALL	HB_BNKCPY		; DO THE INTERBANK COPY
0587+  1216             #IF (INTMODE == 1)
0588+  1216 FB          	EI
0589+  1217             #ENDIF
0590+  1217 AF          	XOR	A
0591+  1218 C9          	RET
0592+  1219             ;
0593+  1219             ; WRITE RAM
0594+  1219             ;
0595+  1219             MD_WRSEC:
0596+  1219 CD 31 12    	CALL	MD_IOSETUP		; SETUP FOR MEMORY COPY
0597+  121C EB          	EX	DE,HL			; SWAP SRC/DEST FOR WRITE
0598+  121D~            #IF (MDTRACE >= 2)
0599+  121D~            	LD	(MD_SRC),HL
0600+  121D~            	LD	(MD_DST),DE
0601+  121D~            	LD	(MD_LEN),BC
0602+  121D             #ENDIF
0603+  121D C5          	PUSH	BC
0604+  121E 0E 8D       	LD	C,BID_BIOS		; SOURCE BANK IS RAM BANK 1 (HBIOS)
0605+  1220 47          	LD	B,A			; DESTINATION BANK
0606+  1221~            #IF (MDTRACE >= 2)
0607+  1221~            	LD	(MD_SRCBNK),BC
0608+  1221~            	CALL	MD_PRT
0609+  1221             #ENDIF
0610+  1221 79          	LD	A,C			; GET SOURCE BANK
0611+  1222 32 E4 FF    	LD	(HB_SRCBNK),A		; SET IT
0612+  1225 78          	LD	A,B			; GET DESTINATION BANK
0613+  1226 32 E7 FF    	LD	(HB_DSTBNK),A		; SET IT
0614+  1229 C1          	POP	BC
0615+  122A             #IF (INTMODE == 1)
0616+  122A F3          	DI
0617+  122B             #ENDIF
0618+  122B CD F6 FF    	CALL	HB_BNKCPY		; DO THE INTERBANK COPY
0619+  122E             #IF (INTMODE == 1)
0620+  122E FB          	EI
0621+  122F             #ENDIF
0622+  122F AF          	XOR	A
0623+  1230 C9          	RET
0624+  1231             ;
0625+  1231             ; SETUP FOR MEMORY COPY
0626+  1231             ;   A=BANK SELECT
0627+  1231             ;   BC=COPY SIZE
0628+  1231             ;   DE=DESTINATION
0629+  1231             ;   HL=SOURCE
0630+  1231             ;
0631+  1231             ; ASSUMES A "READ" OPERATION.  HL AND DE CAN BE SWAPPED
0632+  1231             ; AFTERWARDS TO ACHIEVE A WRITE OPERATION
0633+  1231             ;
0634+  1231             ; ON INPUT, WE HAVE LBA ADDRESSING IN HSTLBAHI:HSTLBALO
0635+  1231             ; BUT WE NEVER HAVE MORE THAN $FFFF BLOCKS IN A RAM/ROM DISK,
0636+  1231             ; SO THE HIGH WORD (HSTLBAHI) IS IGNORED
0637+  1231             ;
0638+  1231             ; EACH RAM/ROM BANK IS 32K BY DEFINITION AND EACH SECTOR IS 512
0639+  1231             ; BYTES BY DEFINITION.	SO, EACH RAM/ROM BANK CONTAINS 64 SECTORS
0640+  1231             ; (32,768 / 512 = 64).	THEREFORE, YOU CAN THINK OF LBA AS
0641+  1231             ; 00000BBB:BBOOOOOO IS WHERE THE 'B' BITS REPRESENT THE BANK NUMBER
0642+  1231             ; AND THE 'O' BITS REPRESENT THE SECTOR NUMBER WITHIN THE BANK.
0643+  1231             ;
0644+  1231             ; TO EXTRACT THE BANK NUMBER, WE CAN LEFT SHIFT TWICE TO GIVE US:
0645+  1231             ; 000BBBBB:OOOOOOOO.  FROM THIS WE CAN EXTRACT THE MSB
0646+  1231             ; TO USE AS THE BANK NUMBER.  NOTE THAT THE "RAW" BANK NUMBER MUST THEN
0647+  1231             ; BE OFFSET TO THE START OF THE ROM/RAM BANKS.
0648+  1231             ; ALSO NOTE THAT THE HIGH BIT OF THE BANK NUMBER REPRESENTS "RAM" SO THIS
0649+  1231             ; BIT MUST ALSO BE SET ACCORDING TO THE UNIT BEING ADDRESSED.
0650+  1231             ;
0651+  1231             ; TO GET THE BYTE OFFSET, WE THEN RIGHT SHIFT THE LSB BY 1 TO GIVE US:
0652+  1231             ; 0OOOOOOO AND EXTRACT THE LSB TO REPRESENT THE MSB OF
0653+  1231             ; THE BYTE OFFSET.  THE LSB OF THE BYTE OFFSET IS ALWAYS 0 SINCE WE ARE
0654+  1231             ; DEALING WITH 512 BYTE BOUNDARIES.
0655+  1231             ;
0656+  1231             MD_IOSETUP:
0657+  1231 FD 6E 02    	LD	L,(IY+MD_LBA+0)		; HL := LOW WORD OF LBA
0658+  1234 FD 66 03    	LD	H,(IY+MD_LBA+1)		; ...
0659+  1237             	; ALIGN BITS TO EXTRACT BANK NUMBER FROM H
0660+  1237 CB 25       	SLA	L			; LEFT SHIFT ONE BIT
0661+  1239 CB 14       	RL	H			;   FULL WORD
0662+  123B CB 25       	SLA	L			; LEFT SHIFT ONE BIT
0663+  123D CB 14       	RL	H			;   FULL WORD
0664+  123F 4C          	LD	C,H			; BANK NUMBER FROM H TO C
0665+  1240             	; GET BANK NUM TO A AND SET FLAG Z=ROM, NZ=RAM
0666+  1240 FD 7E 00    	LD	A,(IY+MD_DEV)		; DEVICE TO A
0667+  1243 E6 01       	AND	$01			; ISOLATE LOW BIT, SET ZF
0668+  1245 79          	LD	A,C			; BANK VALUE INTO A
0669+  1246 F5          	PUSH	AF			; SAVE IT FOR NOW
0670+  1247             	; ADJUST L TO HAVE MSB OF OFFSET
0671+  1247 CB 3D       	SRL	L			; ADJUST L TO BE MSB OF BYTE OFFSET
0672+  1249 65          	LD	H,L			; MOVE MSB TO H WHERE IT BELONGS
0673+  124A 2E 00       	LD	L,0			;   AND ZERO L SO HL IS NOW BYTE OFFSET
0674+  124C             	; LOAD DESTINATION AND COUNT
0675+  124C ED 5B 5E 12 	LD	DE,(MD_DSKBUF)		; DMA ADDRESS IS DESTINATION
0676+  1250 01 00 02    	LD	BC,512			; ALWAYS COPY ONE SECTOR
0677+  1253             	; FINISH UP
0678+  1253 F1          	POP	AF			; GET BANK AND FLAGS BACK
0679+  1254 28 03       	JR	Z,MD_IOSETUP2		; DO ROM DRIVE, ELSE FALL THRU FOR RAM DRIVE
0680+  1256             ;
0681+  1256             MD_IOSETUP1:	; ROM
0682+  1256 C6 04       	ADD	A,BID_ROMD0
0683+  1258 C9          	RET
0684+  1259             ;
0685+  1259             MD_IOSETUP2:	; RAM
0686+  1259 C6 80       	ADD	A,BID_RAMD0
0687+  125B C9          	RET
0688+  125C             ;
0689+  125C             ;
0690+  125C             ;
0691+  125C~            #IF (MDTRACE >= 2)
0692+  125C~            MD_PRT:
0693+  125C~            	PUSH	AF
0694+  125C~            	PUSH	BC
0695+  125C~            	PUSH	DE
0696+  125C~            	PUSH	HL
0697+  125C~            ;
0698+  125C~            	CALL	NEWLINE
0699+  125C~            ;
0700+  125C~            	LD	DE,MDSTR_PREFIX
0701+  125C~            	CALL	WRITESTR
0702+  125C~            ;
0703+  125C~            	CALL	PC_SPACE
0704+  125C~            	LD	DE,MDSTR_SRC
0705+  125C~            	CALL	WRITESTR
0706+  125C~            	LD	A,(MD_SRCBNK)
0707+  125C~            	CALL	PRTHEXBYTE
0708+  125C~            	CALL	PC_COLON
0709+  125C~            	LD	BC,(MD_SRC)
0710+  125C~            	CALL	PRTHEXWORD
0711+  125C~            ;
0712+  125C~            	CALL	PC_SPACE
0713+  125C~            	LD	DE,MDSTR_DST
0714+  125C~            	CALL	WRITESTR
0715+  125C~            	LD	A,(MD_DSTBNK)
0716+  125C~            	CALL	PRTHEXBYTE
0717+  125C~            	CALL	PC_COLON
0718+  125C~            	LD	BC,(MD_DST)
0719+  125C~            	CALL	PRTHEXWORD
0720+  125C~            ;
0721+  125C~            	CALL	PC_SPACE
0722+  125C~            	LD	DE,MDSTR_LEN
0723+  125C~            	CALL	WRITESTR
0724+  125C~            	LD	BC,(MD_LEN)
0725+  125C~            	CALL	PRTHEXWORD
0726+  125C~            ;
0727+  125C~            	POP	HL
0728+  125C~            	POP	DE
0729+  125C~            	POP	BC
0730+  125C~            	POP	AF
0731+  125C~            ;
0732+  125C~            	RET
0733+  125C~            ;
0734+  125C~            MDSTR_PREFIX	.TEXT	"MD:$"
0735+  125C~            MDSTR_SRC	.TEXT	"SRC=$"
0736+  125C~            MDSTR_DST	.TEXT	"DEST=$"
0737+  125C~            MDSTR_LEN	.TEXT	"LEN=$"
0738+  125C             #ENDIF
0739+  125C             ;
0740+  125C             ;==================================================================================================
0741+  125C             ;   FLASH DRIVERS
0742+  125C             ;==================================================================================================
0743+  125C             ;
0744+  125C             ;	UPPER RAM BANK IS ALWAYS AVAILABLE REGARDLESS OF MEMORY BANK SELECTION. 
0745+  125C             ;	HBX_BNKSEL AND HB_CURBNK ARE ALWAYS AVAILABLE IN UPPER MEMORY.
0746+  125C             ;
0747+  125C             ;	THE STACK IS IN UPPER MEMORY DURING BIOS INITIALIZATION BUT IS IN LOWER
0748+  125C             ;	MEMORY DURING HBIOS CALLS.
0749+  125C             ;
0750+  125C             ;	TO ACCESS THE FLASH CHIP FEATURES, CODE IS COPIED TO THE UPPER RAM BANK (HBX_BUF)
0751+  125C             ;	AND THE FLASH CHIP IS SWITCHED INTO THE LOWER BANK.
0752+  125C             ;
0753+  125C             ;	EACH FLASH ROUTINE MUST FIT INTO TO THE HBX_BUF, INCLUDING IT'S LOCAL STACK WHICH
0754+  125C             ;	IS REQUIRED FOR CALLING THE BANK SWITCH ROUTINES. 
0755+  125C             ;
0756+  125C             ;	INSPIRED BY WILL SOWERBUTTS FLASH4 UTILITY - https://github.com/willsowerbutts/flash4/
0757+  125C             ;
0758+  125C             ;	REFERENCE ww1.microchip.com/downloads/en/DeviceDoc/SST39SF040.txt
0759+  125C             ;
0760+  125C             ;==================================================================================================
0761+  125C             ;
0762+  125C~            #IF (MDFFENABLE)
0763+  125C~            ;
0764+  125C~            ;======================================================================
0765+  125C~            ; BIOS FLASH INITIALIZATION
0766+  125C~            ;
0767+  125C~            ; IDENTIFY AND DISPLAY FLASH CHIPS IN SYSTEM.
0768+  125C~            ; USES MEMORY SIZE DEFINED BY BUILD CONFIGURATION.
0769+  125C~            ;======================================================================
0770+  125C~            ;
0771+  125C~            MD_FINIT:
0772+  125C~            	CALL	MD_CALCU		; DISPLAY
0773+  125C~            ;
0774+  125C~            #IF (MD_FVBS==1)
0775+  125C~            	CALL	NEWLINE			; OF UNITS 
0776+  125C~            	PRTS("MD: FLASH=$")
0776+  125C~            	PRTS("MD: FLASH=$")
0777+  125C~            	CALL	PRTDECB			; CONFIGURED FOR.
0778+  125C~            #ENDIF
0779+  125C~            	LD	B,A			; NUMBER OF DEVICES TO PROBE
0780+  125C~            	LD	C,$00			; START ADDRESS IS 0000:0000 IN DE:HL
0781+  125C~            MD_PROBE:
0782+  125C~            	LD	D,$00			; SET ADDRESS IN DE:HL
0783+  125C~            	LD	E,C			;
0784+  125C~            	LD	H,D			; WE INCREASE E BY $08
0785+  125C~            	LD	L,D			; ON EACH CYCLE THROUGH
0786+  125C~            ;	 
0787+  125C~            	PUSH	BC
0788+  125C~            #IF (MD_FVBS==1)
0789+  125C~            	CALL	PC_SPACE
0790+  125C~            	CALL	MD_CALCU
0791+  125C~            	INC	A
0792+  125C~            	SUB	B			; PRINT
0793+  125C~            	CALL	PRTDECB			; DEVICE 
0794+  125C~            	LD	A,'='			; NUMBER
0795+  125C~            	CALL	COUT
0796+  125C~            #ENDIF
0797+  125C~            	PUSH	HL
0798+  125C~            	CALL	MD_CALBAS		; SETUP BANK AND SECTOR
0799+  125C~            	LD	HL,MD_FIDEN_R		; PUT ROUTINE TO CALL
0800+  125C~            	CALL	MD_FNCALL		; EXECUTE: IDENTIFY FLASH CHIP
0801+  125C~            ;
0802+  125C~            	LD	HL,(MD_TGTDEV)		; IF WE MATCH WITH
0803+  125C~            	XOR	A			; A NON 39SF040
0804+  125C~            	SBC	HL,BC			; CHIP SET THE
0805+  125C~            	JR	Z,MD_PR2		; R/W FLAG TO R/O
0806+  125C~            	LD	HL,MD_FFSEN		; A NON ZERO VALUE
0807+  125C~            	SET	0,(HL)			; MEANS WE CAN'T
0808+  125C~            					; ENABLE FLASH WRITING
0809+  125C~            MD_PR2:
0810+  125C~            	POP	HL
0811+  125C~            #IF (MD_FVBS==1)
0812+  125C~            	CALL	MD_LAND			; LOOKUP AND DISPLAY
0813+  125C~            #ENDIF
0814+  125C~            	POP	BC
0815+  125C~            ;
0816+  125C~            	LD	A,C			; UPDATE ADDRESS
0817+  125C~            	ADD	A,$08			; TO NEXT DEVICE
0818+  125C~            	LD	C,A
0819+  125C~            ;
0820+  125C~            	DJNZ	MD_PROBE		; ALWAYS AT LEAST ONE DEVICE
0821+  125C~            
0822+  125C~            #IF (MD_FVBS==1)
0823+  125C~            	CALL	PRTSTRD
0824+  125C~            	.TEXT " FLASH FILE SYSTEM $"
0825+  125C~            	LD	DE,MD_FFMSGDIS
0826+  125C~            	LD	A,(MD_FFSEN)
0827+  125C~            	OR	A
0828+  125C~            	JR	NZ,MD_PR1
0829+  125C~            	LD	DE,MD_FFMSGENA
0830+  125C~            MD_PR1:	CALL	WRITESTR
0831+  125C~            #ENDIF
0832+  125C~            
0833+  125C~            	XOR	A			; INIT SUCCEEDED
0834+  125C~            	RET
0835+  125C~            ;
0836+  125C~            ; CALCULATE NUMBER OF 512KB ROMS FROM NUMBER OF ROM BANKS
0837+  125C~            ;
0838+  125C~            MD_CALCU:
0839+  125C~            ;	LD	A,+(ROMSIZE/512)	; DISPLAY NUMBER
0840+  125C~            	LD	A,(HCB + HCB_ROMBANKS)	; GET NUMBER OF BANKS
0841+  125C~            	SRL	A			; /2 CALCULATE
0842+  125C~            	SRL	A			; /4 NUMBER OF 512KB
0843+  125C~            	SRL	A			; /8 CHIPS THAT IS
0844+  125C~            	SRL	A			; /16
0845+  125C~            	RET
0846+  125C~            ;
0847+  125C~            ;======================================================================
0848+  125C~            ; LOOKUP AND DISPLAY CHIP
0849+  125C~            ;
0850+  125C~            ; ON ENTRY BC CONTAINS CHIP ID
0851+  125C~            ; ON EXIT  A  CONTAINS STATUS 0=SUCCESS, NZ=NOT IDENTIFIED
0852+  125C~            ;======================================================================
0853+  125C~            ;
0854+  125C~            MD_LAND:
0855+  125C~            ;
0856+  125C~            #IF (MD_FDBG==1)
0857+  125C~            	PRTS(" ID:$")
0857+  125C~            	PRTS(" ID:$")
0858+  125C~            	LD	A,C
0859+  125C~            	CALL	PRTHEXBYTE		; DISPLAY FLASH ID
0860+  125C~            	LD	A,B
0861+  125C~            	CALL	PRTHEXBYTE
0862+  125C~            	CALL	PC_SPACE
0863+  125C~            #ENDIF
0864+  125C~            ;
0865+  125C~            	LD	HL,MD_TABLE		; SEARCH THROUGH THE FLASH
0866+  125C~            	LD	DE,MD_T_CNT-1		; TABLE TO FIND A MATCH
0867+  125C~            MD_NXT1:
0868+  125C~            	LD	A,(HL)
0869+  125C~            	CP	C
0870+  125C~            	JR	NZ,MD_NXT0		; FIRST BYTE DOES NOT MATCH
0871+  125C~            ;
0872+  125C~            	INC	HL		
0873+  125C~            	LD	A,(HL)
0874+  125C~            	CP	B
0875+  125C~            	DEC	HL
0876+  125C~            	JR	NZ,MD_NXT0		; SECOND BYTE DOES NOT MATCH
0877+  125C~            ;
0878+  125C~            	INC	HL
0879+  125C~            	INC	HL
0880+  125C~            	JR	MD_NXT2			; MATCH SO EXIT
0881+  125C~            ;
0882+  125C~            MD_NXT0:PUSH	BC			; WE DIDN'T MATCH SO POINT
0883+  125C~            	LD	BC,MD_T_SZ		; TO THE NEXT TABLE ENTRY
0884+  125C~            	ADD	HL,BC
0885+  125C~            	POP	BC
0886+  125C~            ;
0887+  125C~            	LD	A,D			; CHECK IF WE REACHED THE
0888+  125C~            	OR	E			; END OF THE TABLE
0889+  125C~            	DEC	DE
0890+  125C~            	JR	NZ,MD_NXT1		; NOT AT END YET
0891+  125C~            ;
0892+  125C~            	LD	HL,MD_FFMSGUNK		; WE REACHED THE END WITHOUT A MATCH
0893+  125C~            ;
0894+  125C~            MD_NXT2:
0895+  125C~            #IF (MD_FVBS==1)
0896+  125C~            	CALL	PRTSTR			; AFTER SEARCH DISPLAY THE RESULT
0897+  125C~            #ENDIF
0898+  125C~            	RET
0899+  125C~            ;
0900+  125C~            ;======================================================================
0901+  125C~            ; COMMON FUNCTION CALL FOR:
0902+  125C~            ;
0903+  125C~            ;  MD_FIDEN_R - IDENTIFY FLASH CHIP	
0904+  125C~            ;   ON ENTRY MD_FBAS HAS BEEN SET WITH BANK AND SECTOR BEING ACCESSED
0905+  125C~            ;            HL      POINTS TO THE ROUTINE TO BE RELOCATED AND CALLED
0906+  125C~            ;   ON EXIT  BC      CONTAINS THE CHIP ID BYTES.
0907+  125C~            ;            A       NO STATUS IS RETURNED 
0908+  125C~            ;
0909+  125C~            ;  MD_FERAS_R - ERASE FLASH SECTOR	
0910+  125C~            ;   ON ENTRY MD_FBAS HAS BEEN SET WITH BANK AND SECTOR BEING ACCESSED
0911+  125C~            ;            HL      POINTS TO THE ROUTINE TO BE RELOCATED AND CALLED
0912+  125C~            ;   ON EXIT  A       RETURNS STATUS 0=SUCCESS NZ=FAIL
0913+  125C~            ;
0914+  125C~            ;  MD_FREAD_R - READ FLASH SECTOR    
0915+  125C~            ;   ON ENTRY MD_FBAS HAS BEEN SET WITH BANK AND SECTOR BEING ACCESSED
0916+  125C~            ;            HL      POINTS TO THE ROUTINE TO BE RELOCATED AND CALLED
0917+  125C~            ;            IX      POINTS TO WHERE TO SAVE DATA
0918+  125C~            ;   ON EXIT  A       NO STATUS IS RETURNED
0919+  125C~            ;
0920+  125C~            ;  MD_FVERI_R - VERIFY FLASH SECTOR
0921+  125C~            ;   ON ENTRY MD_FBAS HAS BEEN SET WITH BANK AND SECTOR BEING ACCESSED
0922+  125C~            ;            HL      POINTS TO THE ROUTINE TO BE RELOCATED AND CALLED
0923+  125C~            ;            IX      POINTS TO DATA TO COMPARE.
0924+  125C~            ;   ON EXIT  A       RETURNS STATUS 0=SUCCESS NZ=FAIL
0925+  125C~            ;
0926+  125C~            ;  MD_FWRIT_R - WRITE FLASH SECTOR   
0927+  125C~            ;   ON ENTRY MD_FBAS HAS BEEN SET WITH BANK AND SECTOR BEING ACCESSED
0928+  125C~            ;            HL      POINTS TO THE ROUTINE TO BE RELOCATED AND CALLED
0929+  125C~            ;            IX      POINTS TO DATA TO BE WRITTEN
0930+  125C~            ;   ON EXIT  A       NO STATUS IS RETURNED
0931+  125C~            ;
0932+  125C~            ; GENERAL OPERATION:
0933+  125C~            ;  COPY FLASH CODE TO CODE BUFFER
0934+  125C~            ;  CALL RELOCATED FLASH CODE
0935+  125C~            ;  RETURN WITH ID CODE.
0936+  125C~            ;======================================================================
0937+  125C~            ;
0938+  125C~            MD_FNCALL:				; USING HBX_BUF FOR CODE AREA
0939+  125C~            ;
0940+  125C~            	LD	B,0			; RETREIVE THE
0941+  125C~            	DEC	HL			; CODE SIZE TO
0942+  125C~            	LD	C,(HL)			; BE COPIED
0943+  125C~            	INC	HL			; MAXIMUM 64 BYTES
0944+  125C~            ;
0945+  125C~            	LD	DE,HBX_BUF		; EXECUTE / START ADDRESS
0946+  125C~            	LDIR				; COPY OUR RELOCATABLE CODE TO THE BUFFER
0947+  125C~            ;
0948+  125C~            	LD	D,B			; PRESET DE TO ZERO TO REDUCE
0949+  125C~            	LD	E,B			; CODE SIZE IN RELOCATABLE CODE
0950+  125C~            ;
0951+  125C~            	LD	BC,(MD_FBAS)		; PUT BANK AND SECTOR DATA IN BC
0952+  125C~            ;
0953+  125C~            #IF (MD_FDBG==1)
0954+  125C~            	CALL	PRTHEXWORD
0955+  125C~            #ENDIF
0956+  125C~            ;
0957+  125C~            	LD	A,(HB_CURBNK)		; WE ARE STARTING IN HB_CURBNK
0958+  125C~            ;
0959+  125C~            	HB_DI
0960+  125C~            	LD	(MD_SAVSTK),SP		; SAVE CURRENT STACK
0961+  125C~            	LD	SP,HBX_BUF_END		; SETUP A NEW HIMEM STACK AT END OF HX_BUF
0962+  125C~            	CALL	HBX_BUF			; EXECUTE RELOCATED CODE
0963+  125C~            	LD	SP,(MD_SAVSTK)		; RESTORE STACK
0964+  125C~            	HB_EI
0965+  125C~            ;
0966+  125C~            #IF (MD_FDBG==1)
0967+  125C~            	CALL	PC_SPACE
0968+  125C~            	CALL	PRTHEXWORD
0969+  125C~            	CALL	PC_SPACE
0970+  125C~            	EX	DE,HL
0971+  125C~            	CALL	PRTHEXWORDHL
0972+  125C~            	CALL	PC_SPACE
0973+  125C~            	EX	DE,HL
0974+  125C~            #ENDIF
0975+  125C~            ;
0976+  125C~            	LD	A,C			; RETURN WITH STATUS IN A
0977+  125C~            	RET				; RETURN TO MD_READF, MD_WRITEF
0978+  125C~            ;
0979+  125C~            MD_SAVSTK	.DW	0		
0980+  125C~            ;
0981+  125C~            #INCLUDE "flashlib.inc"
0982+  125C~            ;
0983+  125C~            ;======================================================================
0984+  125C~            ;
0985+  125C~            ; FLASH CHIP LIST
0986+  125C~            ;
0987+  125C~            ;======================================================================
0988+  125C~            ;
0989+  125C~            #DEFINE	FF_CHIP(FFROMID,FFROMNM) \
0990+  125C~            #DEFCONT \	.DB	(FFROMID >> 8) & $FF
0991+  125C~            #DEFCONT \	.DB	(FFROMID & $FF)
0992+  125C~            #DEFCONT \	.DB	FFROMNM
0993+  125C~            ;
0994+  125C~            MD_TABLE:
0995+  125C~            FF_CHIP(00120H,"29F010$    ")
0996+  125C~            FF_CHIP(001A4H,"29F040$    ")
0997+  125C~            FF_CHIP(01F04H,"AT49F001NT$")
0998+  125C~            FF_CHIP(01F05H,"AT49F001N$ ")
0999+  125C~            FF_CHIP(01F07H,"AT49F002N$ ")
1000+  125C~            FF_CHIP(01F08H,"AT49F002NT$")
1001+  125C~            FF_CHIP(01F13H,"AT49F040$  ")
1002+  125C~            FF_CHIP(01F5DH,"AT29C512$  ")
1003+  125C~            FF_CHIP(01FA4H,"AT29C040$  ")
1004+  125C~            FF_CHIP(01FD5H,"AT29C010$  ")
1005+  125C~            FF_CHIP(01FDAH,"AT29C020$  ")
1006+  125C~            FF_CHIP(02020H,"M29F010$   ")
1007+  125C~            FF_CHIP(020E2H,"M29F040$   ")
1008+  125C~            FF_CHIP(037A4H,"A29010B$   ")
1009+  125C~            FF_CHIP(03786H,"A29040B$   ")
1010+  125C~            FF_CHIP(0BFB5H,"39F010$    ")
1011+  125C~            FF_CHIP(0BFB6H,"39F020$    ")
1012+  125C~            MD_TGTDEV:				; TARGET CHIP FOR R/W FILESYSTEM 39SF040
1013+  125C~            FF_CHIP(0BFB7H,"39F040$    ")
1014+  125C~            FF_CHIP(0C2A4H,"MX29F040$  ")
1015+  125C~            ;
1016+  125C~            MD_T_CNT	.EQU	19
1017+  125C~            MD_T_SZ		.EQU	($-MD_TABLE) / MD_T_CNT
1018+  125C~            MD_FFMSGUNK	.DB	"UNKNOWN$"
1019+  125C~            MD_FFMSGDIS	.DB	"DISABLED$"
1020+  125C~            MD_FFMSGENA	.DB	"ENABLED$"
1021+  125C~            ;
1022+  125C~            ;======================================================================
1023+  125C~            ;
1024+  125C~            ; 4K FLASH SECTOR BUFFER
1025+  125C~            ;
1026+  125C~            ;======================================================================
1027+  125C~            ;
1028+  125C~            MD_F4KBUF	.FILL	4096,$FF
1029+  125C~            MD_FFSEN	.DB	00h		; FLASH FILES SYSTEM ENABLE
1030+  125C~            ;
1031+  125C             #ENDIF
1032+  125C             ;
1033+  125C 00 00       MD_RWFNADR	.DW	0
1034+  125E 00 00       MD_DSKBUF	.DW	0
1035+  1260 00          MD_SRCBNK	.DB	0
1036+  1261 00          MD_DSTBNK	.DB	0
1037+  1262 00 00       MD_SRC		.DW	0
1038+  1264 00 00       MD_DST		.DW	0
1039+  1266 00 00       MD_LEN		.DW	0
6163   1268             SIZ_MD		.EQU	$ - ORG_MD
6164   1268             		.ECHO	"MD occupies "
6165   1268             		.ECHO	SIZ_MD
6166   1268             		.ECHO	" bytes.\n"
6167   1268             #ENDIF
6168   1268             ;
6169   1268~            #IF (FDENABLE)
6170   1268~            ORG_FD		.EQU	$
6171   1268~              #INCLUDE "fd.asm"
6172   1268~            SIZ_FD		.EQU	$ - ORG_FD
6173   1268~            		.ECHO	"FD occupies "
6174   1268~            		.ECHO	SIZ_FD
6175   1268~            		.ECHO	" bytes.\n"
6176   1268             #ENDIF
6177   1268             ;
6178   1268~            #IF (RFENABLE)
6179   1268~            ORG_RF	.EQU	$
6180   1268~              #INCLUDE "rf.asm"
6181   1268~            SIZ_RF	.EQU	$ - ORG_RF
6182   1268~            		.ECHO	"RF occupies "
6183   1268~            		.ECHO	SIZ_RF
6184   1268~            		.ECHO	" bytes.\n"
6185   1268             #ENDIF
6186   1268             ;
6187   1268~            #IF (IDEENABLE)
6188   1268~            ORG_IDE		.EQU	$
6189   1268~              #INCLUDE "ide.asm"
6190   1268~            SIZ_IDE		.EQU	$ - ORG_IDE
6191   1268~            		.ECHO	"IDE occupies "
6192   1268~            		.ECHO	SIZ_IDE
6193   1268~            		.ECHO	" bytes.\n"
6194   1268             #ENDIF
6195   1268             ;
6196   1268             #IF (PPIDEENABLE)
6197   1268             ORG_PPIDE	.EQU	$
6198   1268               #INCLUDE "ppide.asm"
0001+  1268             ;
0002+  1268             ;=============================================================================
0003+  1268             ;   PPIDE DISK DRIVER
0004+  1268             ;=============================================================================
0005+  1268             ;
0006+  1268             ; TODO:
0007+  1268             ; - FIX SCALER CONSTANT
0008+  1268             ; - GOPARTNER NEEDS TO HANDLE "NO PARTNER" CONDITION
0009+  1268             ;
0010+  1268             ; NOTES:
0011+  1268             ;  - WELL KNOWN PPIDE PORT ADDRESSES:
0012+  1268             ;      $60 - SBC/ZETA ONBOARD PPI
0013+  1268             ;      $20 - ECB DISKIO3, RC FAMILY
0014+  1268             ;      $44 - ECB MULTI-FUNCTION PIC
0015+  1268             ;      $80 - N8 ONBOARD PPI
0016+  1268             ;      $4C - DYNO ONBOARD PPI
0017+  1268             ;
0018+  1268             ; THE CONTROL PORT OF THE 8255 IS PROGRAMMED AS NEEDED TO READ OR WRITE
0019+  1268             ; DATA ON THE IDE BUS.	PORT C OF THE 8255 IS ALWAYS IN OUTPUT MODE BECAUSE
0020+  1268             ; IT IS DRIVING THE ADDRESS BUS AND CONTROL SIGNALS.  PORTS A & B WILL BE
0021+  1268             ; PLACED IN READ OR WRITE MODE DEPENDING ON THE DIRECTION OF THE DATA BUS.
0022+  1268             ;
0023+  1268             PPIDE_DIR_READ	.EQU	%10010010	; IDE BUS DATA INPUT MODE
0024+  1268             PPIDE_DIR_WRITE	.EQU	%10000000	; IDE BUS DATA OUTPUT MODE
0025+  1268             ;
0026+  1268             ; PORT C OF THE 8255 IS USED TO DRIVE THE IDE INTERFACE ADDRESS BUS
0027+  1268             ; AND VARIOUS CONTROL SIGNALS.	THE CONSTANTS BELOW REFLECT THESE
0028+  1268             ; ASSIGNMENTS.
0029+  1268             ;
0030+  1268             PPIDE_CTL_DA0	.EQU	%00000001	; DRIVE ADDRESS BUS - BIT 0 (DA0)
0031+  1268             PPIDE_CTL_DA1	.EQU	%00000010	; DRIVE ADDRESS BUS - BIT 1 (DA1)
0032+  1268             PPIDE_CTL_DA2	.EQU	%00000100	; DRIVE ADDRESS BUS - BIT 2 (DA2)
0033+  1268             PPIDE_CTL_CS1	.EQU	%00001000	; DRIVE CHIP SELECT 0 (ACTIVE LOW, INVERTED)
0034+  1268             PPIDE_CTL_CS3	.EQU	%00010000	; DRIVE CHIP SELECT 1 (ACTIVE LOW, INVERTED)
0035+  1268             PPIDE_CTL_DIOW	.EQU	%00100000	; DRIVE I/O WRITE (ACTIVE LOW, INVERTED)
0036+  1268             PPIDE_CTL_DIOR	.EQU	%01000000	; DRIVE I/O READ (ACTIVE LOW, INVERTED)
0037+  1268             PPIDE_CTL_RESET	.EQU	%10000000	; DRIVE RESET (ACTIVE LOW, INVERTED)
0038+  1268             ;
0039+  1268             ;	+-----------------------------------------------------------------------+
0040+  1268             ;	| CONTROL BLOCK REGISTERS (CS3FX)					|
0041+  1268             ;	+-----------------------+-------+-------+-------------------------------+
0042+  1268             ;	| REGISTER		| PORT	| DIR	| DESCRIPTION			|
0043+  1268             ;	+-----------------------+-------+-------+-------------------------------+
0044+  1268             ;	| PPIDE_REG_ALTSTAT	| 0x06	| R	| ALTERNATE STATUS REGISTER	|
0045+  1268             ;	| PPIDE_REG_CTRL	| 0x06	| W	| DEVICE CONTROL REGISTER	|
0046+  1268             ;	| PPIDE_REG_DRVADR	| 0x07	| R	| DRIVE ADDRESS REGISTER	|
0047+  1268             ;	+-----------------------+-------+-------+-------------------------------+
0048+  1268             ;
0049+  1268             ;	+-----------------------+-------+-------+-------------------------------+
0050+  1268             ;	| COMMAND BLOCK REGISTERS (CS1FX)					|
0051+  1268             ;	+-----------------------+-------+-------+-------------------------------+
0052+  1268             ;	| REGISTER		| PORT	| DIR	| DESCRIPTION			|
0053+  1268             ;	+-----------------------+-------+-------+-------------------------------+
0054+  1268             ;	| PPIDE_REG_DATA	| 0x00	| R/W	| DATA INPUT/OUTPUT		|
0055+  1268             ;	| PPIDE_REG_ERR		| 0x01	| R	| ERROR REGISTER		|
0056+  1268             ;	| PPIDE_REG_FEAT	| 0x01	| W	| FEATURES REGISTER		|
0057+  1268             ;	| PPIDE_REG_COUNT	| 0x02	| R/W	| SECTOR COUNT REGISTER		|
0058+  1268             ;	| PPIDE_REG_SECT	| 0x03	| R/W	| SECTOR NUMBER REGISTER	|
0059+  1268             ;	| PPIDE_REG_CYLLO	| 0x04	| R/W	| CYLINDER NUM REGISTER (LSB)	|
0060+  1268             ;	| PPIDE_REG_CYLHI	| 0x05	| R/W	| CYLINDER NUM REGISTER (MSB)	|
0061+  1268             ;	| PPIDE_REG_DRVHD	| 0x06	| R/W	| DRIVE/HEAD REGISTER		|
0062+  1268             ;	| PPIDE_REG_LBA0*	| 0x03	| R/W	| LBA BYTE 0 (BITS 0-7)		|
0063+  1268             ;	| PPIDE_REG_LBA1*	| 0x04	| R/W	| LBA BYTE 1 (BITS 8-15)	|
0064+  1268             ;	| PPIDE_REG_LBA2*	| 0x05	| R/W	| LBA BYTE 2 (BITS 16-23)	|
0065+  1268             ;	| PPIDE_REG_LBA3*	| 0x06	| R/W	| LBA BYTE 3 (BITS 24-27)	|
0066+  1268             ;	| PPIDE_REG_STAT	| 0x07	| R	| STATUS REGISTER		|
0067+  1268             ;	| PPIDE_REG_CMD		| 0x07	| W	| COMMAND REGISTER (EXECUTE)	|
0068+  1268             ;	+-----------------------+-------+-------+-------------------------------+
0069+  1268             ;	* LBA0-3 ARE ALTERNATE DEFINITIONS OF SECT, CYL, AND DRVHD PORTS
0070+  1268             ;
0071+  1268             ;	=== STATUS REGISTER ===
0072+  1268             ;
0073+  1268             ;	    7	    6	    5	    4	    3	    2	    1	    0
0074+  1268             ;	+-------+-------+-------+-------+-------+-------+-------+-------+
0075+  1268             ;	|  BSY	| DRDY	|  DWF	|  DSC	|  DRQ	| CORR	|  IDX	|  ERR	|
0076+  1268             ;	+-------+-------+-------+-------+-------+-------+-------+-------+
0077+  1268             ;
0078+  1268             ;	BSY:	BUSY
0079+  1268             ;	DRDY:	DRIVE READY
0080+  1268             ;	DWF:	DRIVE WRITE FAULT
0081+  1268             ;	DSC:	DRIVE SEEK COMPLETE
0082+  1268             ;	DRQ:	DATA REQUEST
0083+  1268             ;	CORR:	CORRECTED DATA
0084+  1268             ;	IDX:	INDEX
0085+  1268             ;	ERR:	ERROR
0086+  1268             ;
0087+  1268             ;	=== ERROR REGISTER ===
0088+  1268             ;
0089+  1268             ;	    7	    6	    5	    4	    3	    2	    1	    0
0090+  1268             ;	+-------+-------+-------+-------+-------+-------+-------+-------+
0091+  1268             ;	| BBK	|  UNC	|  MC	|  IDNF |  MCR	| ABRT	| TK0NF |  AMNF |
0092+  1268             ;	+-------+-------+-------+-------+-------+-------+-------+-------+
0093+  1268             ;	(VALID WHEN ERR BIT IS SET IN STATUS REGISTER)
0094+  1268             ;
0095+  1268             ;	BBK:	BAD BLOCK DETECTED
0096+  1268             ;	UNC:	UNCORRECTABLE DATA ERROR
0097+  1268             ;	MC:	MEDIA CHANGED
0098+  1268             ;	IDNF:	ID NOT FOUND
0099+  1268             ;	MCR:	MEDIA CHANGE REQUESTED
0100+  1268             ;	ABRT:	ABORTED COMMAND
0101+  1268             ;	TK0NF:	TRACK 0 NOT FOUND
0102+  1268             ;	AMNF:	ADDRESS MARK NOT FOUND
0103+  1268             ;
0104+  1268             ;	=== DRIVE/HEAD / LBA3 REGISTER ===
0105+  1268             ;
0106+  1268             ;	    7	    6	    5	    4	    3	    2	    1	    0
0107+  1268             ;	+-------+-------+-------+-------+-------+-------+-------+-------+
0108+  1268             ;	|   1	|   L	|   1	|  DRV	|  HS3	|  HS2	|  HS1	|  HS0	|
0109+  1268             ;	+-------+-------+-------+-------+-------+-------+-------+-------+
0110+  1268             ;
0111+  1268             ;	L:	0 = CHS ADDRESSING, 1 = LBA ADDRESSING
0112+  1268             ;	DRV:	0 = DRIVE 0 (PRIMARY) SELECTED, 1 = DRIVE 1 (SLAVE) SELECTED
0113+  1268             ;	HS:	CHS = HEAD ADDRESS (0-15), LBA = BITS 24-27 OF LBA
0114+  1268             ;
0115+  1268             ;	=== DEVICE CONTROL REGISTER ===
0116+  1268             ;
0117+  1268             ;	    7	    6	    5	    4	    3	    2	    1	    0
0118+  1268             ;	+-------+-------+-------+-------+-------+-------+-------+-------+
0119+  1268             ;	|   X	|   X	|   X	|   X	|   1	| SRST	|  ~IEN |   0	|
0120+  1268             ;	+-------+-------+-------+-------+-------+-------+-------+-------+
0121+  1268             ;
0122+  1268             ;	SRST:	SOFTWARE RESET
0123+  1268             ;	~IEN:	INTERRUPT ENABLE
0124+  1268             ;
0125+  1268             ; CONTROL VALUES TO USE WHEN ACCESSING THE VARIOUS IDE DEVICE REGISTERS
0126+  1268             ;
0127+  1268             PPIDE_REG_DATA		.EQU	PPIDE_CTL_CS1 | $00	; DATA INPUT/OUTPUT (R/W)
0128+  1268             PPIDE_REG_ERR		.EQU	PPIDE_CTL_CS1 | $01	; ERROR REGISTER (R)
0129+  1268             PPIDE_REG_FEAT		.EQU	PPIDE_CTL_CS1 | $01	; FEATURES REGISTER (W)
0130+  1268             PPIDE_REG_COUNT		.EQU	PPIDE_CTL_CS1 | $02	; SECTOR COUNT REGISTER (R/W)
0131+  1268             PPIDE_REG_SECT		.EQU	PPIDE_CTL_CS1 | $03	; SECTOR NUMBER REGISTER (R/W)
0132+  1268             PPIDE_REG_CYLLO		.EQU	PPIDE_CTL_CS1 | $04	; CYLINDER NUM REGISTER (LSB) (R/W)
0133+  1268             PPIDE_REG_CYLHI		.EQU	PPIDE_CTL_CS1 | $05	; CYLINDER NUM REGISTER (MSB) (R/W)
0134+  1268             PPIDE_REG_DRVHD		.EQU	PPIDE_CTL_CS1 | $06	; DRIVE/HEAD REGISTER (R/W)
0135+  1268             PPIDE_REG_LBA0		.EQU	PPIDE_CTL_CS1 | $03	; LBA BYTE 0 (BITS 0-7) (R/W)
0136+  1268             PPIDE_REG_LBA1		.EQU	PPIDE_CTL_CS1 | $04	; LBA BYTE 1 (BITS 8-15) (R/W)
0137+  1268             PPIDE_REG_LBA2		.EQU	PPIDE_CTL_CS1 | $05	; LBA BYTE 2 (BITS 16-23) (R/W)
0138+  1268             PPIDE_REG_LBA3		.EQU	PPIDE_CTL_CS1 | $06	; LBA BYTE 3 (BITS 24-27) (R/W)
0139+  1268             PPIDE_REG_STAT		.EQU	PPIDE_CTL_CS1 | $07	; STATUS REGISTER (R)
0140+  1268             PPIDE_REG_CMD		.EQU	PPIDE_CTL_CS1 | $07	; COMMAND REGISTER (EXECUTE) (W)
0141+  1268             PPIDE_REG_ALTSTAT	.EQU	PPIDE_CTL_CS3 | $06	; ALTERNATE STATUS REGISTER (R)
0142+  1268             PPIDE_REG_CTRL		.EQU	PPIDE_CTL_CS3 | $06	; DEVICE CONTROL REGISTER (W)
0143+  1268             PPIDE_REG_DRVADR	.EQU	PPIDE_CTL_CS3 | $07	; DRIVE ADDRESS REGISTER (R)
0144+  1268             ;
0145+  1268             ; COMMAND BYTES
0146+  1268             ;
0147+  1268             PPIDE_CMD_RECAL		.EQU	$10
0148+  1268             PPIDE_CMD_READ		.EQU	$20
0149+  1268             PPIDE_CMD_WRITE		.EQU	$30
0150+  1268             PPIDE_CMD_IDDEV		.EQU	$EC
0151+  1268             PPIDE_CMD_SETFEAT	.EQU	$EF
0152+  1268             ;
0153+  1268             ; FEATURE BYTES
0154+  1268             ;
0155+  1268             PPIDE_FEAT_ENABLE8BIT	.EQU	$01
0156+  1268             PPIDE_FEAT_DISABLE8BIT	.EQU	$81
0157+  1268             ;
0158+  1268             ; PPIDE DEVICE TYPES
0159+  1268             ;
0160+  1268             PPIDE_TYPEUNK	.EQU	0
0161+  1268             PPIDE_TYPEATA	.EQU	1
0162+  1268             PPIDE_TYPEATAPI	.EQU	2
0163+  1268             ;
0164+  1268             ; PPIDE DEVICE STATUS CODES
0165+  1268             ;
0166+  1268             PPIDE_STOK	.EQU	0
0167+  1268             PPIDE_STINVUNIT	.EQU	-1
0168+  1268             PPIDE_STNOMEDIA	.EQU	-2
0169+  1268             PPIDE_STCMDERR	.EQU	-3
0170+  1268             PPIDE_STIOERR	.EQU	-4
0171+  1268             PPIDE_STRDYTO	.EQU	-5
0172+  1268             PPIDE_STDRQTO	.EQU	-6
0173+  1268             PPIDE_STBSYTO	.EQU	-7
0174+  1268             ;
0175+  1268             ; DRIVE SELECTION BYTES (FOR USE IN DRIVE/HEAD REGISTER)
0176+  1268             ;
0177+  1268             ;PPIDE_DRVSEL:
0178+  1268             PPIDE_DRVMASTER	.EQU	%11100000	; LBA, MASTER DEVICE
0179+  1268             PPIDE_DRVSLAVE	.EQU	%11110000	; LBA, SLAVE DEVICE
0180+  1268             ;
0181+  1268             ; PPIDE DEVICE CONFIGURATION
0182+  1268             ;
0183+  1268             PPIDE_CFGSIZ	.EQU	18		; SIZE OF CFG TBL ENTRIES
0184+  1268             ;
0185+  1268             ; PER DEVICE DATA OFFSETS
0186+  1268             ;
0187+  1268             PPIDE_DEV	.EQU	0		; OFFSET OF DEVICE NUMBER (BYTE)
0188+  1268             PPIDE_STAT	.EQU	1		; LAST STATUS (BYTE)
0189+  1268             PPIDE_TYPE	.EQU	2		; DEVICE TYPE (BYTE)
0190+  1268             PPIDE_ACC	.EQU	3		; ACCESS FLAG BITS BIT 0=MASTER, 1=8BIT (BYTE)
0191+  1268             PPIDE_MED	.EQU	4		; MEDIA FLAG BITS BIT 0=CF, 1=LBA (BYTE)
0192+  1268             PPIDE_MEDCAP	.EQU	5		; MEDIA CAPACITY (DWORD)
0193+  1268             PPIDE_LBA	.EQU	9		; OFFSET OF LBA (DWORD)
0194+  1268             PPIDE_DATALO	.EQU	13		; BASE PORT AND IDE DATA BUS LSB (8255 PORT A) (BYTE)
0195+  1268             PPIDE_CTL	.EQU	14		; IDE ADDRESS BUS AND CONTROL SIGNALS (8255 PORT C)(BYTE)
0196+  1268             PPIDE_PPI	.EQU	15		; 8255 CONTROL PORT(BYTE)
0197+  1268             PPIDE_PARTNER	.EQU	16		; PARTNER DEVICE (MASTER <-> SLAVE) (WORD)
0198+  1268             ;
0199+  1268             PPIDE_ACC_MAS	.EQU	%00000001	; UNIT IS MASTER (ELSE SLAVE)
0200+  1268             PPIDE_ACC_8BIT	.EQU	%00000010	; UNIT WANTS 8 BIT I/O (ELSE 16 BIT)
0201+  1268             ;
0202+  1268             PPIDE_MED_CF	.EQU	%00000001	; MEDIA IS CF CARD
0203+  1268             PPIDE_MED_LBA	.EQU	%00000010	; MEDIA HAS LBA CAPABILITY
0204+  1268             ;
0205+  1268             PPIDE_DEVCNT	.EQU	PPIDECNT * 2
0206+  1268             ;
0207+  1268             PPIDE_CFGTBL:
0208+  1268             ;
0209+  1268             #IF (PPIDECNT >= 1)
0210+  1268             ;
0211+  1268             PPIDE_DEV0M:	; DEVICE 0, MASTER
0212+  1268 FE          	.DB	$FE			; DRIVER DEVICE NUMBER (FILLED DYNAMICALLY)
0213+  1269 00          	.DB	0			; DEVICE STATUS
0214+  126A 00          	.DB	0			; DEVICE TYPE
0215+  126B 01          	.DB	PPIDE_ACC_MAS | (PPIDE0A8BIT & PPIDE_ACC_8BIT)	; UNIT ACCESS FLAGS
0216+  126C 00          	.DB	0			; MEDIA FLAGS
0217+  126D 00 00 00 00 	.DW	0,0			; DEVICE CAPACITY
0218+  1271 00 00 00 00 	.DW	0,0			; CURRENT LBA
0219+  1275 20          	.DB	PPIDE0BASE  		; DATALO
0220+  1276 22          	.DB	PPIDE0BASE+2		; CTL 
0221+  1277 23          	.DB	PPIDE0BASE+3		; PPI
0222+  1278 7A 12       	.DW	PPIDE_DEV0S		; PARTNER
0223+  127A             ;
0224+  127A             PPIDE_DEV0S:	; DEVICE 0, SLAVE
0225+  127A FE          	.DB	$FE			; DRIVER DEVICE NUMBER (FILLED DYNAMICALLY)
0226+  127B 00          	.DB	0			; DEVICE STATUS
0227+  127C 00          	.DB	0			; DEVICE TYPE
0228+  127D 00          	.DB	(PPIDE0B8BIT & PPIDE_ACC_8BIT)	; UNIT ACCESS FLAGS
0229+  127E 00          	.DB	0			; MEDIA FLAGS
0230+  127F 00 00 00 00 	.DW	0,0			; DEVICE CAPACITY
0231+  1283 00 00 00 00 	.DW	0,0			; CURRENT LBA
0232+  1287 20          	.DB	PPIDE0BASE  		; DATALO
0233+  1288 22          	.DB	PPIDE0BASE+2		; CTL 
0234+  1289 23          	.DB	PPIDE0BASE+3		; PPI
0235+  128A 68 12       	.DW	PPIDE_DEV0M		; PARTNER
0236+  128C             ;
0237+  128C             #ENDIF
0238+  128C             ;
0239+  128C~            #IF (PPIDECNT >= 2)
0240+  128C~            ;
0241+  128C~            PPIDE_DEV1M:	; DEVICE 1, MASTER
0242+  128C~            	.DB	$FE			; DRIVER DEVICE NUMBER (FILLED DYNAMICALLY)
0243+  128C~            	.DB	0			; DEVICE STATUS
0244+  128C~            	.DB	0			; DEVICE TYPE
0245+  128C~            	.DB	PPIDE_ACC_MAS | (PPIDE1A8BIT & PPIDE_ACC_8BIT)	; UNIT ACCESS FLAGS
0246+  128C~            	.DB	0			; MEDIA FLAGS
0247+  128C~            	.DW	0,0			; DEVICE CAPACITY
0248+  128C~            	.DW	0,0			; CURRENT LBA
0249+  128C~            	.DB	PPIDE1BASE  		; DATALO
0250+  128C~            	.DB	PPIDE1BASE+2		; CTL 
0251+  128C~            	.DB	PPIDE1BASE+3		; PPI
0252+  128C~            	.DW	PPIDE_DEV1S		; PARTNER
0253+  128C~            ;
0254+  128C~            PPIDE_DEV1S:	; DEVICE 1, SLAVE
0255+  128C~            	.DB	$FE			; DRIVER DEVICE NUMBER (FILLED DYNAMICALLY)
0256+  128C~            	.DB	0			; DEVICE STATUS
0257+  128C~            	.DB	0			; DEVICE TYPE
0258+  128C~            	.DB	(PPIDE1B8BIT & PPIDE_ACC_8BIT)	; UNIT ACCESS FLAGS
0259+  128C~            	.DB	0			; MEDIA FLAGS
0260+  128C~            	.DW	0,0			; DEVICE CAPACITY
0261+  128C~            	.DW	0,0			; CURRENT LBA
0262+  128C~            	.DB	PPIDE1BASE  		; DATALO
0263+  128C~            	.DB	PPIDE1BASE+2		; CTL 
0264+  128C~            	.DB	PPIDE1BASE+3		; PPI
0265+  128C~            	.DW	PPIDE_DEV1M		; PARTNER
0266+  128C~            ;
0267+  128C             #ENDIF
0268+  128C             ;
0269+  128C~            #IF (PPIDECNT >= 3)
0270+  128C~            ;
0271+  128C~            PPIDE_DEV2M:	; DEVICE 2, MASTER
0272+  128C~            	.DB	$FE			; DRIVER DEVICE NUMBER (FILLED DYNAMICALLY)
0273+  128C~            	.DB	0			; DEVICE STATUS
0274+  128C~            	.DB	0			; DEVICE TYPE
0275+  128C~            	.DB	PPIDE_ACC_MAS | (PPIDE2A8BIT & PPIDE_ACC_8BIT)	; UNIT ACCESS FLAGS
0276+  128C~            	.DB	0			; MEDIA FLAGS
0277+  128C~            	.DW	0,0			; DEVICE CAPACITY
0278+  128C~            	.DW	0,0			; CURRENT LBA
0279+  128C~            	.DB	PPIDE2BASE  		; DATALO
0280+  128C~            	.DB	PPIDE2BASE+2		; CTL 
0281+  128C~            	.DB	PPIDE2BASE+3		; PPI
0282+  128C~            	.DW	PPIDE_DEV2S		; PARTNER
0283+  128C~            ;	
0284+  128C~            PPIDE_DEV2S:	; DEVICE 2, SLAVE
0285+  128C~            	.DB	$FE			; DRIVER DEVICE NUMBER (FILLED DYNAMICALLY)
0286+  128C~            	.DB	0			; DEVICE STATUS
0287+  128C~            	.DB	0			; DEVICE TYPE
0288+  128C~            	.DB	(PPIDE2B8BIT & PPIDE_ACC_8BIT)	; UNIT ACCESS FLAGS
0289+  128C~            	.DB	0			; MEDIA FLAGS
0290+  128C~            	.DW	0,0			; DEVICE CAPACITY
0291+  128C~            	.DW	0,0			; CURRENT LBA
0292+  128C~            	.DB	PPIDE2BASE  		; DATALO
0293+  128C~            	.DB	PPIDE2BASE+2		; CTL 
0294+  128C~            	.DB	PPIDE2BASE+3		; PPI
0295+  128C~            	.DW	PPIDE_DEV2M		; PARTNER
0296+  128C~            ;
0297+  128C             #ENDIF
0298+  128C             ;
0299+  128C~            #IF ($ - PPIDE_CFGTBL) != (PPIDE_DEVCNT * PPIDE_CFGSIZ)
0300+  128C~            	.ECHO	"*** INVALID PPIDE CONFIG TABLE ***\n"
0301+  128C             #ENDIF
0302+  128C             ;
0303+  128C FF          	.DB	$FF			; END OF TABLE MARKER
0304+  128D             ;
0305+  128D             ; THE IDE_WAITXXX FUNCTIONS ARE BUILT TO TIMEOUT AS NEEDED SO DRIVER WILL
0306+  128D             ; NOT HANG IF DEVICE IS UNRESPONSIVE.  DIFFERENT TIMEOUTS ARE USED DEPENDING
0307+  128D             ; ON THE SITUATION.  GENERALLY, THE FAST TIMEOUT IS USED TO PROBE FOR DEVICES
0308+  128D             ; USING FUNCTIONS THAT PERFORM NO I/O.	OTHERWISE THE NORMAL TIMEOUT IS USED.
0309+  128D             ; IDE SPEC ALLOWS FOR UP TO 30 SECS MAX TO RESPOND.  IN PRACTICE, THIS IS WAY
0310+  128D             ; TOO LONG, BUT IF YOU ARE USING A VERY OLD DEVICE, THESE TIMEOUTS MAY NEED TO
0311+  128D             ; BE ADJUSTED.	NOTE THAT THESE ARE BYTE VALUES, SO YOU CANNOT EXCEED 255.
0312+  128D             ; THE TIMEOUTS ARE IN UNITS OF .05 SECONDS.
0313+  128D             ;
0314+  128D             PPIDE_TONORM	.EQU	200		; NORMAL TIMEOUT IS 10 SECS
0315+  128D             PPIDE_TOFAST	.EQU	10		; FAST TIMEOUT IS 0.5 SECS
0316+  128D             ;
0317+  128D             ;=============================================================================
0318+  128D             ; INITIALIZATION ENTRY POINT
0319+  128D             ;=============================================================================
0320+  128D             ;
0321+  128D             PPIDE_INIT:
0322+  128D             	; COMPUTE CPU SPEED COMPENSATED TIMEOUT SCALER
0323+  128D             	; AT 1MHZ, THE SCALER IS 218 (50000US / 229TS = 218)
0324+  128D             	; SCALER IS THEREFORE 218 * CPU SPEED IN MHZ
0325+  128D 11 DA 00    	LD	DE,218			; LOAD SCALER FOR 1MHZ
0326+  1290 3A 08 01    	LD	A,(CB_CPUMHZ)		; LOAD CPU SPEED IN MHZ
0327+  1293 CD 4A 1B    	CALL	MULT8X16		; HL := DE * A
0328+  1296 22 CE 18    	LD	(PPIDE_TOSCALER),HL	; SAVE IT
0329+  1299             ;
0330+  1299 AF          	XOR	A			; ZERO ACCUM
0331+  129A 32 D6 18    	LD	(PPIDE_DEVNUM),A	; INIT DEV UNIT NUM FOR DYNAMIC ASSIGNMENT
0332+  129D FD 21 68 12 	LD	IY,PPIDE_CFGTBL		; POINT TO START OF CONFIG TABLE
0333+  12A1             ;
0334+  12A1             PPIDE_INIT1:
0335+  12A1 FD 7E 00    	LD	A,(IY)			; LOAD FIRST BYTE TO CHECK FOR END
0336+  12A4 FE FF       	CP	$FF			; CHECK FOR END OF TABLE VALUE
0337+  12A6 20 02       	JR	NZ,PPIDE_INIT2		; IF NOT END OF TABLE, CONTINUE
0338+  12A8 AF          	XOR	A			; SIGNAL SUCCESS
0339+  12A9 C9          	RET				; AND RETURN
0340+  12AA             ;
0341+  12AA             PPIDE_INIT2:
0342+  12AA FD CB 03 46 	BIT	0,(IY+PPIDE_ACC)	; MASTER?
0343+  12AE 28 3D       	JR	Z,PPIDE_INIT4		; IF NOT MASTER, SKIP AHEAD
0344+  12B0             ;
0345+  12B0 CD 20 19    	CALL	NEWLINE			; FORMATTING
0346+  12B3 CD 3B 19    	PRTS("PPIDE:$")			; LABEL FOR IO ADDRESS
0346+  12B6 50 50 49 44 
0346+  12BA 45 3A 24 
0347+  12BD             ;
0348+  12BD CD 3B 19    	PRTS(" IO=0x$")			; LABEL FOR IO ADDRESS
0348+  12C0 20 49 4F 3D 
0348+  12C4 30 78 24 
0349+  12C7 FD 7E 0D    	LD	A,(IY+PPIDE_DATALO)	; GET IO BASE ADDRES
0350+  12CA CD 52 19    	CALL	PRTHEXBYTE		; DISPLAY IT
0351+  12CD             ;
0352+  12CD CD 61 13    	CALL	PPIDE_DETECT		; PROBE FOR INTERFACE
0353+  12D0 28 0B       	JR	Z,PPIDE_INIT3		; GOT IT, MOVE ON TO INIT UNITS
0354+  12D2 CD D7 18    	CALL	PC_SPACE		; FORMATTING
0355+  12D5 11 B6 18    	LD	DE,PPIDE_STR_NOPPI	; NO PPI MESSAGE
0356+  12D8 CD 12 1A    	CALL	WRITESTR		; DISPLAY IT
0357+  12DB 18 10       	JR	PPIDE_INIT4		; SKIP CFG ENTRY
0358+  12DD             ;	
0359+  12DD             PPIDE_INIT3:
0360+  12DD CD B0 15    	CALL	PPIDE_RESET		; RESET THE BUS
0361+  12E0 CD F4 12    	CALL	PPIDE_INIT5		; DETECT/INIT MASTER
0362+  12E3 FD E5       	PUSH	IY			; SAVE CFG PTR
0363+  12E5 CD DE 16    	CALL	PPIDE_GOPARTNER		; SWITCH IY TO PARTNER CFG
0364+  12E8 CD F4 12    	CALL	PPIDE_INIT5		; DETECT/INIT SLAVE
0365+  12EB FD E1       	POP	IY			; RESTORE CFG PTR
0366+  12ED             ;	
0367+  12ED             PPIDE_INIT4:
0368+  12ED 11 12 00    	LD	DE,PPIDE_CFGSIZ		; SIZE OF CFG TABLE ENTRY
0369+  12F0 FD 19       	ADD	IY,DE			; BUMP POINTER
0370+  12F2 18 AD       	JR	PPIDE_INIT1		; AND LOOP
0371+  12F4             ;
0372+  12F4             PPIDE_INIT5:
0373+  12F4             	; UPDATE DRIVER RELATIVE UNIT NUMBER IN CONFIG TABLE
0374+  12F4 3A D6 18    	LD	A,(PPIDE_DEVNUM)	; GET NEXT UNIT NUM TO ASSIGN
0375+  12F7 FD 77 00    	LD	(IY+PPIDE_DEV),A	; UPDATE IT
0376+  12FA 3C          	INC	A			; BUMP TO NEXT UNIT NUM TO ASSIGN
0377+  12FB 32 D6 18    	LD	(PPIDE_DEVNUM),A	; SAVE IT
0378+  12FE             ;
0379+  12FE             	; ADD UNIT TO GLOBAL DISK UNIT TABLE
0380+  12FE 01 72 13    	LD	BC,PPIDE_FNTBL		; BC := FUNC TABLE ADR
0381+  1301 FD E5       	PUSH	IY			; CFG ENTRY POINTER
0382+  1303 D1          	POP	DE			; COPY TO DE
0383+  1304 CD 5A 08    	CALL	DIO_ADDENT		; ADD ENTRY TO GLOBAL DISK DEV TABLE
0384+  1307             ;
0385+  1307             	; CHECK FOR BAD STATUS
0386+  1307 FD 7E 01    	LD	A,(IY+PPIDE_STAT)	; GET STATUS
0387+  130A B7          	OR	A			; SET FLAGS
0388+  130B C2 A6 17    	JP	NZ,PPIDE_PRTSTAT	; EXIT VIA PRINT STATUS
0389+  130E             ;
0390+  130E CD 32 18    	CALL	PPIDE_PRTPREFIX		; PRINT DEVICE PREFIX
0391+  1311             ;
0392+  1311 11 C6 18    	LD	DE,PPIDE_STR_8BIT
0393+  1314 FD CB 03 4E 	BIT	1,(IY+PPIDE_ACC)	; 8 BIT ACCESS?
0394+  1318 C4 12 1A    	CALL	NZ,WRITESTR
0395+  131B             ;
0396+  131B             	; PRINT LBA/NOLBA
0397+  131B CD D7 18    	CALL	PC_SPACE		; FORMATTING
0398+  131E FD CB 04 4E 	BIT	1,(IY+PPIDE_MED)	; TEST LBA FLAG
0399+  1322 11 B3 18    	LD	DE,PPIDE_STR_NO		; POINT TO "NO" STRING
0400+  1325 CC 12 1A    	CALL	Z,WRITESTR		; PRINT "NO" BEFORE "LBA" IF LBA NOT SUPPORTED
0401+  1328 CD 3B 19    	PRTS("LBA$")			; PRINT "LBA" REGARDLESS
0401+  132B 4C 42 41 24 
0402+  132F             ;
0403+  132F             	; PRINT STORAGE CAPACITY (BLOCK COUNT)
0404+  132F CD 3B 19    	PRTS(" BLOCKS=0x$")		; PRINT FIELD LABEL
0404+  1332 20 42 4C 4F 
0404+  1336 43 4B 53 3D 
0404+  133A 30 78 24 
0405+  133D 3E 05       	LD	A,PPIDE_MEDCAP		; OFFSET TO CAPACITY FIELD
0406+  133F CD 45 29    	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
0407+  1342 CD AE 1C    	CALL	LD32			; GET THE CAPACITY VALUE
0408+  1345 CD 78 19    	CALL	PRTHEX32		; PRINT HEX VALUE
0409+  1348             ;
0410+  1348             	; PRINT STORAGE SIZE IN MB
0411+  1348 CD 3B 19    	PRTS(" SIZE=$")			; PRINT FIELD LABEL
0411+  134B 20 53 49 5A 
0411+  134F 45 3D 24 
0412+  1352 06 0B       	LD	B,11			; 11 BIT SHIFT TO CONVERT BLOCKS --> MB
0413+  1354 CD 98 1C    	CALL	SRL32			; RIGHT SHIFT
0414+  1357             ;	CALL	PRTDEC			; PRINT LOW WORD IN DECIMAL (HIGH WORD DISCARDED)
0415+  1357 CD CA 1B    	CALL	PRTDEC32		; PRINT DWORD IN DECIMAL
0416+  135A CD 3B 19    	PRTS("MB$")			; PRINT SUFFIX
0416+  135D 4D 42 24    
0417+  1360             ;
0418+  1360 C9          	RET
0419+  1361             ;
0420+  1361             ;----------------------------------------------------------------------
0421+  1361             ; PROBE FOR PPI HARDWARE
0422+  1361             ;----------------------------------------------------------------------
0423+  1361             ;
0424+  1361             ; ON RETURN, ZF SET INDICATES HARDWARE FOUND
0425+  1361             ;
0426+  1361             PPIDE_DETECT:
0427+  1361             ;
0428+  1361             	; TEST FOR PPI EXISTENCE
0429+  1361             	; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
0430+  1361             	; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
0431+  1361             	; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
0432+  1361             	; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
0433+  1361             	; INTERFERE WITH THE VALUE BEING READ.
0434+  1361             ;
0435+  1361 3E 80       	LD	A,PPIDE_DIR_WRITE	; SET DATA BUS DIRECTION TO WRITE
0436+  1363 FD 4E 0F    	LD	C,(IY+PPIDE_PPI)	; PPI CONTROL WORD
0437+  1366 ED 79       	OUT	(C),A			; WRITE IT
0438+  1368             ;
0439+  1368 FD 4E 0D    	LD	C,(IY+PPIDE_DATALO)	; PPI PORT A, DATALO
0440+  136B AF          	XOR	A			; VALUE ZERO
0441+  136C ED 79       	OUT	(C),A			; PUSH VALUE TO PORT
0442+  136E ED 78       	IN	A,(C)			; GET PORT VALUE
0443+  1370~            #IF (PPIDETRACE >= 3)
0444+  1370~            	CALL	PC_SPACE
0445+  1370~            	CALL	PRTHEXBYTE
0446+  1370             #ENDIF
0447+  1370 B7          	OR	A			; SET FLAGS
0448+  1371 C9          	RET				; AND RETURN
0449+  1372             ;
0450+  1372             ;=============================================================================
0451+  1372             ; DRIVER FUNCTION TABLE
0452+  1372             ;=============================================================================
0453+  1372             ;
0454+  1372             PPIDE_FNTBL:
0455+  1372 E7 13       	.DW	PPIDE_STATUS
0456+  1374 B0 15       	.DW	PPIDE_RESET
0457+  1376 30 14       	.DW	PPIDE_SEEK
0458+  1378 91 13       	.DW	PPIDE_READ
0459+  137A 9D 13       	.DW	PPIDE_WRITE
0460+  137C 8A 13       	.DW	PPIDE_VERIFY
0461+  137E 8A 13       	.DW	PPIDE_FORMAT
0462+  1380 EC 13       	.DW	PPIDE_DEVICE
0463+  1382 02 14       	.DW	PPIDE_MEDIA
0464+  1384 8A 13       	.DW	PPIDE_DEFMED
0465+  1386 45 14       	.DW	PPIDE_CAP
0466+  1388 57 14       	.DW	PPIDE_GEOM
0467+  138A~            #IF (($ - PPIDE_FNTBL) != (DIO_FNCNT * 2))
0468+  138A~            	.ECHO	"*** INVALID PPIDE FUNCTION TABLE ***\n"
0469+  138A             #ENDIF
0470+  138A             ;
0471+  138A             PPIDE_VERIFY:
0472+  138A             PPIDE_FORMAT:
0473+  138A             PPIDE_DEFMED:
0474+  138A             	SYSCHKERR(ERR_NOTIMPL)		; NOT IMPLEMENTED
0474+  138A             
0474+  138A CD 60 23    
0474+  138D 3E FE       
0474+  138F B7          
0475+  1390 C9          	RET
0476+  1391             ;
0477+  1391             ;
0478+  1391             ;
0479+  1391             PPIDE_READ:
0480+  1391 CD A3 08    	CALL	HB_DSKREAD		; HOOK HBIOS DISK READ SUPERVISOR
0481+  1394 01 8C 14    	LD	BC,PPIDE_RDSEC		; GET ADR OF SECTOR READ FUNC
0482+  1397 ED 43 D1 18 	LD	(PPIDE_IOFNADR),BC	; SAVE IT AS PENDING IO FUNC
0483+  139B 18 0C       	JR	PPIDE_IO		; CONTINUE TO GENERIC IO ROUTINE
0484+  139D             ;
0485+  139D             ;
0486+  139D             ;
0487+  139D             PPIDE_WRITE:
0488+  139D CD F6 08    	CALL	HB_DSKWRITE		; HOOK HBIOS DISK WRITE SUPERVISOR
0489+  13A0 01 A5 14    	LD	BC,PPIDE_WRSEC		; GET ADR OF SECTOR WRITE FUNC
0490+  13A3 ED 43 D1 18 	LD	(PPIDE_IOFNADR),BC	; SAVE IT AS PENDING IO FUNC
0491+  13A7 18 00       	JR	PPIDE_IO		; CONTINUE TO GENERIC IO ROUTINE
0492+  13A9             ;
0493+  13A9             ;
0494+  13A9             ;
0495+  13A9             PPIDE_IO:
0496+  13A9 22 D4 18    	LD	(PPIDE_DSKBUF),HL	; SAVE DISK BUFFER ADDRESS
0497+  13AC 7B          	LD	A,E			; BLOCK COUNT TO A
0498+  13AD B7          	OR	A			; SET FLAGS
0499+  13AE C8          	RET	Z			; ZERO SECTOR I/O, RETURN W/ E=0 & A=0
0500+  13AF 47          	LD	B,A			; INIT SECTOR DOWNCOUNTER
0501+  13B0 0E 00       	LD	C,0			; INIT SECTOR READ/WRITE COUNT
0502+  13B2             #IF (PPIDETRACE == 1)
0503+  13B2 21 A5 17    	LD	HL,PPIDE_PRTERR		; SET UP PPIDE_PRTERR
0504+  13B5 E5          	PUSH	HL			; ... TO FILTER ALL EXITS
0505+  13B6             #ENDIF
0506+  13B6 C5          	PUSH	BC			; SAVE COUNTERS
0507+  13B7 CD 12 16    	CALL	PPIDE_SELUNIT		; HARDWARE SELECTION OF TARGET UNIT
0508+  13BA CD EA 16    	CALL	PPIDE_CHKERR		; CHECK FOR ERR STATUS AND RESET IF SO
0509+  13BD C1          	POP	BC			; RESTORE COUNTERS
0510+  13BE 20 1D       	JR	NZ,PPIDE_IO3		; BAIL OUT ON ERROR
0511+  13C0             PPIDE_IO1:
0512+  13C0 C5          	PUSH	BC			; SAVE COUNTERS
0513+  13C1 2A D1 18    	LD	HL,(PPIDE_IOFNADR)	; GET PENDING IO FUNCTION ADDRESS
0514+  13C4 CD CD 1A    	CALL	JPHL			; ... AND CALL IT
0515+  13C7 20 0E       	JR	NZ,PPIDE_IO2		; IF ERROR, SKIP INCREMENT
0516+  13C9             	; INCREMENT LBA
0517+  13C9 3E 09       	LD	A,PPIDE_LBA		; LBA OFFSET
0518+  13CB CD 45 29    	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
0519+  13CE CD D8 1C    	CALL	INC32HL			; INCREMENT THE VALUE
0520+  13D1             	; INCREMENT DMA
0521+  13D1 21 D5 18    	LD	HL,PPIDE_DSKBUF+1	; POINT TO MSB OF BUFFER ADR
0522+  13D4 34          	INC	(HL)			; BUMP DMA BY
0523+  13D5 34          	INC	(HL)			; ... 512 BYTES
0524+  13D6 AF          	XOR	A			; SIGNAL SUCCESS
0525+  13D7             PPIDE_IO2:
0526+  13D7 C1          	POP	BC			; RECOVER COUNTERS
0527+  13D8 20 03       	JR	NZ,PPIDE_IO3		; IF ERROR, BAIL OUT
0528+  13DA 0C          	INC	C			; BUMP COUNT OF SECTORS READ
0529+  13DB 10 E3       	DJNZ	PPIDE_IO1		; LOOP AS NEEDED
0530+  13DD             PPIDE_IO3:
0531+  13DD 59          	LD	E,C			; SECTOR READ COUNT TO E
0532+  13DE 2A D4 18    	LD	HL,(PPIDE_DSKBUF)	; CURRENT DMA TO HL
0533+  13E1 B7          	OR	A			; SET FLAGS BASED ON RETURN CODE
0534+  13E2 C8          	RET	Z			; RETURN IF SUCCESS
0535+  13E3 3E F7       	LD	A,ERR_IO		; SIGNAL IO ERROR
0536+  13E5 B7          	OR	A			; SET FLAGS
0537+  13E6 C9          	RET				; AND DONE
0538+  13E7             ;
0539+  13E7             ;
0540+  13E7             ;
0541+  13E7             PPIDE_STATUS:
0542+  13E7             	; RETURN UNIT STATUS
0543+  13E7 FD 7E 01    	LD	A,(IY+PPIDE_STAT)	; GET STATUS OF SELECTED DEVICE
0544+  13EA B7          	OR	A			; SET FLAGS
0545+  13EB C9          	RET				; AND RETURN
0546+  13EC             ;
0547+  13EC             ;
0548+  13EC             ;
0549+  13EC             PPIDE_DEVICE:
0550+  13EC 16 50       	LD	D,DIODEV_PPIDE		; D := DEVICE TYPE
0551+  13EE FD 5E 00    	LD	E,(IY+PPIDE_DEV)	; E := PHYSICAL DEVICE NUMBER
0552+  13F1 FD CB 04 46 	BIT	0,(IY+PPIDE_MED)	; TEST CF BIT IN FLAGS
0553+  13F5 0E 00       	LD	C,%00000000		; ASSUME NON-REMOVABLE HARD DISK
0554+  13F7 28 02       	JR	Z,PPIDE_DEVICE1		; IF Z, WE ARE DONE
0555+  13F9 0E 48       	LD	C,%01001000		; OTHERWISE REMOVABLE COMPACT FLASH
0556+  13FB             PPIDE_DEVICE1:
0557+  13FB 26 00       	LD	H,0			; H := 0, DRIVER HAS NO MODES
0558+  13FD FD 6E 0D    	LD	L,(IY+PPIDE_DATALO)	; L := BASE I/O ADDRESS
0559+  1400 AF          	XOR	A			; SIGNAL SUCCESS
0560+  1401 C9          	RET
0561+  1402             ;
0562+  1402             ; IDE_GETMED
0563+  1402             ;
0564+  1402             PPIDE_MEDIA:
0565+  1402 7B          	LD	A,E			; GET FLAGS
0566+  1403 B7          	OR	A			; SET FLAGS
0567+  1404 28 1B       	JR	Z,PPIDE_MEDIA2		; JUST REPORT CURRENT STATUS AND MEDIA
0568+  1406             ;
0569+  1406             	; GET CURRENT STATUS
0570+  1406 FD 7E 01    	LD	A,(IY+PPIDE_STAT)	; GET STATUS
0571+  1409 B7          	OR	A			; SET FLAGS
0572+  140A 20 12       	JR	NZ,PPIDE_MEDIA1		; ERROR ACTIVE, GO RIGHT TO RESET
0573+  140C             ;
0574+  140C             	; USE IDENTIFY COMMAND TO CHECK DEVICE
0575+  140C 21 CD 18    	LD	HL,PPIDE_TIMEOUT	; POINT TO TIMEOUT
0576+  140F 36 0A       	LD	(HL),PPIDE_TOFAST	; USE FAST TIMEOUT DURING IDENTIFY COMMAND
0577+  1411 CD 12 16    	CALL	PPIDE_SELUNIT		; HARDWARE SELECTION OF TARGET UNIT
0578+  1414 CD 76 14    	CALL	PPIDE_IDENTIFY		; EXECUTE IDENTIFY COMMAND
0579+  1417 21 CD 18    	LD	HL,PPIDE_TIMEOUT	; POINT TO TIMEOUT
0580+  141A 36 C8       	LD	(HL),PPIDE_TONORM	; BACK TO NORMAL TIMEOUT
0581+  141C 28 03       	JR	Z,PPIDE_MEDIA2		; IF SUCCESS, BYPASS RESET
0582+  141E             ;
0583+  141E             PPIDE_MEDIA1:
0584+  141E CD B0 15    	CALL	PPIDE_RESET		; RESET IDE INTERFACE
0585+  1421             ;
0586+  1421             PPIDE_MEDIA2:
0587+  1421 FD 7E 01    	LD	A,(IY+PPIDE_STAT)	; GET STATUS
0588+  1424 B7          	OR	A			; SET FLAGS
0589+  1425 16 00       	LD	D,0			; NO MEDIA CHANGE DETECTED
0590+  1427 1E 04       	LD	E,MID_HD		; ASSUME WE ARE OK
0591+  1429 C8          	RET	Z			; RETURN IF GOOD INIT
0592+  142A 1E 00       	LD	E,MID_NONE		; SIGNAL NO MEDIA
0593+  142C 3E F9       	LD	A,ERR_NOMEDIA		; NO MEDIA ERROR
0594+  142E B7          	OR	A			; SET FLAGS
0595+  142F C9          	RET				; AND RETURN
0596+  1430             ;
0597+  1430             ;
0598+  1430             ;
0599+  1430             PPIDE_SEEK:
0600+  1430 CB 7A       	BIT	7,D			; CHECK FOR LBA FLAG
0601+  1432 CC 4D 29    	CALL	Z,HB_CHS2LBA		; CLEAR MEANS CHS, CONVERT TO LBA
0602+  1435 CB BA       	RES	7,D			; CLEAR FLAG REGARDLESS (DOES NO HARM IF ALREADY LBA)
0603+  1437 FD 75 09    	LD	(IY+PPIDE_LBA+0),L	; SAVE NEW LBA
0604+  143A FD 74 0A    	LD	(IY+PPIDE_LBA+1),H	; ...
0605+  143D FD 73 0B    	LD	(IY+PPIDE_LBA+2),E	; ...
0606+  1440 FD 72 0C    	LD	(IY+PPIDE_LBA+3),D	; ...
0607+  1443 AF          	XOR	A			; SIGNAL SUCCESS
0608+  1444 C9          	RET				; AND RETURN
0609+  1445             ;
0610+  1445             ;
0611+  1445             ;
0612+  1445             PPIDE_CAP:
0613+  1445 FD 7E 01    	LD	A,(IY+PPIDE_STAT)	; GET STATUS
0614+  1448 F5          	PUSH	AF			; SAVE IT
0615+  1449 3E 05       	LD	A,PPIDE_MEDCAP		; OFFSET TO CAPACITY FIELD
0616+  144B CD 45 29    	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
0617+  144E CD AE 1C    	CALL	LD32			; GET THE CURRENT CAPACITY INTO DE:HL
0618+  1451 01 00 02    	LD	BC,512			; 512 BYTES PER BLOCK
0619+  1454 F1          	POP	AF			; RECOVER STATUS
0620+  1455 B7          	OR	A			; SET FLAGS
0621+  1456 C9          	RET
0622+  1457             ;
0623+  1457             ;
0624+  1457             ;
0625+  1457             PPIDE_GEOM:
0626+  1457             	; FOR LBA, WE SIMULATE CHS ACCESS USING 16 HEADS AND 16 SECTORS
0627+  1457             	; RETURN HS:CC -> DE:HL, SET HIGH BIT OF D TO INDICATE LBA CAPABLE
0628+  1457 CD 45 14    	CALL	PPIDE_CAP		; GET TOTAL BLOCKS IN DE:HL, BLOCK SIZE TO BC
0629+  145A 6C          	LD	L,H			; DIVPPIDE BY 256 FOR # TRACKS
0630+  145B 63          	LD	H,E			; ... HIGH BYTE DISCARDED, RESULT IN HL
0631+  145C 16 90       	LD	D,16 | $80		; HEADS / CYL = 16, SET LBA CAPABILITY BIT
0632+  145E 1E 10       	LD	E,16			; SECTORS / TRACK = 16
0633+  1460 C9          	RET				; DONE, A STILL HAS PPIDE_CAP STATUS
0634+  1461             ;
0635+  1461             ;=============================================================================
0636+  1461             ; FUNCTION SUPPORT ROUTINES
0637+  1461             ;=============================================================================
0638+  1461             ;
0639+  1461             ;
0640+  1461             ;
0641+  1461             PPIDE_SETFEAT:
0642+  1461 F5          	PUSH	AF
0643+  1462~            #IF (PPIDETRACE >= 3)
0644+  1462~            	CALL	PPIDE_PRTPREFIX
0645+  1462~            	PRTS(" SETFEAT$")
0645+  1462~            	PRTS(" SETFEAT$")
0646+  1462             #ENDIF
0647+  1462 3A D3 18    	LD	A,(PPIDE_DRVHD)
0648+  1465             	;OUT	(PPIDE_REG_DRVHD),A
0649+  1465 CD 63 17    	CALL	PPIDE_OUT
0650+  1468 0E          	.DB	PPIDE_REG_DRVHD
0651+  1469~            #IF (PPIDETRACE >= 3)
0652+  1469~            	CALL	PC_SPACE
0653+  1469~            	CALL	PRTHEXBYTE
0654+  1469             #ENDIF
0655+  1469 F1          	POP	AF
0656+  146A             	;OUT	(PPIDE_REG_FEAT),A	; SET THE FEATURE VALUE
0657+  146A CD 63 17    	CALL	PPIDE_OUT
0658+  146D 09          	.DB	PPIDE_REG_FEAT
0659+  146E~            #IF (PPIDETRACE >= 3)
0660+  146E~            	CALL	PC_SPACE
0661+  146E~            	CALL	PRTHEXBYTE
0662+  146E             #ENDIF
0663+  146E 3E EF       	LD	A,PPIDE_CMD_SETFEAT	; CMD = SETFEAT
0664+  1470 32 D0 18    	LD	(PPIDE_CMD),A		; SAVE IT
0665+  1473 C3 DA 14    	JP	PPIDE_RUNCMD		; RUN COMMAND AND EXIT
0666+  1476             ;
0667+  1476             ;
0668+  1476             ;
0669+  1476             PPIDE_IDENTIFY:
0670+  1476~            #IF (PPIDETRACE >= 3)
0671+  1476~            	CALL	PPIDE_PRTPREFIX
0672+  1476~            	PRTS(" IDDEV$")
0672+  1476~            	PRTS(" IDDEV$")
0673+  1476             #ENDIF
0674+  1476 3A D3 18    	LD	A,(PPIDE_DRVHD)
0675+  1479             	;OUT	(PPIDE_REG_DRVHD),A
0676+  1479 CD 63 17    	CALL	PPIDE_OUT
0677+  147C 0E          	.DB	PPIDE_REG_DRVHD
0678+  147D~            #IF (PPIDETRACE >= 3)
0679+  147D~            	CALL	PC_SPACE
0680+  147D~            	CALL	PRTHEXBYTE
0681+  147D             #ENDIF
0682+  147D 3E EC       	LD	A,PPIDE_CMD_IDDEV
0683+  147F 32 D0 18    	LD	(PPIDE_CMD),A
0684+  1482 CD DA 14    	CALL	PPIDE_RUNCMD
0685+  1485 C0          	RET	NZ
0686+  1486 21 5B 2A    	LD	HL,HB_WRKBUF
0687+  1489 C3 F0 14    	JP	PPIDE_GETBUF		; EXIT THRU BUFRD
0688+  148C             ;
0689+  148C             ;
0690+  148C             ;
0691+  148C             PPIDE_RDSEC:
0692+  148C             ;
0693+  148C~            #IF (PPIDETRACE >= 3)
0694+  148C~            	CALL	PPIDE_PRTPREFIX
0695+  148C~            	PRTS(" READ$")
0695+  148C~            	PRTS(" READ$")
0696+  148C             #ENDIF
0697+  148C 3A D3 18    	LD	A,(PPIDE_DRVHD)
0698+  148F             	;OUT	(PPIDE_REG_DRVHD),A
0699+  148F CD 63 17    	CALL	PPIDE_OUT
0700+  1492 0E          	.DB	PPIDE_REG_DRVHD
0701+  1493~            #IF (PPIDETRACE >= 3)
0702+  1493~            	CALL	PC_SPACE
0703+  1493~            	CALL	PRTHEXBYTE
0704+  1493             #ENDIF
0705+  1493 CD BE 14    	CALL	PPIDE_SETADDR		; SETUP CYL, TRK, HEAD
0706+  1496 3E 20       	LD	A,PPIDE_CMD_READ
0707+  1498 32 D0 18    	LD	(PPIDE_CMD),A
0708+  149B CD DA 14    	CALL	PPIDE_RUNCMD
0709+  149E C0          	RET	NZ
0710+  149F 2A D4 18    	LD	HL,(PPIDE_DSKBUF)
0711+  14A2 C3 F0 14    	JP	PPIDE_GETBUF
0712+  14A5             ;
0713+  14A5             ;
0714+  14A5             ;
0715+  14A5             PPIDE_WRSEC:
0716+  14A5             ;
0717+  14A5~            #IF (PPIDETRACE >= 3)
0718+  14A5~            	CALL	PPIDE_PRTPREFIX
0719+  14A5~            	PRTS(" WRITE$")
0719+  14A5~            	PRTS(" WRITE$")
0720+  14A5             #ENDIF
0721+  14A5 3A D3 18    	LD	A,(PPIDE_DRVHD)
0722+  14A8             	;OUT	(PPIDE_REG_DRVHD),A
0723+  14A8 CD 63 17    	CALL	PPIDE_OUT
0724+  14AB 0E          	.DB	PPIDE_REG_DRVHD
0725+  14AC~            #IF (PPIDETRACE >= 3)
0726+  14AC~            	CALL	PC_SPACE
0727+  14AC~            	CALL	PRTHEXBYTE
0728+  14AC             #ENDIF
0729+  14AC CD BE 14    	CALL	PPIDE_SETADDR		; SETUP CYL, TRK, HEAD
0730+  14AF 3E 30       	LD	A,PPIDE_CMD_WRITE
0731+  14B1 32 D0 18    	LD	(PPIDE_CMD),A
0732+  14B4 CD DA 14    	CALL	PPIDE_RUNCMD
0733+  14B7 C0          	RET	NZ
0734+  14B8 2A D4 18    	LD	HL,(PPIDE_DSKBUF)
0735+  14BB C3 49 15    	JP	PPIDE_PUTBUF
0736+  14BE             ;
0737+  14BE             ;
0738+  14BE             ;
0739+  14BE             PPIDE_SETADDR:
0740+  14BE             ;
0741+  14BE~            #IF (DSKYENABLE)
0742+  14BE~            	LD	A,PPIDE_LBA
0743+  14BE~            	CALL	LDHLIYA
0744+  14BE~            	CALL	HB_DSKACT		; SHOW ACTIVITY
0745+  14BE             #ENDIF
0746+  14BE             	; SEND 3 LOWEST BYTES OF LBA IN REVERSE ORDER
0747+  14BE             	; IDE_IO_LBA3 HAS ALREADY BEEN SET
0748+  14BE             	; HSTLBA2-0 --> IDE_IO_LBA2-0
0749+  14BE FD 7E 0B    	LD	A,(IY+PPIDE_LBA+2)
0750+  14C1~            #IF (PPIDETRACE >= 3)
0751+  14C1~            	CALL	PC_SPACE
0752+  14C1~            	CALL	PRTHEXBYTE
0753+  14C1             #ENDIF
0754+  14C1 CD 63 17    	CALL	PPIDE_OUT
0755+  14C4 0D          	.DB	PPIDE_REG_LBA2
0756+  14C5             ;
0757+  14C5 FD 7E 0A    	LD	A,(IY+PPIDE_LBA+1)
0758+  14C8~            #IF (PPIDETRACE >= 3)
0759+  14C8~            	CALL	PC_SPACE
0760+  14C8~            	CALL	PRTHEXBYTE
0761+  14C8             #ENDIF
0762+  14C8 CD 63 17    	CALL	PPIDE_OUT
0763+  14CB 0C          	.DB	PPIDE_REG_LBA1
0764+  14CC             ;
0765+  14CC FD 7E 09    	LD	A,(IY+PPIDE_LBA+0)
0766+  14CF~            #IF (PPIDETRACE >= 3)
0767+  14CF~            	CALL	PC_SPACE
0768+  14CF~            	CALL	PRTHEXBYTE
0769+  14CF             #ENDIF
0770+  14CF CD 63 17    	CALL	PPIDE_OUT
0771+  14D2 0B          	.DB	PPIDE_REG_LBA0
0772+  14D3             ;
0773+  14D3 3E 01       	LD	A,1
0774+  14D5~            #IF (PPIDETRACE >= 3)
0775+  14D5~            	CALL	PC_SPACE
0776+  14D5~            	CALL	PRTHEXBYTE
0777+  14D5             #ENDIF
0778+  14D5 CD 63 17    	CALL	PPIDE_OUT
0779+  14D8 0A          	.DB	PPIDE_REG_COUNT
0780+  14D9             ;
0781+  14D9             ;;#IF (DSKYENABLE)
0782+  14D9             ;;	CALL	PPIDE_DSKY
0783+  14D9             ;;#ENDIF
0784+  14D9             ;
0785+  14D9 C9          	RET
0786+  14DA             ;
0787+  14DA             ;=============================================================================
0788+  14DA             ; COMMAND PROCESSING
0789+  14DA             ;=============================================================================
0790+  14DA             ;
0791+  14DA             PPIDE_RUNCMD:
0792+  14DA CD F2 16    	CALL	PPIDE_WAITRDY		; WAIT FOR DRIVE READY
0793+  14DD C0          	RET	NZ			; BAIL OUT ON TIMEOUT
0794+  14DE             ;
0795+  14DE 3A D0 18    	LD	A,(PPIDE_CMD)		; GET THE COMMAND
0796+  14E1~            #IF (PPIDETRACE >= 3)
0797+  14E1~            	CALL	PC_SPACE
0798+  14E1~            	CALL	PRTHEXBYTE
0799+  14E1             #ENDIF
0800+  14E1             	;OUT	(PPIDE_REG_CMD),A	; SEND IT (STARTS EXECUTION)
0801+  14E1 CD 63 17    	CALL	PPIDE_OUT
0802+  14E4 0F          	.DB	PPIDE_REG_CMD
0803+  14E5~            #IF (PPIDETRACE >= 3)
0804+  14E5~            	PRTS(" -->$")
0804+  14E5~            	PRTS(" -->$")
0805+  14E5             #ENDIF
0806+  14E5             ;
0807+  14E5 CD 2A 17    	CALL	PPIDE_WAITBSY		; WAIT FOR DRIVE READY (COMMAND DONE)
0808+  14E8 C0          	RET	NZ			; BAIL OUT ON TIMEOUT
0809+  14E9             ;
0810+  14E9 CD A2 15    	CALL	PPIDE_GETRES
0811+  14EC C2 8C 17    	JP	NZ,PPIDE_CMDERR
0812+  14EF C9          	RET
0813+  14F0             ;
0814+  14F0             ;
0815+  14F0             ;
0816+  14F0             PPIDE_GETBUF:
0817+  14F0~            #IF (PPIDETRACE >= 3)
0818+  14F0~            	PRTS(" GETBUF$")
0818+  14F0~            	PRTS(" GETBUF$")
0819+  14F0             #ENDIF
0820+  14F0             ;
0821+  14F0             	; WAIT FOR BUFFER
0822+  14F0 CD 0E 17    	CALL	PPIDE_WAITDRQ		; WAIT FOR BUFFER READY
0823+  14F3 C0          	RET	NZ			; BAIL OUT IF TIMEOUT
0824+  14F4             ;
0825+  14F4             	; SETUP PPI TO READ
0826+  14F4 3E 92       	LD	A,PPIDE_DIR_READ	; SET DATA BUS DIRECTION TO READ
0827+  14F6             	;OUT	(PPIDE_IO_PPI),A	; DO IT
0828+  14F6 FD 4E 0F    	LD	C,(IY+PPIDE_PPI)	; PPI CONTROL WORD
0829+  14F9 ED 79       	OUT	(C),A			; WRITE IT
0830+  14FB             ;
0831+  14FB             	; SELECT READ/WRITE IDE REGISTER
0832+  14FB 3E 08       	LD	A,PPIDE_REG_DATA	; DATA REGISTER
0833+  14FD             	;OUT	(PPIDE_IO_CTL),A	; DO IT
0834+  14FD FD 4E 0E    	LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
0835+  1500 ED 79       	OUT	(C),A			; DO IT
0836+  1502 5F          	LD	E,A			; E := READ UNASSERTED
0837+  1503 EE 40       	XOR	PPIDE_CTL_DIOR		; SWAP THE READ LINE BIT
0838+  1505 57          	LD	D,A			; D := READ ASSERTED
0839+  1506             ;
0840+  1506             	; LOOP SETUP
0841+  1506 AF          	XOR	A			; IMPORTANT, NEEDED FOR LOOP END COMPARISON
0842+  1507 06 00       	LD	B,0			; 256 ITERATIONS
0843+  1509 FD 4E 0E    	LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
0844+  150C             ;
0845+  150C FD CB 03 4E 	BIT	1,(IY+PPIDE_ACC)	; 8 BIT?
0846+  1510 28 08       	JR	Z,PPIDE_GETBUF1		; IF NOT, DO 16 BIT
0847+  1512 CD 2B 15    	CALL	PPIDE_GETBUF8		; FIRST PASS (FIRST 256 BYTES)
0848+  1515 CD 2B 15    	CALL	PPIDE_GETBUF8		; SECOND PASS (LAST 256 BYTES)
0849+  1518 18 06       	JR	PPIDE_GETBUF2		; CONTINUE
0850+  151A             PPIDE_GETBUF1:
0851+  151A CD 39 15    	CALL	PPIDE_GETBUF16		; FIRST PASS (FIRST 256 BYTES)
0852+  151D CD 39 15    	CALL	PPIDE_GETBUF16		; SECOND PASS (LAST 256 BYTES)
0853+  1520             PPIDE_GETBUF2:
0854+  1520 CD F2 16    	CALL	PPIDE_WAITRDY		; PROBLEMS IF THIS IS REMOVED!
0855+  1523 C0          	RET	NZ
0856+  1524 CD A2 15    	CALL	PPIDE_GETRES
0857+  1527 C2 90 17    	JP	NZ,PPIDE_IOERR
0858+  152A C9          	RET
0859+  152B             ;
0860+  152B             PPIDE_GETBUF8:	; 8 BIT WIDE READ LOOP
0861+  152B             	; ENTER W/ C = PPIDE_IO_CTL
0862+  152B ED 51       	OUT	(C),D			; ASSERT READ
0863+  152D 0D          	DEC	C			; CTL -> MSB
0864+  152E 0D          	DEC	C			; MSB -> LSB
0865+  152F ED A2       	INI				; READ FROM LSB
0866+  1531 0C          	INC	C			; LSB -> MSB
0867+  1532 0C          	INC	C			; MSB -> CTL
0868+  1533 ED 59       	OUT	(C),E			; DEASSERT READ
0869+  1535 B8          	CP	B			; B == A == 0?
0870+  1536 20 F3       	JR	NZ,PPIDE_GETBUF8	; LOOP UNTIL DONE
0871+  1538 C9          	RET
0872+  1539             ;
0873+  1539             PPIDE_GETBUF16:	; 16 BIT WIDE READ LOOP
0874+  1539             	; ENTER W/ C = PPIDE_IO_CTL
0875+  1539 ED 51       	OUT	(C),D			; ASSERT READ
0876+  153B 0D          	DEC	C			; CTL -> MSB
0877+  153C 0D          	DEC	C			; MSB -> LSB
0878+  153D ED A2       	INI				; READ FROM LSB
0879+  153F 0C          	INC	C			; LSB -> MSB
0880+  1540 ED A2       	INI				; READ MSB FOR 16 BIT
0881+  1542 0C          	INC	C			; MSB -> CTL
0882+  1543 ED 59       	OUT	(C),E			; DEASSERT READ
0883+  1545 B8          	CP	B			; B == A == 0?
0884+  1546 20 F1       	JR	NZ,PPIDE_GETBUF16	; LOOP UNTIL DONE
0885+  1548 C9          	RET
0886+  1549             ;
0887+  1549             ;
0888+  1549             ;
0889+  1549             PPIDE_PUTBUF:
0890+  1549~            #IF (PPIDETRACE >= 3)
0891+  1549~            	PRTS(" PUTBUF$")
0891+  1549~            	PRTS(" PUTBUF$")
0892+  1549             #ENDIF
0893+  1549             ;
0894+  1549             	; WAIT FOR BUFFER
0895+  1549 CD 0E 17    	CALL	PPIDE_WAITDRQ		; WAIT FOR BUFFER READY
0896+  154C C0          	RET	NZ			; BAIL OUT IF TIMEOUT
0897+  154D             ;
0898+  154D             	; SETUP PPI TO WRITE
0899+  154D 3E 80       	LD	A,PPIDE_DIR_WRITE	; SET DATA BUS DIRECTION TO WRITE
0900+  154F             	;OUT	(PPIDE_IO_PPI),A	; DO IT
0901+  154F FD 4E 0F    	LD	C,(IY+PPIDE_PPI)	; PPI CONTROL WORD
0902+  1552 ED 79       	OUT	(C),A			; WRITE IT
0903+  1554             ;
0904+  1554             	; SELECT READ/WRITE IDE REGISTER
0905+  1554 3E 08       	LD	A,PPIDE_REG_DATA	; DATA REGISTER
0906+  1556             	;OUT	(PPIDE_IO_CTL),A	; DO IT
0907+  1556 FD 4E 0E    	LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
0908+  1559 ED 79       	OUT	(C),A			; DO IT
0909+  155B 5F          	LD	E,A			; E := WRITE UNASSERTED
0910+  155C EE 20       	XOR	PPIDE_CTL_DIOW		; SWAP THE READ LINE BIT
0911+  155E 57          	LD	D,A			; D := WRITE ASSERTED
0912+  155F             ;
0913+  155F             	; LOOP SETUP
0914+  155F AF          	XOR	A			; IMPORTANT, NEEDED FOR LOOP END COMPARISON
0915+  1560 06 00       	LD	B,0			; 256 ITERATIONS
0916+  1562 FD 4E 0E    	LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
0917+  1565             ;
0918+  1565 FD CB 03 4E 	BIT	1,(IY+PPIDE_ACC)	; 8 BIT?
0919+  1569 28 08       	JR	Z,PPIDE_PUTBUF1		; IF NOT, DO 16 BIT
0920+  156B CD 84 15    	CALL	PPIDE_PUTBUF8		; FIRST PASS (FIRST 256 BYTES)
0921+  156E CD 84 15    	CALL	PPIDE_PUTBUF8		; SECOND PASS (LAST 256 BYTES)
0922+  1571 18 06       	JR	PPIDE_PUTBUF2		; CONTINUE
0923+  1573             PPIDE_PUTBUF1:
0924+  1573 CD 92 15    	CALL	PPIDE_PUTBUF16		; FIRST PASS (FIRST 256 BYTES)
0925+  1576 CD 92 15    	CALL	PPIDE_PUTBUF16		; SECOND PASS (LAST 256 BYTES)
0926+  1579             PPIDE_PUTBUF2:
0927+  1579 CD F2 16    	CALL	PPIDE_WAITRDY		; PROBLEMS IF THIS IS REMOVED!
0928+  157C C0          	RET	NZ
0929+  157D CD A2 15    	CALL	PPIDE_GETRES
0930+  1580 C2 90 17    	JP	NZ,PPIDE_IOERR
0931+  1583 C9          	RET
0932+  1584             ;
0933+  1584             PPIDE_PUTBUF8:	; 8 BIT WIDE WRITE LOOP
0934+  1584 0D          	DEC	C			; CTL -> MSB
0935+  1585 0D          	DEC	C			; MSB -> LSB
0936+  1586 ED A3       	OUTI				; WRITE NEXT BYTE (LSB)
0937+  1588 0C          	INC	C			; LSB -> MSB
0938+  1589 0C          	INC	C			; MSB -> CTL
0939+  158A ED 51       	OUT	(C),D			; ASSERT WRITE
0940+  158C ED 59       	OUT	(C),E			; DEASSERT WRITE
0941+  158E B8          	CP	B			; B == A == 0?
0942+  158F 20 F3       	JR	NZ,PPIDE_PUTBUF8	; LOOP UNTIL DONE
0943+  1591 C9          	RET
0944+  1592             ;
0945+  1592             PPIDE_PUTBUF16:	; 16 BIT WIDE WRITE LOOP
0946+  1592 0D          	DEC	C			; CTL -> MSB
0947+  1593 0D          	DEC	C			; MSB -> LSB
0948+  1594 ED A3       	OUTI				; WRITE NEXT BYTE (LSB)
0949+  1596 0C          	INC	C			; LSB -> MSB
0950+  1597 ED A3       	OUTI				; WRITE NEXT BYTE (MSB)
0951+  1599 0C          	INC	C			; MSB -> CTL
0952+  159A ED 51       	OUT	(C),D			; ASSERT WRITE
0953+  159C ED 59       	OUT	(C),E			; DEASSERT WRITE
0954+  159E B8          	CP	B			; B == A == 0?
0955+  159F 20 F1       	JR	NZ,PPIDE_PUTBUF16	; LOOP UNTIL DONE
0956+  15A1 C9          	RET
0957+  15A2             ;
0958+  15A2             ;
0959+  15A2             ;
0960+  15A2             PPIDE_GETRES:
0961+  15A2             	;IN	A,(PPIDE_REG_STAT)	; READ STATUS
0962+  15A2 CD 44 17    	CALL	PPIDE_IN
0963+  15A5 0F          	.DB	PPIDE_REG_STAT
0964+  15A6~            #IF (PPIDETRACE >= 3)
0965+  15A6~            	CALL	PC_SPACE
0966+  15A6~            	CALL	PRTHEXBYTE
0967+  15A6             #ENDIF
0968+  15A6 E6 01       	AND	%00000001		; ERROR BIT SET?
0969+  15A8 C8          	RET	Z			; NOPE, RETURN WITH ZF
0970+  15A9             ;
0971+  15A9             	;IN	A,(PPIDE_REG_ERR)	; READ ERROR REGISTER
0972+  15A9 CD 44 17    	CALL	PPIDE_IN
0973+  15AC 09          	.DB	PPIDE_REG_ERR
0974+  15AD~            #IF (PPIDETRACE >= 3)
0975+  15AD~            	CALL	PC_SPACE
0976+  15AD~            	CALL	PRTHEXBYTE
0977+  15AD             #ENDIF
0978+  15AD F6 FF       	OR	$FF			; FORCE NZ TO SIGNAL ERROR
0979+  15AF C9          	RET				; RETURN
0980+  15B0             ;
0981+  15B0             ;=============================================================================
0982+  15B0             ; HARDWARE INTERFACE ROUTINES
0983+  15B0             ;=============================================================================
0984+  15B0             ;
0985+  15B0             ; SOFT RESET OF ALL DEVICES ON BUS
0986+  15B0             ;
0987+  15B0             PPIDE_RESET:
0988+  15B0~            #IF (PPIDETRACE >= 3)
0989+  15B0~            	CALL	PPIDE_PRTPREFIX
0990+  15B0~            	PRTS(" RESET$")
0990+  15B0~            	PRTS(" RESET$")
0991+  15B0             #ENDIF
0992+  15B0             ;
0993+  15B0             	; OLDER CF CARDS DO NOT SEEM TO SET THE 
0994+  15B0             	; REGISTERS ON RESET, SO HERE WE FAKE THINGS BY
0995+  15B0             	; SETTING THEM AS A RESET WOULD
0996+  15B0~            #IF (PPIDETRACE >= 3)
0997+  15B0~            	PRTS(" FAKE$")
0997+  15B0~            	PRTS(" FAKE$")
0998+  15B0             #ENDIF
0999+  15B0 AF          	XOR	A
1000+  15B1             	;OUT	(IDE_IO_CYLLO),A
1001+  15B1 CD 63 17    	CALL	PPIDE_OUT
1002+  15B4 0C          	.DB	PPIDE_REG_CYLLO
1003+  15B5             	;OUT	(IDE_IO_CYLHI),A
1004+  15B5 CD 63 17    	CALL	PPIDE_OUT
1005+  15B8 0D          	.DB	PPIDE_REG_CYLHI
1006+  15B9 3C          	INC	A
1007+  15BA             	;OUT	(IDE_IO_COUNT),A
1008+  15BA CD 63 17    	CALL	PPIDE_OUT
1009+  15BD 0A          	.DB	PPIDE_REG_COUNT
1010+  15BE             	;OUT	(IDE_IO_SECT),A
1011+  15BE CD 63 17    	CALL	PPIDE_OUT
1012+  15C1 0B          	.DB	PPIDE_REG_SECT
1013+  15C2             ;
1014+  15C2             	; SETUP PPI TO READ
1015+  15C2 3E 92       	LD	A,PPIDE_DIR_READ	; SET DATA BUS DIRECTION TO READ
1016+  15C4             	;OUT	(PPIDE_IO_PPI),A	; DO IT
1017+  15C4 FD 4E 0F    	LD	C,(IY+PPIDE_PPI)	; PPI CONTROL WORD
1018+  15C7 ED 79       	OUT	(C),A			; WRITE IT
1019+  15C9             ;
1020+  15C9             ; IF A DSKYNG IS ACTIVE AND IS ON THE SAME PPI PORT AS THE PPISD BEING
1021+  15C9             ; RESET, THEN THE DSKYNG WILL ALSO BE RESET.  SO, THE RESET CODE IS
1022+  15C9             ; BRACKETED WITH CODE TO SAVE AND RESTORE THE STATE OF THE DSKYNG.
1023+  15C9             ; THERE IS NO CHECK FOR THE SPECIFIC PPI PORT SINCE IT DOES NO HARM
1024+  15C9             ; IF THE DSKYNG IS SAVED AND RESTORED.
1025+  15C9             ;
1026+  15C9~            #IF (DSKYENABLE)
1027+  15C9~              #IF (DSKYMODE == DSKYMODE_NG)
1028+  15C9~            	; SAVE CONTENTS OF DSKY DISPLAY ACROSS RESET
1029+  15C9~            	LD	B,8
1030+  15C9~            	LD	C,0
1031+  15C9~            	LD	HL,DSKY_BUF
1032+  15C9~            	CALL	DSKY_GETSTR
1033+  15C9~              #ENDIF
1034+  15C9             #ENDIF
1035+  15C9             ;
1036+  15C9             	; PULSE IDE RESET LINE
1037+  15C9 3E 80       	LD	A,PPIDE_CTL_RESET
1038+  15CB             	;OUT	(PPIDE_IO_CTL),A
1039+  15CB FD 4E 0E    	LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
1040+  15CE ED 79       	OUT	(C),A
1041+  15D0 11 14 00    	LD	DE,20
1042+  15D3 CD 04 1B    	CALL	VDELAY
1043+  15D6 AF          	XOR	A
1044+  15D7             	;OUT	(PPIDE_IO_CTL),A
1045+  15D7 ED 79       	OUT	(C),A
1046+  15D9 11 14 00    	LD	DE,20
1047+  15DC CD 04 1B    	CALL	VDELAY
1048+  15DF             ;	
1049+  15DF~            #IF (DSKYENABLE)
1050+  15DF~              #IF (DSKYMODE == DSKYMODE_NG)
1051+  15DF~            	; REININT DSKY AND RESTORE CONTENTS
1052+  15DF~            	CALL	DSKY_REINIT
1053+  15DF~            	LD	B,8
1054+  15DF~            	LD	C,0
1055+  15DF~            	LD	HL,DSKY_BUF
1056+  15DF~            	CALL	DSKY_PUTSTR
1057+  15DF~              #ENDIF
1058+  15DF             #ENDIF
1059+  15DF             ;
1060+  15DF 3E 0A       	LD	A,%00001010		; SET ~IEN, NO INTERRUPTS
1061+  15E1             	;OUT	(PPIDE_REG_CTRL),A
1062+  15E1 CD 63 17    	CALL	PPIDE_OUT
1063+  15E4 16          	.DB	PPIDE_REG_CTRL
1064+  15E5             ;
1065+  15E5             ; SPEC ALLOWS UP TO 450MS FOR DEVICES TO ASSERT THEIR PRESENCE
1066+  15E5             ; VIA -DASP.  I ENCOUNTER PROBLEMS LATER ON IF I DON'T WAIT HERE
1067+  15E5             ; FOR THAT TO OCCUR.  THUS FAR, IT APPEARS THAT 150MS IS SUFFICIENT
1068+  15E5             ; FOR ANY DEVICE ENCOUNTERED.  MAY NEED TO EXTEND BACK TO 500MS
1069+  15E5             ; IF A SLOWER DEVICE IS ENCOUNTERED.
1070+  15E5             ;
1071+  15E5             	;LD	DE,500000/16		; ~500MS
1072+  15E5 11 9F 24    	LD	DE,150000/16		; ~???MS
1073+  15E8 CD 04 1B    	CALL	VDELAY
1074+  15EB             ;
1075+  15EB             	; INITIALIZE THE INDIVIDUAL UNITS (MASTER AND SLAVE).
1076+  15EB             	; BASED ON TESTING, IT APPEARS THAT THE MASTER UNIT MUST
1077+  15EB             	; BE DONE FIRST OR THIS BEHAVES BADLY.
1078+  15EB FD E5       	PUSH	IY			; SAVE CFG PTR
1079+  15ED FD CB 03 46 	BIT	0,(IY+PPIDE_ACC)	; MASTER?
1080+  15F1 CC DE 16    	CALL	Z,PPIDE_GOPARTNER	; IF NOT, SWITCH TO MASTER
1081+  15F4 CD 01 16    	CALL	PPIDE_INITUNIT		; INIT CURRENT UNIT
1082+  15F7 CD DE 16    	CALL	PPIDE_GOPARTNER		; POINT TO SLAVE
1083+  15FA CD 01 16    	CALL	PPIDE_INITUNIT		; INIT PARTNER UNIT
1084+  15FD FD E1       	POP	IY			; RECOVER ORIG CFG PTR
1085+  15FF             ;	
1086+  15FF AF          	XOR	A			; SIGNAL SUCCESS
1087+  1600 C9          	RET				; AND DONE
1088+  1601             ;
1089+  1601             ;
1090+  1601             ;
1091+  1601             PPIDE_INITUNIT:
1092+  1601 CD 12 16    	CALL	PPIDE_SELUNIT		; SELECT UNIT
1093+  1604 C0          	RET	NZ			; ABORT IF ERROR
1094+  1605             
1095+  1605 21 CD 18    	LD	HL,PPIDE_TIMEOUT	; POINT TO TIMEOUT
1096+  1608 36 C8       	LD	(HL),PPIDE_TONORM	; SET NORMAL TIMEOUT
1097+  160A             
1098+  160A CD 23 16    	CALL	PPIDE_PROBE		; DO PROBE
1099+  160D C0          	RET	NZ			; JUST RETURN IF NOTHING THERE
1100+  160E             
1101+  160E CD 74 16    	CALL	PPIDE_INITDEV		; IF FOUND, ATTEMPT TO INIT DEVICE
1102+  1611 C9          	RET				; DONE
1103+  1612             ;
1104+  1612             ; TAKE ANY ACTIONS REQUIRED TO SELECT DESIRED PHYSICAL UNIT
1105+  1612             ;
1106+  1612             PPIDE_SELUNIT:
1107+  1612~            #IF (PPIDETRACE >= 3)
1108+  1612~            	CALL	PPIDE_PRTPREFIX
1109+  1612~            	PRTS(" SELUNIT$")
1109+  1612~            	PRTS(" SELUNIT$")
1110+  1612             #ENDIF
1111+  1612 FD CB 03 46 	BIT	0,(IY+PPIDE_ACC)	; MASTER?
1112+  1616 28 04       	JR	Z,PPIDE_SELUNIT1	; HANDLE SLAVE
1113+  1618 3E E0       	LD	A,PPIDE_DRVMASTER	; MASTER
1114+  161A 18 02       	JR	PPIDE_SELUNIT2          
1115+  161C             PPIDE_SELUNIT1:                         
1116+  161C 3E F0       	LD	A,PPIDE_DRVSLAVE	; SLAVE
1117+  161E             PPIDE_SELUNIT2:                         
1118+  161E 32 D3 18    	LD	(PPIDE_DRVHD),A		; SAVE IT
1119+  1621 AF          	XOR	A			; SUCCESS
1120+  1622 C9          	RET
1121+  1623             ;
1122+  1623             ;
1123+  1623             ;
1124+  1623             PPIDE_PROBE:
1125+  1623~            #IF (PPIDETRACE >= 3)
1126+  1623~            	CALL	PPIDE_PRTPREFIX
1127+  1623~            	PRTS(" PROBE$")			; LABEL FOR IO ADDRESS
1127+  1623~            	PRTS(" PROBE$")			; LABEL FOR IO ADDRESS
1128+  1623             #ENDIF
1129+  1623             ;
1130+  1623 3A D3 18    	LD	A,(PPIDE_DRVHD)
1131+  1626             	;OUT	(IDE_IO_DRVHD),A
1132+  1626 CD 63 17    	CALL	PPIDE_OUT
1133+  1629 0E          	.DB	PPIDE_REG_DRVHD
1134+  162A~            #IF (PPIDETRACE >= 3)
1135+  162A~            	CALL	PC_SPACE
1136+  162A~            	CALL	PRTHEXBYTE
1137+  162A             #ENDIF
1138+  162A             
1139+  162A CD FD 1A    	CALL	DELAY			; DELAY ~16US
1140+  162D             ;
1141+  162D             	; BELOW TESTS FOR EXISTENCE OF AN IDE CONTROLLER ON THE
1142+  162D             	; PPIDE INTERFACE.  WE WRITE A VALUE OF ZERO FIRST SO THAT
1143+  162D             	; THE PPI BUS HOLD WILL RETURN A VALUE OF ZERO IF THERE IS
1144+  162D             	; NOTHING CONNECTED TO PPI PORT A.  THEN WE READ THE STATUS
1145+  162D             	; REGISTER.  IF AN IDE CONTROLLER IS THERE, IT SHOULD ALWAYS
1146+  162D             	; RETURN SOMETHING OTHER THAN ZERO.  IF AN IDE CONTROLLER IS
1147+  162D             	; THERE, THEN THE VALUE WRITTEN TO PPI PORT A IS IGNORED
1148+  162D             	; BECAUSE THE WRITE SIGNAL IS NEVER PULSED.
1149+  162D AF          	XOR	A
1150+  162E             	;OUT	(PPIDE_IO_DATALO),A
1151+  162E FD 4E 0D    	LD	C,(IY+PPIDE_DATALO)	; PPI PORT A, DATALO
1152+  1631 ED 79       	OUT	(C),A
1153+  1633             ;	IN	A,(PPIDE_REG_STAT)	; GET STATUS
1154+  1633 CD 44 17    	CALL	PPIDE_IN
1155+  1636 0F          	.DB	PPIDE_REG_STAT
1156+  1637~            #IF (PPIDETRACE >= 3)
1157+  1637~            	CALL	PC_SPACE
1158+  1637~            	CALL	PRTHEXBYTE
1159+  1637             #ENDIF
1160+  1637 B7          	OR	A
1161+  1638 CA 88 17    	JP	Z,PPIDE_NOMEDIA
1162+  163B             ;
1163+  163B~            #IF (PPIDETRACE >= 3)
1164+  163B~            	CALL	PPIDE_REGDUMP
1165+  163B             #ENDIF
1166+  163B             ;
1167+  163B             	;JR	PPIDE_PROBE1		; *DEBUG*
1168+  163B             ;
1169+  163B             PPIDE_PROBE0:
1170+  163B CD 2A 17    	CALL	PPIDE_WAITBSY		; WAIT FOR BUSY TO CLEAR
1171+  163E C2 88 17    	JP	NZ,PPIDE_NOMEDIA	; CONVERT TIMEOUT TO NO MEDIA AND RETURN
1172+  1641             ;
1173+  1641~            #IF (PPIDETRACE >= 3)
1174+  1641~            	CALL	PPIDE_REGDUMP
1175+  1641             #ENDIF
1176+  1641             ;
1177+  1641             	; CHECK STATUS
1178+  1641             ;	IN	A,(PPIDE_REG_STAT)	; GET STATUS
1179+  1641 CD 44 17    	CALL	PPIDE_IN
1180+  1644 0F          	.DB	PPIDE_REG_STAT
1181+  1645~            #IF (PPIDETRACE >= 3)
1182+  1645~            	CALL	PC_SPACE
1183+  1645~            	CALL	PRTHEXBYTE		; IF DEBUG, PRINT STATUS
1184+  1645             #ENDIF
1185+  1645 B7          	OR	A			; SET FLAGS TO TEST FOR ZERO
1186+  1646 CA 88 17    	JP	Z,PPIDE_NOMEDIA		; CONTINUE IF NON-ZERO
1187+  1649             ;
1188+  1649             	; CHECK SIGNATURE
1189+  1649~            #IF (PPIDETRACE >= 3)
1190+  1649~            	CALL	PC_SPACE
1191+  1649             #ENDIF
1192+  1649             	;IN	A,(PPIDE_REG_COUNT)
1193+  1649 CD 44 17    	CALL	PPIDE_IN
1194+  164C 0A          	.DB	PPIDE_REG_COUNT
1195+  164D~            #IF (PPIDETRACE >= 3)
1196+  164D~            	CALL	PRTHEXBYTE
1197+  164D             #ENDIF
1198+  164D FE 01       	CP	$01
1199+  164F C2 88 17    	JP	NZ,PPIDE_NOMEDIA
1200+  1652~            #IF (PPIDETRACE >= 3)
1201+  1652~            	CALL	PC_SPACE
1202+  1652             #ENDIF
1203+  1652             	;IN	A,(PPIDE_REG_SECT)
1204+  1652 CD 44 17    	CALL	PPIDE_IN
1205+  1655 0B          	.DB	PPIDE_REG_SECT
1206+  1656~            #IF (PPIDETRACE >= 3)
1207+  1656~            	CALL	PRTHEXBYTE
1208+  1656             #ENDIF
1209+  1656 FE 01       	CP	$01
1210+  1658 C2 88 17    	JP	NZ,PPIDE_NOMEDIA
1211+  165B~            #IF (PPIDETRACE >= 3)
1212+  165B~            	CALL	PC_SPACE
1213+  165B             #ENDIF
1214+  165B             	;IN	A,(PPIDE_REG_CYLLO)
1215+  165B CD 44 17    	CALL	PPIDE_IN
1216+  165E 0C          	.DB	PPIDE_REG_CYLLO
1217+  165F~            #IF (PPIDETRACE >= 3)
1218+  165F~            	CALL	PRTHEXBYTE
1219+  165F             #ENDIF
1220+  165F FE 00       	CP	$00
1221+  1661 C2 88 17    	JP	NZ,PPIDE_NOMEDIA
1222+  1664~            #IF (PPIDETRACE >= 3)
1223+  1664~            	CALL	PC_SPACE
1224+  1664             #ENDIF
1225+  1664             	;IN	A,(PPIDE_REG_CYLHI)
1226+  1664 CD 44 17    	CALL	PPIDE_IN
1227+  1667 0D          	.DB	PPIDE_REG_CYLHI
1228+  1668~            #IF (PPIDETRACE >= 3)
1229+  1668~            	CALL	PRTHEXBYTE
1230+  1668             #ENDIF
1231+  1668 FE 00       	CP	$00
1232+  166A C2 88 17    	JP	NZ,PPIDE_NOMEDIA
1233+  166D             ;
1234+  166D             PPIDE_PROBE1:
1235+  166D             	; SIGNATURE MATCHES ATA DEVICE, RECORD TYPE AND RETURN SUCCESS
1236+  166D 3E 01       	LD	A,PPIDE_TYPEATA		; TYPE = ATA
1237+  166F FD 77 02    	LD	(IY+PPIDE_TYPE),A	; SET IT IN INSTANCE DATA
1238+  1672 AF          	XOR	A			; SIGNAL SUCCESS
1239+  1673 C9          	RET				; DONE, NOTE THAT A=0 AND Z IS SET
1240+  1674             ;
1241+  1674             ; (RE)INITIALIZE DEVICE
1242+  1674             ;
1243+  1674             PPIDE_INITDEV:
1244+  1674             ;
1245+  1674 FD 7E 02    	LD	A,(IY+PPIDE_TYPE)	; GET THE DEVICE TYPE
1246+  1677 B7          	OR	A			; SET FLAGS
1247+  1678 CA 88 17    	JP	Z,PPIDE_NOMEDIA		; EXIT SETTING NO MEDIA STATUS
1248+  167B             ;
1249+  167B FD CB 03 4E 	BIT	1,(IY+PPIDE_ACC)	; 8 BIT ACCESS?
1250+  167F 28 08       	JR	Z,PPIDE_INITDEV0	; NO, DO 16 BIT INIT
1251+  1681 3E 01       	LD	A,PPIDE_FEAT_ENABLE8BIT	; FEATURE VALUE = ENABLE 8-BIT PIO
1252+  1683 CD 61 14    	CALL	PPIDE_SETFEAT		; SET FEATURE
1253+  1686 C0          	RET	NZ			; BAIL OUT ON ERROR
1254+  1687 18 05       	JR	PPIDE_INITDEV00		; CONTINUE
1255+  1689             ;
1256+  1689             PPIDE_INITDEV0:
1257+  1689             	; "REAL" IDE DRIVES MAY NOT ACCEPT THE DISABLE8BIT FEATURE COMMAND,
1258+  1689             	; SO IT IS ONLY AN ERROR IF WE ARE ATTEMPTING TO ENABLE8BIT.
1259+  1689             	; CREDIT TO ED BRINDLEY FOR THIS CORRECTION.  SO ERROR RETURN IGNORED HERE.
1260+  1689 3E 81       	LD	A,PPIDE_FEAT_DISABLE8BIT	; FEATURE VALUE = ENABLE 8-BIT PIO
1261+  168B CD 61 14    	CALL	PPIDE_SETFEAT		; SET FEATURE, IGNORE ERRORS
1262+  168E             ;
1263+  168E             PPIDE_INITDEV00:
1264+  168E             ;
1265+  168E CD 76 14    	CALL	PPIDE_IDENTIFY		; EXECUTE PPIDENTIFY COMMAND
1266+  1691 C0          	RET	NZ			; BAIL OUT ON ERROR
1267+  1692             ;
1268+  1692 11 5B 2A    	LD	DE,HB_WRKBUF		; POINT TO BUFFER
1269+  1695~            #IF (PPIDETRACE >= 3)
1270+  1695~            	CALL	DUMP_BUFFER		; DUMP IT IF DEBUGGING
1271+  1695             #ENDIF
1272+  1695             ;
1273+  1695 FD 36 04 00 	LD	(IY+PPIDE_MED),0	; CLEAR MEDIA FLAGS
1274+  1699             ;
1275+  1699             	; DETERMINE IF CF DEVICE BY TESTING FOR CF CARD SIGNATURES
1276+  1699             	; IN THEORY, THERE ARE SOME OTHER POSSIBLE VARIATIONS, BUT
1277+  1699             	; THEY ARE NOT RECOMMENDED BY THE CF CARD SPEC AND MIGHT
1278+  1699             	; OVERLAP WITH "REAL" HARD DISK SIGNATURES.  I HAVE NEVER
1279+  1699             	; SEEN A CF CARD THAT DID NOT USE ONE OF THE BELOW.
1280+  1699             	; CREDIT TO LASZLO SZOLNOKI
1281+  1699             ;
1282+  1699~            #IF (PPIDETRACE >= 3)
1283+  1699~            	CALL	PPIDE_PRTPREFIX
1284+  1699~            	PRTS(" SIG=0x$")
1284+  1699~            	PRTS(" SIG=0x$")
1285+  1699~            	LD	BC,(HB_WRKBUF)
1286+  1699~            	CALL	PRTHEXWORD
1287+  1699             #ENDIF
1288+  1699             ;
1289+  1699             ; SEE PAGE 114 OF CF+ & CF SPECIFICATION REV. 3.0 FOR CF CARD
1290+  1699             ; SIGNATURE VALUES.  ALL OF THE BELOW ARE DOCUMENTED THERE EXCEPT
1291+  1699             ; $045A WHICH IS A VALUE DISCOVERED ON A CF<->SD CARD ADAPTER.
1292+  1699             ;
1293+  1699             ; SIGNATURE $045A IS NOT LISTED IN THE CF SPEC.  IT WAS ADDED BECAUSE
1294+  1699             ; IT WAS SEEN IN THE WILD ON A CF-SD ADAPTER.  HOWEVER IT HAS NOW
1295+  1699             ; ALSO BEEN SEEN ON A SPINNING HARD DISK.  SINCE IT IS AMBIGUOUS, I
1296+  1699             ; WILL CONSIDER IT TO BE A HARD DISK.
1297+  1699             ;
1298+  1699 01 8A 84    	LD	BC,$848A		; STANDARD CF CARD SIGNATURE	%1000 1111 1000 1010
1299+  169C CD AD 16    	CALL	PPIDE_INITDEV000	; TEST & SET
1300+  169F 01 4A 04    	LD	BC,$044A		; ALT SIG FOR CF NON-REMOVABLE	%0000 0100 0100 1010
1301+  16A2 CD AD 16    	CALL	PPIDE_INITDEV000	; TEST & SET
1302+  16A5             	;LD	BC,$045A		; ?ALT SIG FOR CF NON-REMOVABLE	%0000 0100 0101 1010
1303+  16A5             	;CALL	PPIDE_INITDEV000	; TEST & SET
1304+  16A5 01 40 00    	LD	BC,$0040		; ALT SIG FOR CF NON-REMOVABLE	%0000 0000 0100 0000
1305+  16A8 CD AD 16    	CALL	PPIDE_INITDEV000	; TEST & SET
1306+  16AB 18 0C       	JR	PPIDE_INITDEV1		; CONTINUE INIT
1307+  16AD             ;
1308+  16AD             PPIDE_INITDEV000:
1309+  16AD             	; CHECK IF FIRST WORD OF IDENTIFY DATA MATCHES VALUE IN BC
1310+  16AD             	; AND SET CF FLAG IF SO
1311+  16AD 2A 5B 2A    	LD	HL,(HB_WRKBUF)		; FIRST WORD OF IDENTIFY DATA
1312+  16B0 B7          	OR	A			; CLEAR CARRY
1313+  16B1 ED 42       	SBC	HL,BC			; COMPARE
1314+  16B3 C0          	RET	NZ			; ABORT IF NOT EQUAL
1315+  16B4 FD CB 04 C6 	SET	0,(IY+PPIDE_MED)	; ELSE SET FLAGS BIT FOR CF MEDIA
1316+  16B8 C9          	RET				; AND RETURN
1317+  16B9             ;
1318+  16B9             PPIDE_INITDEV1:
1319+  16B9             	; DETERMINE IF LBA CAPABLE
1320+  16B9 3A BE 2A    	LD	A,(HB_WRKBUF+98+1)	; GET BYTE WITH LBA BIT FROM BUFFER
1321+  16BC CB 4F       	BIT	1,A			; CHECK THE LBA BIT
1322+  16BE 28 04       	JR	Z,PPIDE_INITDEV2	; NOT SET, BYPASS
1323+  16C0 FD CB 04 CE 	SET	1,(IY+PPIDE_MED)	; SET FLAGS BIT FOR LBA
1324+  16C4             ;
1325+  16C4             PPIDE_INITDEV2:
1326+  16C4             	; GET DEVICE CAPACITY AND SAVE IT
1327+  16C4 3E 05       	LD	A,PPIDE_MEDCAP		; OFFSET TO CAPACITY FIELD
1328+  16C6 CD 45 29    	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
1329+  16C9 E5          	PUSH	HL			; SAVE POINTER
1330+  16CA 21 5B 2A    	LD	HL,HB_WRKBUF		; POINT TO BUFFER START
1331+  16CD 3E 78       	LD	A,120			; OFFSET OF SECTOR COUNT
1332+  16CF CD D2 1A    	CALL	ADDHLA			; POINT TO ADDRESS OF SECTOR COUNT
1333+  16D2 CD AE 1C    	CALL	LD32			; LOAD IT TO DE:HL
1334+  16D5 C1          	POP	BC			; RECOVER POINTER TO CAPACITY ENTRY
1335+  16D6 CD BA 1C    	CALL	ST32			; SAVE CAPACITY
1336+  16D9             ;
1337+  16D9             	; RESET CARD STATUS TO 0 (OK)
1338+  16D9 AF          	XOR	A			; A := 0 (STATUS = OK)
1339+  16DA FD 77 01    	LD	(IY+PPIDE_STAT),A	; SAVE IT
1340+  16DD             ;
1341+  16DD C9          	RET				; RETURN, A=0, Z SET
1342+  16DE             ;
1343+  16DE             ; SWITCH IY POINTER FROM CURRENT UNIT CFG TO PARTNER UNIT CFG
1344+  16DE             ;
1345+  16DE             PPIDE_GOPARTNER:
1346+  16DE E5          	PUSH	HL			; SAVE HL
1347+  16DF FD 6E 10    	LD	L,(IY+PPIDE_PARTNER)	; GET PARTNER ENTRY
1348+  16E2 FD 66 11    	LD	H,(IY+PPIDE_PARTNER+1)	; ...
1349+  16E5 E5          	PUSH	HL			; MOVE HL
1350+  16E6 FD E1       	POP	IY			; ... TO IY
1351+  16E8 E1          	POP	HL			; RESTORE INCOMING HL
1352+  16E9 C9          	RET				; AND DONE
1353+  16EA             ;
1354+  16EA             ; CHECK CURRENT DEVICE FOR ERROR STATUS AND ATTEMPT TO RECOVER
1355+  16EA             ; VIA RESET IF DEVICE IS IN ERROR.
1356+  16EA             ;
1357+  16EA             PPIDE_CHKERR:
1358+  16EA FD 7E 01    	LD	A,(IY+PPIDE_STAT)	; GET STATUS
1359+  16ED B7          	OR	A			; SET FLAGS
1360+  16EE C4 B0 15    	CALL	NZ,PPIDE_RESET		; IF ERROR STATUS, RESET BUS
1361+  16F1 C9          	RET
1362+  16F2             ;
1363+  16F2             ;
1364+  16F2             ;
1365+  16F2             PPIDE_WAITRDY:
1366+  16F2 3A CD 18    	LD	A,(PPIDE_TIMEOUT)	; GET TIMEOUT IN 0.05 SECS
1367+  16F5 47          	LD	B,A			; PUT IN OUTER LOOP VAR
1368+  16F6             PPIDE_WAITRDY1:
1369+  16F6 ED 5B CE 18 	LD	DE,(PPIDE_TOSCALER)	; CPU SPEED SCALER TO INNER LOOP VAR
1370+  16FA             PPIDE_WAITRDY2:
1371+  16FA             	;IN	A,(PPIDE_REG_STAT)	; READ STATUS
1372+  16FA CD 44 17    	CALL	PPIDE_IN
1373+  16FD 0F          	.DB	PPIDE_REG_STAT
1374+  16FE 4F          	LD	C,A			; SAVE IT
1375+  16FF E6 C0       	AND	%11000000		; ISOLATE BUSY AND RDY BITS
1376+  1701 EE 40       	XOR	%01000000		; WE WANT BUSY(7) TO BE 0 AND RDY(6) TO BE 1
1377+  1703 C8          	RET	Z			; ALL SET, RETURN WITH Z SET
1378+  1704 1B          	DEC	DE
1379+  1705 7A          	LD	A,D
1380+  1706 B3          	OR	E
1381+  1707 20 F1       	JR	NZ,PPIDE_WAITRDY2	; INNER LOOP RETURN
1382+  1709 10 EB       	DJNZ	PPIDE_WAITRDY1		; OUTER LOOP RETURN
1383+  170B C3 94 17    	JP	PPIDE_RDYTO		; EXIT WITH RDYTO ERR
1384+  170E             ;
1385+  170E             ;
1386+  170E             ;
1387+  170E             PPIDE_WAITDRQ:
1388+  170E 3A CD 18    	LD	A,(PPIDE_TIMEOUT)	; GET TIMEOUT IN 0.05 SECS
1389+  1711 47          	LD	B,A			; PUT IN OUTER LOOP VAR
1390+  1712             PPIDE_WAITDRQ1:
1391+  1712 ED 5B CE 18 	LD	DE,(PPIDE_TOSCALER)	; CPU SPEED SCALER TO INNER LOOP VAR
1392+  1716             PPIDE_WAITDRQ2:
1393+  1716             	;IN	A,(PPIDE_REG_STAT)	; READ STATUS
1394+  1716 CD 44 17    	CALL	PPIDE_IN
1395+  1719 0F          	.DB	PPIDE_REG_STAT
1396+  171A 4F          	LD	C,A			; SAVE IT
1397+  171B E6 88       	AND	%10001000		; TO FILL (OR READY TO FILL)
1398+  171D EE 08       	XOR	%00001000
1399+  171F C8          	RET	Z
1400+  1720 1B          	DEC	DE
1401+  1721 7A          	LD	A,D
1402+  1722 B3          	OR	E
1403+  1723 20 F1       	JR	NZ,PPIDE_WAITDRQ2
1404+  1725 10 EB       	DJNZ	PPIDE_WAITDRQ1
1405+  1727 C3 98 17    	JP	PPIDE_DRQTO		; EXIT WITH BUFTO ERR
1406+  172A             ;
1407+  172A             ;
1408+  172A             ;
1409+  172A             PPIDE_WAITBSY:
1410+  172A 3A CD 18    	LD	A,(PPIDE_TIMEOUT)	; GET TIMEOUT IN 0.05 SECS
1411+  172D 47          	LD	B,A			; PUT IN OUTER LOOP VAR
1412+  172E             PPIDE_WAITBSY1:
1413+  172E ED 5B CE 18 	LD	DE,(PPIDE_TOSCALER)	; CPU SPEED SCALER TO INNER LOOP VAR
1414+  1732             PPIDE_WAITBSY2:
1415+  1732             	;IN	A,(PPIDE_REG_STAT)	; READ STATUS
1416+  1732 CD 44 17    	CALL	PPIDE_IN							; 17TS + 170TS
1417+  1735 0F          	.DB	PPIDE_REG_STAT							; 0TS
1418+  1736 4F          	LD	C,A			; SAVE IT				; 4TS
1419+  1737 E6 80       	AND	%10000000		; TO FILL (OR READY TO FILL)		; 7TS
1420+  1739 C8          	RET	Z								; 5TS
1421+  173A 1B          	DEC	DE								; 6TS
1422+  173B 7A          	LD	A,D								; 4TS
1423+  173C B3          	OR	E								; 4TS
1424+  173D 20 F3       	JR	NZ,PPIDE_WAITBSY2						; 12TS
1425+  173F 10 ED       	DJNZ	PPIDE_WAITBSY1							; -----
1426+  1741 C3 9C 17    	JP	PPIDE_BSYTO		; EXIT WITH BSYTO ERR			; 229TS
1427+  1744             ;
1428+  1744             ; READ A VALUE FROM THE DEVICE POINTED TO BY IY AND RETURN IT IN A
1429+  1744             ; 
1430+  1744             PPIDE_IN:
1431+  1744 E3          	EX	(SP),HL			; GET PARM POINTER			; 19TS
1432+  1745 C5          	PUSH	BC			; SAVE INCOMING BC			; 11TS
1433+  1746 3E 92       	LD	A,PPIDE_DIR_READ	; SET DATA BUS DIRECTION TO READ	; 7TS
1434+  1748             	;OUT	(PPIDE_IO_PPI),A	; DO IT					; 11TS
1435+  1748 FD 4E 0F    	LD	C,(IY+PPIDE_PPI)	; PPI CONTROL WORD
1436+  174B ED 79       	OUT	(C),A			; WRITE IT
1437+  174D             ;
1438+  174D 46          	LD	B,(HL)			; GET CTL PORT VALUE			; 7TS
1439+  174E             	;LD	C,PPIDE_IO_CTL		; SETUP PORT TO WRITE			; 7TS
1440+  174E             	;LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
1441+  174E 0D          	DEC	C			; SET IDE ADDRESS
1442+  174F ED 41       	OUT	(C),B			; SET ADDRESS LINES			; 12TS
1443+  1751 CB F0       	SET	6,B			; TURN ON READ BIT			; 8TS
1444+  1753 ED 41       	OUT	(C),B			; ASSERT READ LINE			; 12TS
1445+  1755             ;
1446+  1755             	;IN	A,(PPIDE_IO_DATALO)	; GET DATA VALUE FROM DEVICE		; 11TS
1447+  1755 0D          	DEC	C
1448+  1756 0D          	DEC	C
1449+  1757 ED 78       	IN	A,(C)			; GET DATA VALUE FROM DEVICE
1450+  1759 0C          	INC	C
1451+  175A 0C          	INC	C
1452+  175B             ;
1453+  175B CB B0       	RES	6,B			; CLEAR READ BIT			; 8TS
1454+  175D ED 41       	OUT	(C),B			; DEASSERT READ LINE			; 12TS
1455+  175F C1          	POP	BC			; RECOVER INCOMING BC			; 10TS
1456+  1760 23          	INC	HL			; POINT PAST PARM			; 6TS
1457+  1761 E3          	EX	(SP),HL			; RESTORE STACK				; 19TS
1458+  1762 C9          	RET									; 10TS
1459+  1763             ;
1460+  1763             ; OUTPUT VALUE IN A TO THE DEVICE POINTED TO BY IY
1461+  1763             ; 
1462+  1763             PPIDE_OUT:
1463+  1763             	; *** TODO *** FIX ORDER OF SET/CLEAR WRITE LINE
1464+  1763 E3          	EX	(SP),HL			; GET PARM POINTER
1465+  1764 C5          	PUSH	BC			; SAVE INCOMING BC
1466+  1765 F5          	PUSH	AF			; PRESERVE INCOMING VALUE
1467+  1766 3E 80       	LD	A,PPIDE_DIR_WRITE	; SET DATA BUS DIRECTION TO WRITE
1468+  1768             	;OUT	(PPIDE_IO_PPI),A	; DO IT
1469+  1768 FD 4E 0F    	LD	C,(IY+PPIDE_PPI)	; PPI CONTROL WORD
1470+  176B ED 79       	OUT	(C),A			; WRITE IT
1471+  176D F1          	POP	AF			; RECOVER VALUE TO WRITE
1472+  176E             ;
1473+  176E 46          	LD	B,(HL)			; GET IDE ADDRESS VALUE
1474+  176F             	;LD	C,PPIDE_IO_CTL		; SETUP PORT TO WRITE
1475+  176F             	;LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
1476+  176F 0D          	DEC	C			; SET IDE ADDRESS
1477+  1770 ED 41       	OUT	(C),B			; SET ADDRESS LINES
1478+  1772 CB E8       	SET	5,B			; TURN ON WRITE BIT
1479+  1774 ED 41       	OUT	(C),B			; ASSERT WRITE LINE
1480+  1776             ;
1481+  1776 0D          	DEC	C
1482+  1777 0D          	DEC	C
1483+  1778             	;OUT	(PPIDE_IO_DATALO),A	; SEND DATA VALUE TO DEVICE
1484+  1778 ED 79       	OUT	(C),A			; SEND DATA VALUE TO DEVICE
1485+  177A 0C          	INC	C
1486+  177B 0C          	INC	C
1487+  177C             ;
1488+  177C CB A8       	RES	5,B			; CLEAR WRITE BIT
1489+  177E ED 41       	OUT	(C),B			; DEASSERT WRITE LINE
1490+  1780 C1          	POP	BC			; RECOVER INCOMING BC
1491+  1781 23          	INC	HL			; POINT PAST PARM
1492+  1782 E3          	EX	(SP),HL			; RESTORE STACK
1493+  1783 C9          	RET
1494+  1784             ;
1495+  1784             ;=============================================================================
1496+  1784             ; ERROR HANDLING AND DIAGNOSTICS
1497+  1784             ;=============================================================================
1498+  1784             ;
1499+  1784             ; ERROR HANDLERS
1500+  1784             ;
1501+  1784             PPIDE_INVUNIT:
1502+  1784 3E FF       	LD	A,PPIDE_STINVUNIT
1503+  1786 18 1B       	JR	PPIDE_ERR2		; SPECIAL CASE FOR INVALID UNIT
1504+  1788             ;
1505+  1788             PPIDE_NOMEDIA:
1506+  1788 3E FE       	LD	A,PPIDE_STNOMEDIA
1507+  178A 18 14       	JR	PPIDE_ERR
1508+  178C             ;
1509+  178C             PPIDE_CMDERR:
1510+  178C 3E FD       	LD	A,PPIDE_STCMDERR
1511+  178E 18 10       	JR	PPIDE_ERR
1512+  1790             ;
1513+  1790             PPIDE_IOERR:
1514+  1790 3E FC       	LD	A,PPIDE_STIOERR
1515+  1792 18 0C       	JR	PPIDE_ERR
1516+  1794             ;
1517+  1794             PPIDE_RDYTO:
1518+  1794 3E FB       	LD	A,PPIDE_STRDYTO
1519+  1796 18 08       	JR	PPIDE_ERR
1520+  1798             ;
1521+  1798             PPIDE_DRQTO:
1522+  1798 3E FA       	LD	A,PPIDE_STDRQTO
1523+  179A 18 04       	JR	PPIDE_ERR
1524+  179C             ;
1525+  179C             PPIDE_BSYTO:
1526+  179C 3E F9       	LD	A,PPIDE_STBSYTO
1527+  179E 18 00       	JR	PPIDE_ERR
1528+  17A0             ;
1529+  17A0             PPIDE_ERR:
1530+  17A0 FD 77 01    	LD	(IY+PPIDE_STAT),A	; SAVE NEW STATUS
1531+  17A3             ;
1532+  17A3             PPIDE_ERR2:
1533+  17A3~            #IF (PPIDETRACE >= 2)
1534+  17A3~            	CALL	PPIDE_PRTSTAT
1535+  17A3~            	CALL	PPIDE_REGDUMP
1536+  17A3             #ENDIF
1537+  17A3 B7          	OR	A			; SET FLAGS
1538+  17A4 C9          	RET
1539+  17A5             ;
1540+  17A5             ;
1541+  17A5             ;
1542+  17A5             PPIDE_PRTERR:
1543+  17A5 C8          	RET	Z			; DONE IF NO ERRORS
1544+  17A6             	; FALL THRU TO PPIDE_PRTSTAT
1545+  17A6             ;
1546+  17A6             ; PRINT STATUS STRING (STATUS NUM IN A)
1547+  17A6             ;
1548+  17A6             PPIDE_PRTSTAT:
1549+  17A6 F5          	PUSH	AF
1550+  17A7 D5          	PUSH	DE
1551+  17A8 E5          	PUSH	HL
1552+  17A9 FD 7E 01    	LD	A,(IY+PPIDE_STAT)
1553+  17AC B7          	OR	A
1554+  17AD 11 4E 18    	LD	DE,PPIDE_STR_STOK
1555+  17B0 28 2D       	JR	Z,PPIDE_PRTSTAT1
1556+  17B2 3C          	INC	A
1557+  17B3 11 51 18    	LD	DE,PPIDE_STR_STINVUNIT
1558+  17B6 28 2C       	JR	Z,PPIDE_PRTSTAT2	; INVALID UNIT IS SPECIAL CASE
1559+  17B8 3C          	INC	A
1560+  17B9 11 5E 18    	LD	DE,PPIDE_STR_STNOMEDIA
1561+  17BC 28 21       	JR	Z,PPIDE_PRTSTAT1
1562+  17BE 3C          	INC	A
1563+  17BF 11 67 18    	LD	DE,PPIDE_STR_STCMDERR
1564+  17C2 28 1B       	JR	Z,PPIDE_PRTSTAT1
1565+  17C4 3C          	INC	A
1566+  17C5 11 75 18    	LD	DE,PPIDE_STR_STIOERR
1567+  17C8 28 15       	JR	Z,PPIDE_PRTSTAT1
1568+  17CA 3C          	INC	A
1569+  17CB 11 7E 18    	LD	DE,PPIDE_STR_STRDYTO
1570+  17CE 28 0F       	JR	Z,PPIDE_PRTSTAT1
1571+  17D0 3C          	INC	A
1572+  17D1 11 8C 18    	LD	DE,PPIDE_STR_STDRQTO
1573+  17D4 28 09       	JR	Z,PPIDE_PRTSTAT1
1574+  17D6 3C          	INC	A
1575+  17D7 11 98 18    	LD	DE,PPIDE_STR_STBSYTO
1576+  17DA 28 03       	JR	Z,PPIDE_PRTSTAT1
1577+  17DC 11 A5 18    	LD	DE,PPIDE_STR_STUNK
1578+  17DF             PPIDE_PRTSTAT1:
1579+  17DF CD 32 18    	CALL	PPIDE_PRTPREFIX		; PRINT UNIT PREFIX
1580+  17E2 18 0D       	JR	PPIDE_PRTSTAT3
1581+  17E4             PPIDE_PRTSTAT2:
1582+  17E4 CD 20 19    	CALL	NEWLINE
1583+  17E7 CD 3B 19    	PRTS("PPIDE:$")			; NO UNIT NUM IN PREFIX FOR INVALID UNIT
1583+  17EA 50 50 49 44 
1583+  17EE 45 3A 24 
1584+  17F1             PPIDE_PRTSTAT3:
1585+  17F1 CD D7 18    	CALL	PC_SPACE		; FORMATTING
1586+  17F4 CD 12 1A    	CALL	WRITESTR
1587+  17F7 E1          	POP	HL
1588+  17F8 D1          	POP	DE
1589+  17F9 F1          	POP	AF
1590+  17FA C9          	RET
1591+  17FB             ;
1592+  17FB             ; PRINT ALL REGISTERS DIRECTLY FROM DEVICE
1593+  17FB             ; DEVICE MUST BE SELECTED PRIOR TO CALL
1594+  17FB             ;
1595+  17FB             PPIDE_REGDUMP:
1596+  17FB F5          	PUSH	AF
1597+  17FC C5          	PUSH	BC
1598+  17FD D5          	push	DE
1599+  17FE CD D7 18    	CALL	PC_SPACE
1600+  1801 CD EB 18    	CALL	PC_LBKT
1601+  1804 3E 92       	LD	A,PPIDE_DIR_READ	; SET DATA BUS DIRECTION TO READ
1602+  1806             	;OUT	(PPIDE_IO_PPI),A	; DO IT
1603+  1806 FD 4E 0F    	LD	C,(IY+PPIDE_PPI)	; PPI CONTROL WORD
1604+  1809 ED 79       	OUT	(C),A			; WRITE IT
1605+  180B FD 4E 0E    	LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
1606+  180E 1E 0F       	LD	E,PPIDE_REG_CMD
1607+  1810 06 07       	LD	B,7
1608+  1812             PPIDE_REGDUMP1:
1609+  1812 7B          	LD	A,E			; REGISTER ADDRESS
1610+  1813             	;OUT	(PPIDE_IO_CTL),A	; SET IT
1611+  1813 ED 79       	OUT	(C),A			; REGISTER ADDRESS
1612+  1815 EE 40       	XOR	PPIDE_CTL_DIOR		; SET BIT TO ASSERT READ LINE
1613+  1817             	;OUT	(PPIDE_IO_CTL),A	; ASSERT READ
1614+  1817 ED 79       	OUT	(C),A			; ASSERT READ
1615+  1819             	;IN	A,(PPIDE_IO_DATALO)	; GET VALUE
1616+  1819 0D          	DEC	C			; CTL -> MSB
1617+  181A 0D          	DEC	C			; MSB -> LSB
1618+  181B ED 78       	IN	A,(C)			; GET VALUE
1619+  181D 0C          	INC	C			; LSB -> MSB
1620+  181E 0C          	INC	C			; MSB -> CTL
1621+  181F CD 52 19    	CALL	PRTHEXBYTE		; DISPLAY IT
1622+  1822             	;LD	A,C			; RELOAD ADDRESS W/ READ UNASSERTED
1623+  1822             	;OUT	(PPIDE_IO_CTL),A	; AND SET IT
1624+  1822 ED 59       	OUT	(C),E			; RELOAD ADDRESS W/ READ UNASSERTED
1625+  1824             	;DEC	C			; NEXT LOWER REGISTER
1626+  1824 1D          	DEC	E			; NEXT LOWER REGISTER
1627+  1825 05          	DEC	B			; DEC LOOP COUNTER
1628+  1826 C4 D7 18    	CALL	NZ,PC_SPACE		; FORMATTING
1629+  1829 20 E7       	JR	NZ,PPIDE_REGDUMP1	; LOOP AS NEEDED
1630+  182B CD F0 18    	CALL	PC_RBKT			; FORMATTING
1631+  182E D1          	POP	DE
1632+  182F C1          	POP	BC
1633+  1830 F1          	POP	AF
1634+  1831 C9          	RET
1635+  1832             ;
1636+  1832             ; PRINT DIAGNONSTIC PREFIX
1637+  1832             ;
1638+  1832             PPIDE_PRTPREFIX:
1639+  1832 F5          	PUSH	AF
1640+  1833 CD 20 19    	CALL	NEWLINE
1641+  1836 CD 3B 19    	PRTS("PPIDE$")
1641+  1839 50 50 49 44 
1641+  183D 45 24 
1642+  183F FD 7E 00    	LD	A,(IY+PPIDE_DEV)	; GET CURRENT DEVICE NUM
1643+  1842 FE FE       	CP	$FE			; NOT YET ASSIGNED?
1644+  1844 28 03       	JR	Z,PPIDE_PRTPREFIX1	; SKIP DEV NUM IF SO
1645+  1846 CD B2 1B    	CALL	PRTDECB
1646+  1849             PPIDE_PRTPREFIX1:
1647+  1849 CD E1 18    	CALL	PC_COLON
1648+  184C F1          	POP	AF
1649+  184D C9          	RET
1650+  184E             ;;;
1651+  184E             ;;;
1652+  184E             ;;;
1653+  184E             ;;#IF (DSKYENABLE)
1654+  184E             ;;PPIDE_DSKY:
1655+  184E             ;;	LD	HL,DSKY_HEXBUF		; POINT TO DSKY BUFFER
1656+  184E             ;;	CALL	PPIDE_IN
1657+  184E             ;;	.DB	PPIDE_REG_DRVHD
1658+  184E             ;;	LD	(HL),A			; SAVE IN BUFFER
1659+  184E             ;;	INC	HL			; INCREMENT BUFFER POINTER
1660+  184E             ;;	CALL	PPIDE_IN
1661+  184E             ;;	.DB	PPIDE_REG_CYLHI
1662+  184E             ;;	LD	(HL),A			; SAVE IN BUFFER
1663+  184E             ;;	INC	HL			; INCREMENT BUFFER POINTER
1664+  184E             ;;	CALL	PPIDE_IN
1665+  184E             ;;	.DB	PPIDE_REG_CYLLO
1666+  184E             ;;	LD	(HL),A			; SAVE IN BUFFER
1667+  184E             ;;	INC	HL			; INCREMENT BUFFER POINTER
1668+  184E             ;;	CALL	PPIDE_IN
1669+  184E             ;;	.DB	PPIDE_REG_SECT
1670+  184E             ;;	LD	(HL),A			; SAVE IN BUFFER
1671+  184E             ;;	CALL	DSKY_HEXOUT		; SEND IT TO DSKY
1672+  184E             ;;	RET
1673+  184E             ;;#ENDIF
1674+  184E             ;
1675+  184E             ;=============================================================================
1676+  184E             ; STRING DATA
1677+  184E             ;=============================================================================
1678+  184E             ;
1679+  184E 4F 4B 24    PPIDE_STR_STOK		.TEXT	"OK$"
1680+  1851 49 4E 56 41 PPIDE_STR_STINVUNIT	.TEXT	"INVALID UNIT$"
1680+  1855 4C 49 44 20 
1680+  1859 55 4E 49 54 
1680+  185D 24 
1681+  185E 4E 4F 20 4D PPIDE_STR_STNOMEDIA	.TEXT	"NO MEDIA$"
1681+  1862 45 44 49 41 
1681+  1866 24 
1682+  1867 43 4F 4D 4D PPIDE_STR_STCMDERR	.TEXT	"COMMAND ERROR$"
1682+  186B 41 4E 44 20 
1682+  186F 45 52 52 4F 
1682+  1873 52 24 
1683+  1875 49 4F 20 45 PPIDE_STR_STIOERR	.TEXT	"IO ERROR$"
1683+  1879 52 52 4F 52 
1683+  187D 24 
1684+  187E 52 45 41 44 PPIDE_STR_STRDYTO	.TEXT	"READY TIMEOUT$"
1684+  1882 59 20 54 49 
1684+  1886 4D 45 4F 55 
1684+  188A 54 24 
1685+  188C 44 52 51 20 PPIDE_STR_STDRQTO	.TEXT	"DRQ TIMEOUT$"
1685+  1890 54 49 4D 45 
1685+  1894 4F 55 54 24 
1686+  1898 42 55 53 59 PPIDE_STR_STBSYTO	.TEXT	"BUSY TIMEOUT$"
1686+  189C 20 54 49 4D 
1686+  18A0 45 4F 55 54 
1686+  18A4 24 
1687+  18A5 55 4E 4B 4E PPIDE_STR_STUNK		.TEXT	"UNKNOWN ERROR$"
1687+  18A9 4F 57 4E 20 
1687+  18AD 45 52 52 4F 
1687+  18B1 52 24 
1688+  18B3             ;
1689+  18B3 4E 4F 24    PPIDE_STR_NO		.TEXT	"NO$"
1690+  18B6 50 50 49 20 PPIDE_STR_NOPPI		.TEXT	"PPI NOT PRESENT$"
1690+  18BA 4E 4F 54 20 
1690+  18BE 50 52 45 53 
1690+  18C2 45 4E 54 24 
1691+  18C6 20 38 2D 42 PPIDE_STR_8BIT		.TEXT	" 8-BIT$"
1691+  18CA 49 54 24 
1692+  18CD             ;
1693+  18CD             ;=============================================================================
1694+  18CD             ; DATA STORAGE
1695+  18CD             ;=============================================================================
1696+  18CD             ;
1697+  18CD C8          PPIDE_TIMEOUT	.DB	PPIDE_TONORM	; WAIT FUNCS TIMEOUT IN TENTHS OF SEC
1698+  18CE A0 0D       PPIDE_TOSCALER	.DW	CPUMHZ * 218	; WAIT FUNCS SCALER FOR CPU SPEED
1699+  18D0             ;
1700+  18D0 00          PPIDE_CMD	.DB	0		; PENDING COMMAND TO PROCESS
1701+  18D1 00 00       PPIDE_IOFNADR	.DW	0		; PENDING IO FUNCTION ADDRESS
1702+  18D3 00          PPIDE_DRVHD	.DB	0		; CURRENT DRIVE/HEAD MASK
1703+  18D4             ;
1704+  18D4 00 00       PPIDE_DSKBUF	.DW	0		; ACTIVE DISK BUFFER
1705+  18D6             ;
1706+  18D6 00          PPIDE_DEVNUM	.DB	0		; TEMP DEVICE NUM USED DURING INIT
6199   18D7             SIZ_PPIDE	.EQU	$ - ORG_PPIDE
6200   18D7             		.ECHO	"PPIDE occupies "
6201   18D7             		.ECHO	SIZ_PPIDE
6202   18D7             		.ECHO	" bytes.\n"
6203   18D7             #ENDIF
6204   18D7             ;
6205   18D7~            #IF (SDENABLE)
6206   18D7~            ORG_SD		.EQU	$
6207   18D7~              #INCLUDE "sd.asm"
6208   18D7~            SIZ_SD		.EQU	$ - ORG_SD
6209   18D7~            		.ECHO	"SD occupies "
6210   18D7~            		.ECHO	SIZ_SD
6211   18D7~            		.ECHO	" bytes.\n"
6212   18D7             #ENDIF
6213   18D7             ;
6214   18D7~            #IF (HDSKENABLE)
6215   18D7~            ORG_HDSK	.EQU	$
6216   18D7~              #INCLUDE "hdsk.asm"
6217   18D7~            SIZ_HDSK	.EQU	$ - ORG_HDSK
6218   18D7~            		.ECHO	"HDSK occupies "
6219   18D7~            		.ECHO	SIZ_HDSK
6220   18D7~            		.ECHO	" bytes.\n"
6221   18D7             #ENDIF
6222   18D7             ;
6223   18D7~            #IF (TERMENABLE)
6224   18D7~            ORG_TERM	.EQU	$
6225   18D7~              #INCLUDE "term.asm"
6226   18D7~            SIZ_TERM	.EQU	$ - ORG_TERM
6227   18D7~            		.ECHO	"TERM occupies "
6228   18D7~            		.ECHO	SIZ_TERM
6229   18D7~            		.ECHO	" bytes.\n"
6230   18D7             #ENDIF
6231   18D7             ;
6232   18D7             ;#IF (SPKENABLE & DSRTCENABLE)
6233   18D7~            #IF (SPKENABLE)
6234   18D7~            ORG_SPK	.EQU	$
6235   18D7~              #INCLUDE "spk.asm"
6236   18D7~            SIZ_SPK	.EQU	$ - ORG_SPK
6237   18D7~            		.ECHO	"SPK occupies "
6238   18D7~            		.ECHO	SIZ_SPK
6239   18D7~            		.ECHO	" bytes.\n"
6240   18D7             #ENDIF
6241   18D7~            #IF (KIOENABLE)
6242   18D7~            ORG_KIO	.EQU	$
6243   18D7~              #INCLUDE "kio.asm"
6244   18D7~            SIZ_KIO	.EQU	$ - ORG_KIO
6245   18D7~            		.ECHO	"KIO occupies "
6246   18D7~            		.ECHO	SIZ_KIO
6247   18D7~            		.ECHO	" bytes.\n"
6248   18D7             #ENDIF
6249   18D7~            #IF (CTCENABLE)
6250   18D7~            ORG_CTC	.EQU	$
6251   18D7~              #INCLUDE "ctc.asm"
6252   18D7~            SIZ_CTC	.EQU	$ - ORG_CTC
6253   18D7~            		.ECHO	"CTC occupies "
6254   18D7~            		.ECHO	SIZ_CTC
6255   18D7~            		.ECHO	" bytes.\n"
6256   18D7             #ENDIF
6257   18D7~            #IF (SN76489ENABLE)
6258   18D7~            ORG_SN76489	.EQU	$
6259   18D7~              #INCLUDE "sn76489.asm"
6260   18D7~            SIZ_SN76489	.EQU	$ - ORG_SN76489
6261   18D7~            		.ECHO	"SN76489 occupies "
6262   18D7~            		.ECHO	SIZ_SN76489
6263   18D7~            		.ECHO	" bytes.\n"
6264   18D7             #ENDIF
6265   18D7~            #IF (AY38910ENABLE)
6266   18D7~            ORG_AY38910	.EQU	$
6267   18D7~              #INCLUDE "ay38910.asm"
6268   18D7~            SIZ_AY38910	.EQU	$ - ORG_AY38910
6269   18D7~            		.ECHO	"AY38910 occupies "
6270   18D7~            		.ECHO	SIZ_AY38910
6271   18D7~            		.ECHO	" bytes.\n"
6272   18D7             #ENDIF
6273   18D7~            #IF (YM2612ENABLE)
6274   18D7~            ORG_YM2612	.EQU	$
6275   18D7~              #INCLUDE "ym2612.asm"
6276   18D7~            SIZ_YM2612	.EQU	$ - ORG_YM2612
6277   18D7~            		.ECHO	"YM2612 occupies "
6278   18D7~            		.ECHO	SIZ_YM2612
6279   18D7~            		.ECHO	" bytes.\n"
6280   18D7             #ENDIF
6281   18D7             ;
6282   18D7             		.ECHO	"RTCDEF="
6283   18D7             		.ECHO	RTCDEF
6284   18D7             		.ECHO	"\n"
6285   18D7             ;
6286   18D7             #DEFINE USEDELAY
6287   18D7             #INCLUDE "util.asm"
0001+  18D7             ;
0002+  18D7             ;==================================================================================================
0003+  18D7             ; UTILITY FUNCTIONS
0004+  18D7             ;==================================================================================================
0005+  18D7             ;
0006+  18D7             ;
0007+  18D7             CHR_BEL		.EQU	07H
0008+  18D7             CHR_CR		.EQU	0DH
0009+  18D7             CHR_LF		.EQU	0AH
0010+  18D7             CHR_BS		.EQU	08H
0011+  18D7             CHR_ESC		.EQU	1BH
0012+  18D7             ;
0013+  18D7             ;__________________________________________________________________________________________________
0014+  18D7             ;
0015+  18D7             ; UTILITY PROCS TO PRINT SINGLE CHARACTERS WITHOUT TRASHING ANY REGISTERS
0016+  18D7             ;
0017+  18D7             PC_SPACE:
0018+  18D7 F5          	PUSH	AF
0019+  18D8 3E 20       	LD	A,' '
0020+  18DA 18 3C       	JR	PC_PRTCHR
0021+  18DC             
0022+  18DC             PC_PERIOD:
0023+  18DC F5          	PUSH	AF
0024+  18DD 3E 2E       	LD	A,'.'
0025+  18DF 18 37       	JR	PC_PRTCHR
0026+  18E1             
0027+  18E1             PC_COLON:
0028+  18E1 F5          	PUSH	AF
0029+  18E2 3E 3A       	LD	A,':'
0030+  18E4 18 32       	JR	PC_PRTCHR
0031+  18E6             
0032+  18E6             PC_COMMA:
0033+  18E6 F5          	PUSH	AF
0034+  18E7 3E 2C       	LD	A,','
0035+  18E9 18 2D       	JR	PC_PRTCHR
0036+  18EB             
0037+  18EB             PC_LBKT:
0038+  18EB F5          	PUSH	AF
0039+  18EC 3E 5B       	LD	A,'['
0040+  18EE 18 28       	JR	PC_PRTCHR
0041+  18F0             
0042+  18F0             PC_RBKT:
0043+  18F0 F5          	PUSH	AF
0044+  18F1 3E 5D       	LD	A,']'
0045+  18F3 18 23       	JR	PC_PRTCHR
0046+  18F5             
0047+  18F5             PC_LT:
0048+  18F5 F5          	PUSH	AF
0049+  18F6 3E 3C       	LD	A,'<'
0050+  18F8 18 1E       	JR	PC_PRTCHR
0051+  18FA             
0052+  18FA             PC_GT:
0053+  18FA F5          	PUSH	AF
0054+  18FB 3E 3E       	LD	A,'>'
0055+  18FD 18 19       	JR	PC_PRTCHR
0056+  18FF             
0057+  18FF             PC_LPAREN:
0058+  18FF F5          	PUSH	AF
0059+  1900 3E 28       	LD	A,'('
0060+  1902 18 14       	JR	PC_PRTCHR
0061+  1904             
0062+  1904             PC_RPAREN:
0063+  1904 F5          	PUSH	AF
0064+  1905 3E 29       	LD	A,')'
0065+  1907 18 0F       	JR	PC_PRTCHR
0066+  1909             
0067+  1909             PC_ASTERISK:
0068+  1909 F5          	PUSH	AF
0069+  190A 3E 2A       	LD	A,'*'
0070+  190C 18 0A       	JR	PC_PRTCHR
0071+  190E             
0072+  190E             PC_CR:
0073+  190E F5          	PUSH	AF
0074+  190F 3E 0D       	LD	A,CHR_CR
0075+  1911 18 05       	JR	PC_PRTCHR
0076+  1913             
0077+  1913             PC_LF:
0078+  1913 F5          	PUSH	AF
0079+  1914 3E 0A       	LD	A,CHR_LF
0080+  1916 18 00       	JR	PC_PRTCHR
0081+  1918             
0082+  1918             PC_PRTCHR:
0083+  1918 CD FF 28    	CALL	COUT
0084+  191B F1          	POP	AF
0085+  191C C9          	RET
0086+  191D             
0087+  191D             NEWLINE2:
0088+  191D CD 20 19    	CALL	NEWLINE
0089+  1920             NEWLINE:
0090+  1920 CD 0E 19    	CALL	PC_CR
0091+  1923 CD 13 19    	CALL	PC_LF
0092+  1926 C9          	RET
0093+  1927             ;
0094+  1927             ; PRINT A CHARACTER REFERENCED BY POINTER AT TOP OF STACK
0095+  1927             ; USAGE:
0096+  1927             ;   CALL PRTCH
0097+  1927             ;   .DB  'X'
0098+  1927             ;
0099+  1927             PRTCH:
0100+  1927 E3          	EX	(SP),HL
0101+  1928 F5          	PUSH	AF
0102+  1929 7E          	LD	A,(HL)
0103+  192A CD FF 28    	CALL	COUT
0104+  192D F1          	POP	AF
0105+  192E 23          	INC	HL
0106+  192F E3          	EX	(SP),HL
0107+  1930 C9          	RET
0108+  1931             ;
0109+  1931             ; PRINT A STRING AT ADDRESS SPECIFIED IN HL
0110+  1931             ; STRING MUST BE TERMINATED BY '$'
0111+  1931             ; USAGE:
0112+  1931             ;   LD	HL,MYSTR
0113+  1931             ;   CALL PRTSTR
0114+  1931             ;   ...
0115+  1931             ;   MYSTR: .DB  "HELLO$"
0116+  1931             ;
0117+  1931             PRTSTR:
0118+  1931 7E          	LD	A,(HL)
0119+  1932 23          	INC	HL
0120+  1933 FE 24       	CP	'$'
0121+  1935 C8          	RET	Z
0122+  1936 CD FF 28    	CALL	COUT
0123+  1939 18 F6       	JR	PRTSTR
0124+  193B             ;
0125+  193B             ; PRINT A STRING DIRECT: REFERENCED BY POINTER AT TOP OF STACK
0126+  193B             ; STRING MUST BE TERMINATED BY '$'
0127+  193B             ; USAGE:
0128+  193B             ;   CALL PRTSTRD
0129+  193B             ;   .DB  "HELLO$"
0130+  193B             ;   ...
0131+  193B             ;
0132+  193B             PRTSTRD:
0133+  193B E3          	EX	(SP),HL
0134+  193C F5          	PUSH	AF
0135+  193D CD 31 19    	CALL	PRTSTR
0136+  1940 F1          	POP	AF
0137+  1941 E3          	EX	(SP),HL
0138+  1942 C9          	RET
0139+  1943             ;
0140+  1943             ; PRINT A STRING INDIRECT: REFERENCED BY INDIRECT POINTER AT TOP OF STACK
0141+  1943             ; STRING MUST BE TERMINATED BY '$'
0142+  1943             ; USAGE:
0143+  1943             ;   MYSTRING	.DB	"HELLO$"
0144+  1943             ;   CALL PRTSTRI(MYSTRING)
0145+  1943             ;		.DW	MYSTRING
0146+  1943             ;
0147+  1943             PRTSTRI:
0148+  1943 E3          	EX	(SP),HL
0149+  1944 F5          	PUSH	AF
0150+  1945 7E          	LD	A,(HL)
0151+  1946 23          	INC	HL
0152+  1947 E5          	PUSH	HL
0153+  1948 66          	LD	H,(HL)
0154+  1949 6F          	LD	L,A
0155+  194A CD 31 19    	CALL	PRTSTR
0156+  194D E1          	POP	HL
0157+  194E 23          	INC	HL
0158+  194F F1          	POP	AF
0159+  1950 E3          	EX	(SP),HL
0160+  1951 C9          	RET
0161+  1952             ;
0162+  1952             ; PRINT THE HEX BYTE VALUE IN A
0163+  1952             ;
0164+  1952             PRTHEXBYTE:
0165+  1952 F5          	PUSH	AF
0166+  1953 D5          	PUSH	DE
0167+  1954 CD 85 19    	CALL	HEXASCII
0168+  1957 7A          	LD	A,D
0169+  1958 CD FF 28    	CALL	COUT
0170+  195B 7B          	LD	A,E
0171+  195C CD FF 28    	CALL	COUT
0172+  195F D1          	POP	DE
0173+  1960 F1          	POP	AF
0174+  1961 C9          	RET
0175+  1962             ;
0176+  1962             ; PRINT THE HEX WORD VALUE IN BC
0177+  1962             ;
0178+  1962             PRTHEXWORD:
0179+  1962 F5          	PUSH	AF
0180+  1963 78          	LD	A,B
0181+  1964 CD 52 19    	CALL	PRTHEXBYTE
0182+  1967 79          	LD	A,C
0183+  1968 CD 52 19    	CALL	PRTHEXBYTE
0184+  196B F1          	POP	AF
0185+  196C C9          	RET
0186+  196D             ;
0187+  196D             ; PRINT THE HEX WORD VALUE IN HL
0188+  196D             ;
0189+  196D             PRTHEXWORDHL:
0190+  196D F5          	PUSH	AF
0191+  196E 7C          	LD	A,H
0192+  196F CD 52 19    	CALL	PRTHEXBYTE
0193+  1972 7D          	LD	A,L
0194+  1973 CD 52 19    	CALL	PRTHEXBYTE
0195+  1976 F1          	POP	AF
0196+  1977 C9          	RET
0197+  1978             ;
0198+  1978             ; PRINT THE HEX DWORD VALUE IN DE:HL
0199+  1978             ;
0200+  1978             PRTHEX32:
0201+  1978 C5          	PUSH	BC
0202+  1979 D5          	PUSH	DE
0203+  197A C1          	POP	BC
0204+  197B CD 62 19    	CALL	PRTHEXWORD
0205+  197E E5          	PUSH	HL
0206+  197F C1          	POP	BC
0207+  1980 CD 62 19    	CALL	PRTHEXWORD
0208+  1983 C1          	POP	BC
0209+  1984 C9          	RET
0210+  1985             ;
0211+  1985             ; CONVERT BINARY VALUE IN A TO ASCII HEX CHARACTERS IN DE
0212+  1985             ;
0213+  1985             HEXASCII:
0214+  1985 57          	LD	D,A
0215+  1986 CD 94 19    	CALL	HEXCONV
0216+  1989 5F          	LD	E,A
0217+  198A 7A          	LD	A,D
0218+  198B 07          	RLCA
0219+  198C 07          	RLCA
0220+  198D 07          	RLCA
0221+  198E 07          	RLCA
0222+  198F CD 94 19    	CALL	HEXCONV
0223+  1992 57          	LD	D,A
0224+  1993 C9          	RET
0225+  1994             ;
0226+  1994             ; CONVERT LOW NIBBLE OF A TO ASCII HEX
0227+  1994             ;
0228+  1994             HEXCONV:
0229+  1994 E6 0F       	AND	0FH	     ;LOW NIBBLE ONLY
0230+  1996 C6 90       	ADD	A,90H
0231+  1998 27          	DAA
0232+  1999 CE 40       	ADC	A,40H
0233+  199B 27          	DAA
0234+  199C C9          	RET
0235+  199D             ;
0236+  199D             ; PRINT A BYTE BUFFER IN HEX POINTED TO BY DE
0237+  199D             ; REGISTER A HAS SIZE OF BUFFER
0238+  199D             ;
0239+  199D             PRTHEXBUF:
0240+  199D B7          	OR	A
0241+  199E C8          	RET	Z		; EMPTY BUFFER
0242+  199F             ;
0243+  199F 47          	LD	B,A
0244+  19A0             PRTHEXBUF1:
0245+  19A0 CD D7 18    	CALL	PC_SPACE
0246+  19A3 1A          	LD	A,(DE)
0247+  19A4 CD 52 19    	CALL	PRTHEXBYTE
0248+  19A7 13          	INC	DE
0249+  19A8 10 F6       	DJNZ	PRTHEXBUF1
0250+  19AA C9          	RET
0251+  19AB             ;
0252+  19AB             ; PRINT A BLOCK OF MEMORY NICELY FORMATTED
0253+  19AB             ;  DE=BUFFER ADDRESS
0254+  19AB             ;
0255+  19AB             DUMP_BUFFER:
0256+  19AB CD 20 19    	CALL	NEWLINE
0257+  19AE             
0258+  19AE D5          	PUSH	DE
0259+  19AF E1          	POP	HL
0260+  19B0 14          	INC	D
0261+  19B1 14          	INC	D
0262+  19B2             
0263+  19B2             DB_BLKRD:
0264+  19B2 C5          	PUSH	BC
0265+  19B3 E5          	PUSH	HL
0266+  19B4 C1          	POP	BC
0267+  19B5 CD 62 19    	CALL	PRTHEXWORD		; PRINT START LOCATION
0268+  19B8 C1          	POP	BC
0269+  19B9 CD D7 18    	CALL	PC_SPACE		;
0270+  19BC 0E 10       	LD	C,16			; SET FOR 16 LOCS
0271+  19BE E5          	PUSH	HL			; SAVE STARTING HL
0272+  19BF             DB_NXTONE:
0273+  19BF 7E          	LD	A,(HL)			; GET BYTE
0274+  19C0 CD 52 19    	CALL	PRTHEXBYTE		; PRINT IT
0275+  19C3 CD D7 18    	CALL	PC_SPACE		;
0276+  19C6             DB_UPDH:
0277+  19C6 23          	INC	HL			; POINT NEXT
0278+  19C7 0D          	DEC	C			; DEC. LOC COUNT
0279+  19C8 20 F5       	JR	NZ,DB_NXTONE		; IF LINE NOT DONE
0280+  19CA             					; NOW PRINT 'DECODED' DATA TO RIGHT OF DUMP
0281+  19CA             DB_PCRLF:
0282+  19CA CD D7 18    	CALL	PC_SPACE		; SPACE IT
0283+  19CD 0E 10       	LD	C,16			; SET FOR 16 CHARS
0284+  19CF E1          	POP	HL			; GET BACK START
0285+  19D0             DB_PCRLF0:
0286+  19D0 7E          	LD	A,(HL)			; GET BYTE
0287+  19D1 E6 60       	AND	060H			; SEE IF A 'DOT'
0288+  19D3 7E          	LD	A,(HL)			; O.K. TO GET
0289+  19D4 20 02       	JR	NZ,DB_PDOT		;
0290+  19D6             DB_DOT:
0291+  19D6 3E 2E       	LD	A,2EH			; LOAD A DOT
0292+  19D8             DB_PDOT:
0293+  19D8 CD FF 28    	CALL	COUT			; PRINT IT
0294+  19DB 23          	INC	HL			;
0295+  19DC 7A          	LD	A,D			;
0296+  19DD BC          	CP	H			;
0297+  19DE 20 05       	JR	NZ,DB_UPDH1		;
0298+  19E0 7B          	LD	A,E			;
0299+  19E1 BD          	CP	L			;
0300+  19E2 CA EE 19    	JP	Z,DB_END		;
0301+  19E5             DB_UPDH1:
0302+  19E5             ; IF BLOCK NOT DUMPED, DO NEXT CHARACTER OR LINE
0303+  19E5 0D          	DEC	C			; DEC. CHAR COUNT
0304+  19E6 20 E8       	JR	NZ,DB_PCRLF0		; DO NEXT
0305+  19E8             DB_CONTD:
0306+  19E8 CD 20 19    	CALL	NEWLINE			;
0307+  19EB C3 B2 19    	JP	DB_BLKRD		;
0308+  19EE             
0309+  19EE             DB_END:
0310+  19EE C9          	RET
0311+  19EF             ;
0312+  19EF             ; PRINT THE nTH STRING IN A LIST OF STRINGS WHERE EACH IS TERMINATED BY $
0313+  19EF             ; C REGISTER CONTAINS THE INDEX TO THE STRING TO BE DISPLAYED.
0314+  19EF             ; A REGISTER CONTAINS A MASK TO BE APPLIED TO THE INDEX
0315+  19EF             ; THE INDEX IS NORMALIZED TO A RANGE 0..N USING THE MASK AND THEN THE nTH
0316+  19EF             ; STRING IS PRINTED IN A LIST DEFINED BY DE
0317+  19EF             ;
0318+  19EF             ; C = ATTRIBUTE
0319+  19EF             ; A = MASK
0320+  19EF             ; DE = STRING LIST
0321+  19EF             ;
0322+  19EF             PRTIDXMSK:
0323+  19EF C5          	PUSH	BC
0324+  19F0             PRTIDXMSK0:
0325+  19F0 CB 47       	BIT	0,A
0326+  19F2 20 06       	JR	NZ,PRTIDXMSK1
0327+  19F4 CB 3F       	SRL	A
0328+  19F6 CB 39       	SRL	C
0329+  19F8 18 F6       	JR	PRTIDXMSK0
0330+  19FA             PRTIDXMSK1:
0331+  19FA 47          	LD	B,A
0332+  19FB 79          	LD	A,C
0333+  19FC A0          	AND	B
0334+  19FD C1          	POP	BC
0335+  19FE             ;
0336+  19FE             ; PRINT THE nTH STRING IN A LIST OF STRINGS WHERE EACH IS TERMINATED BY $
0337+  19FE             ; A REGISTER DEFINES THE nTH STRING IN THE LIST TO PRINT AND DE POINTS
0338+  19FE             ; TO THE START OF THE STRING LIST.
0339+  19FE             ;
0340+  19FE             ; SLOW BUT IMPROVES CODE SIZE, READABILITY AND ELIMINATES THE NEED HAVE
0341+  19FE             ; LIST OF POINTERS OR A LIST OF CONDITIONAL CHECKS.
0342+  19FE             ;
0343+  19FE             PRTIDXDEA:
0344+  19FE C5          	PUSH	BC
0345+  19FF 4F          	LD	C,A			; INDEX COUNT
0346+  1A00 B7          	OR	A
0347+  1A01 3E 00       	LD	A,0
0348+  1A03 32 27 1A    	LD	(PRTIDXCNT),A		; RESET CHARACTER COUNT
0349+  1A06             PRTIDXDEA1:
0350+  1A06 28 09       	JR	Z,PRTIDXDEA3
0351+  1A08             PRTIDXDEA2:
0352+  1A08 1A          	LD	A,(DE)			; LOOP UNIT
0353+  1A09 13          	INC	DE			; WE REACH
0354+  1A0A FE 24       	CP	'$'			; END OF STRING
0355+  1A0C 20 FA       	JR	NZ,PRTIDXDEA2
0356+  1A0E 0D          	DEC	C			; AT STRING END. SO GO
0357+  1A0F 18 F5       	JR	PRTIDXDEA1		; CHECK FOR INDEX MATCH
0358+  1A11             PRTIDXDEA3:
0359+  1A11 C1          	POP	BC
0360+  1A12             ;	CALL	WRITESTR		; FALL THROUGH TO WRITESTR
0361+  1A12             ;	RET
0362+  1A12             ;
0363+  1A12             ; OUTPUT A '$' TERMINATED STRING AT DE
0364+  1A12             ;
0365+  1A12             WRITESTR:
0366+  1A12 F5          	PUSH	AF
0367+  1A13             WRITESTR1:
0368+  1A13 1A          	LD	A,(DE)
0369+  1A14 FE 24       	CP	'$'			; TEST FOR STRING TERMINATOR
0370+  1A16 28 0D       	JR	Z,WRITESTR2
0371+  1A18 CD FF 28    	CALL	COUT
0372+  1A1B 3A 27 1A    	LD	A,(PRTIDXCNT)
0373+  1A1E 3C          	INC	A
0374+  1A1F 32 27 1A    	LD	(PRTIDXCNT),A
0375+  1A22 13          	INC	DE
0376+  1A23 18 EE       	JR	WRITESTR1
0377+  1A25             WRITESTR2:
0378+  1A25 F1          	POP	AF
0379+  1A26 C9          	RET
0380+  1A27             ;
0381+  1A27             PRTIDXCNT:
0382+  1A27 00          	.DB	0			; CHARACTER COUNT
0383+  1A28             ;
0384+  1A28             ;
0385+  1A28             ;
0386+  1A28             TSTPT:
0387+  1A28 D5          	PUSH	DE
0388+  1A29 11 BF 1A    	LD	DE,STR_TSTPT
0389+  1A2C CD 12 1A    	CALL	WRITESTR
0390+  1A2F D1          	POP	DE
0391+  1A30 18 00       	JR	REGDMP			; DUMP REGISTERS AND RETURN
0392+  1A32             ;
0393+  1A32             ;
0394+  1A32             ;
0395+  1A32             REGDMP:
0396+  1A32 CD 36 1A    	CALL	XREGDMP
0397+  1A35 C9          	RET
0398+  1A36             ;
0399+  1A36             XREGDMP:
0400+  1A36 E3          	EX	(SP),HL			; RET ADR TO HL, SAVE HL ON TOS
0401+  1A37 22 9F 1A    	LD	(REGDMP_RET),HL		; SAVE RETURN ADDRESS
0402+  1A3A E1          	POP	HL			; RESTORE HL AND BURN STACK ENTRY
0403+  1A3B             
0404+  1A3B E3          	EX	(SP),HL			; PC TO HL, SAVE HL ON TOS
0405+  1A3C 22 A1 1A    	LD	(REGDMP_PC),HL		; SAVE PC VALUE
0406+  1A3F E3          	EX	(SP),HL			; BACK THE WAY IT WAS
0407+  1A40             
0408+  1A40 ED 73 A3 1A 	LD	(REGDMP_SP),SP		; SAVE STACK POINTER
0409+  1A44             
0410+  1A44             	;LD	(RD_STKSAV),SP		; SAVE ORIGINAL STACK POINTER
0411+  1A44             	;LD	SP,RD_STACK		; SWITCH TO PRIVATE STACK
0412+  1A44             
0413+  1A44 F5          	PUSH	AF
0414+  1A45 C5          	PUSH	BC
0415+  1A46 D5          	PUSH	DE
0416+  1A47 E5          	PUSH	HL
0417+  1A48             
0418+  1A48 F5          	PUSH	AF
0419+  1A49 3E 40       	LD	A,'@'
0420+  1A4B CD FF 28    	CALL	COUT
0421+  1A4E F1          	POP	AF
0422+  1A4F             
0423+  1A4F C5          	PUSH	BC
0424+  1A50 ED 4B A1 1A 	LD	BC,(REGDMP_PC)
0425+  1A54 CD 62 19    	CALL	PRTHEXWORD		; PC
0426+  1A57 C1          	POP	BC
0427+  1A58 CD EB 18    	CALL	PC_LBKT
0428+  1A5B C5          	PUSH	BC
0429+  1A5C F5          	PUSH	AF
0430+  1A5D C1          	POP	BC
0431+  1A5E CD 62 19    	CALL	PRTHEXWORD		; AF
0432+  1A61 C1          	POP	BC
0433+  1A62 CD E1 18    	CALL	PC_COLON
0434+  1A65 CD 62 19    	CALL	PRTHEXWORD		; BC
0435+  1A68 CD E1 18    	CALL	PC_COLON
0436+  1A6B D5          	PUSH	DE
0437+  1A6C C1          	POP	BC
0438+  1A6D CD 62 19    	CALL	PRTHEXWORD		; DE
0439+  1A70 CD E1 18    	CALL	PC_COLON
0440+  1A73 E5          	PUSH	HL
0441+  1A74 C1          	POP	BC
0442+  1A75 CD 62 19    	CALL	PRTHEXWORD		; HL
0443+  1A78 CD E1 18    	CALL	PC_COLON
0444+  1A7B ED 4B A3 1A 	LD	BC,(REGDMP_SP)
0445+  1A7F CD 62 19    	CALL	PRTHEXWORD		; SP
0446+  1A82             
0447+  1A82 CD E1 18    	CALL	PC_COLON
0448+  1A85 DD E5       	PUSH	IX
0449+  1A87 C1          	POP	BC
0450+  1A88 CD 62 19    	CALL	PRTHEXWORD		; IX
0451+  1A8B             
0452+  1A8B CD E1 18    	CALL	PC_COLON
0453+  1A8E FD E5       	PUSH	IY
0454+  1A90 C1          	POP	BC
0455+  1A91 CD 62 19    	CALL	PRTHEXWORD		; IY
0456+  1A94             
0457+  1A94 CD F0 18    	CALL	PC_RBKT
0458+  1A97 CD D7 18    	CALL	PC_SPACE
0459+  1A9A             
0460+  1A9A E1          	POP	HL
0461+  1A9B D1          	POP	DE
0462+  1A9C C1          	POP	BC
0463+  1A9D F1          	POP	AF
0464+  1A9E             
0465+  1A9E             	;LD	SP,(RD_STKSAV)		; BACK TO ORIGINAL STACK FRAME
0466+  1A9E             
0467+  1A9E C3 FF FF    	JP	$FFFF			; RETURN, $FFFF IS DYNAMICALLY UPDATED
0468+  1AA1             REGDMP_RET	.EQU	$-2		; RETURN ADDRESS GOES HERE
0469+  1AA1             ;
0470+  1AA1 00 00       REGDMP_PC	.DW	0
0471+  1AA3 00 00       REGDMP_SP	.DW	0
0472+  1AA5             ;
0473+  1AA5             ;RD_STKSAV	.DW	0
0474+  1AA5             ;		.FILL	$FF,16*2	; 16 LEVEL PRIVATE STACK
0475+  1AA5             ;RD_STACK	.EQU	$
0476+  1AA5             ;
0477+  1AA5             ;
0478+  1AA5             ;
0479+  1AA5             ;
0480+  1AA5             ;
0481+  1AA5 0D 0A 0D 0A STR_HALT	.TEXT	"\r\n\r\n*** System Halted ***$"
0481+  1AA9 2A 2A 2A 20 
0481+  1AAD 53 79 73 74 
0481+  1AB1 65 6D 20 48 
0481+  1AB5 61 6C 74 65 
0481+  1AB9 64 20 2A 2A 
0481+  1ABD 2A 24 
0482+  1ABF 0D 0A 2B 2B STR_TSTPT	.TEXT	"\r\n+++ TSTPT: $"
0482+  1AC3 2B 20 54 53 
0482+  1AC7 54 50 54 3A 
0482+  1ACB 20 24 
0483+  1ACD             ;STR_AF		.DB	" AF=$"
0484+  1ACD             ;STR_BC		.DB	" BC=$"
0485+  1ACD             ;STR_DE		.DB	" DE=$"
0486+  1ACD             ;STR_HL		.DB	" HL=$"
0487+  1ACD             ;STR_PC		.DB	" PC=$"
0488+  1ACD             ;STR_SP		.DB	" SP=$"
0489+  1ACD             ;
0490+  1ACD             ; INDIRECT JUMP TO ADDRESS IN HL,IX, OR IY
0491+  1ACD             ;
0492+  1ACD             ;   MOSTLY USEFUL TO PERFORM AN INDIRECT CALL LIKE:
0493+  1ACD             ;     LD	HL,xxxx
0494+  1ACD             ;     CALL	JPHL
0495+  1ACD             ;
0496+  1ACD E9          JPHL:	JP	(HL)
0497+  1ACE DD E9       JPIX:	JP	(IX)
0498+  1AD0 FD E9       JPIY:	JP	(IY)
0499+  1AD2             ;
0500+  1AD2             ; ADD HL,A
0501+  1AD2             ;
0502+  1AD2             ;   A REGISTER IS DESTROYED!
0503+  1AD2             ;
0504+  1AD2             ADDHLA:
0505+  1AD2 85          	ADD	A,L
0506+  1AD3 6F          	LD	L,A
0507+  1AD4 D0          	RET	NC
0508+  1AD5 24          	INC	H
0509+  1AD6 C9          	RET
0510+  1AD7             ;
0511+  1AD7             ;****************************
0512+  1AD7             ;	A(BCD) => A(BIN)
0513+  1AD7             ;	[00H..99H] -> [0..99]
0514+  1AD7             ;****************************
0515+  1AD7             ;
0516+  1AD7             BCD2BYTE:
0517+  1AD7 C5          	PUSH	BC
0518+  1AD8 4F          	LD	C,A
0519+  1AD9 E6 F0       	AND	0F0H
0520+  1ADB CB 3F       	SRL	A
0521+  1ADD 47          	LD	B,A
0522+  1ADE CB 3F       	SRL	A
0523+  1AE0 CB 3F       	SRL	A
0524+  1AE2 80          	ADD	A,B
0525+  1AE3 47          	LD	B,A
0526+  1AE4 79          	LD	A,C
0527+  1AE5 E6 0F       	AND	0FH
0528+  1AE7 80          	ADD	A,B
0529+  1AE8 C1          	POP	BC
0530+  1AE9 C9          	RET
0531+  1AEA             ;
0532+  1AEA             ;*****************************
0533+  1AEA             ;	 A(BIN) =>  A(BCD)
0534+  1AEA             ;	[0..99] => [00H..99H]
0535+  1AEA             ;*****************************
0536+  1AEA             ;
0537+  1AEA             BYTE2BCD:
0538+  1AEA C5          	PUSH	BC
0539+  1AEB 06 0A       	LD	B,10
0540+  1AED 0E FF       	LD	C,-1
0541+  1AEF             BYTE2BCD1:
0542+  1AEF 0C          	INC	C
0543+  1AF0 90          	SUB	B
0544+  1AF1 30 FC       	JR	NC,BYTE2BCD1
0545+  1AF3 80          	ADD	A,B
0546+  1AF4 47          	LD	B,A
0547+  1AF5 79          	LD	A,C
0548+  1AF6 87          	ADD	A,A
0549+  1AF7 87          	ADD	A,A
0550+  1AF8 87          	ADD	A,A
0551+  1AF9 87          	ADD	A,A
0552+  1AFA B0          	OR	B
0553+  1AFB C1          	POP	BC
0554+  1AFC C9          	RET
0555+  1AFD             
0556+  1AFD             #IFDEF USEDELAY
0557+  1AFD             
0558+  1AFD             ;
0559+  1AFD             ; DELAY 16US (CPU SPEED COMPENSATED) INCUDING CALL/RET INVOCATION
0560+  1AFD             ; REGISTER A AND FLAGS DESTROYED
0561+  1AFD             ; NO COMPENSATION FOR Z180 MEMORY WAIT STATES
0562+  1AFD             ; THERE IS AN OVERHEAD OF 3TS PER INVOCATION
0563+  1AFD             ;   IMPACT OF OVERHEAD DIMINISHES AS CPU SPEED INCREASES
0564+  1AFD             ;
0565+  1AFD             ; CPU SCALER (CPUSCL) = (CPUHMZ - 2) FOR 16US + 3TS DELAY
0566+  1AFD             ;   NOTE: CPUSCL MUST BE >= 1!
0567+  1AFD             ;
0568+  1AFD             ; EXAMPLE: 8MHZ CPU (DELAY GOAL IS 16US)
0569+  1AFD             ;   LOOP = ((6 * 16) - 5) = 91TS
0570+  1AFD             ;   TOTAL COST = (91 + 40) = 131TS
0571+  1AFD             ;   ACTUAL DELAY = (131 / 8) = 16.375US
0572+  1AFD             ;
0573+  1AFD             	; --- TOTAL COST = (LOOP COST + 40) TS -----------------+
0574+  1AFD             DELAY:				; 17TS (FROM INVOKING CALL)	|
0575+  1AFD 3A 2A 1B    	LD	A,(CPUSCL)	; 13TS				|
0576+  1B00             ;								|
0577+  1B00             DELAY1:				;				|
0578+  1B00             	; --- LOOP = ((CPUSCL * 16) - 5) TS ------------+	|
0579+  1B00 3D          	DEC	A		; 4TS			|	|
0580+  1B01               #IF (BIOS == BIOS_WBW)	;			|	|
0581+  1B01~                #IF (CPUFAM == CPU_Z180)	;			|	|
0582+  1B01~            	OR	A		; +4TS FOR Z180		|	|
0583+  1B01                 #ENDIF			;			|	|
0584+  1B01               #ENDIF			;			|	|
0585+  1B01 20 FD       	JR	NZ,DELAY1	; 12TS (NZ) / 7TS (Z)	|	|
0586+  1B03             	; ----------------------------------------------+	|
0587+  1B03             ;								|
0588+  1B03 C9          	RET			; 10TS (RETURN)			|
0589+  1B04             	;-------------------------------------------------------+
0590+  1B04             ;
0591+  1B04             ; DELAY 16US * DE (CPU SPEED COMPENSATED)
0592+  1B04             ; REGISTER DE, A, AND FLAGS DESTROYED
0593+  1B04             ; NO COMPENSATION FOR Z180 MEMORY WAIT STATES
0594+  1B04             ; THERE IS A 27TS OVERHEAD FOR CALL/RET PER INVOCATION
0595+  1B04             ;   IMPACT OF OVERHEAD DIMINISHES AS DE AND/OR CPU SPEED INCREASES
0596+  1B04             ;
0597+  1B04             ; CPU SCALER (CPUSCL) = (CPUHMZ - 2) FOR 16US OUTER LOOP COST
0598+  1B04             ;   NOTE: CPUSCL MUST BE > 0!
0599+  1B04             ;
0600+  1B04             ; EXAMPLE: 8MHZ CPU, DE=6250 (DELAY GOAL IS .1 SEC OR 100,000US)
0601+  1B04             ;   INNER LOOP = ((16 * 6) - 5) = 91TS
0602+  1B04             ;   OUTER LOOP = ((91 + 37) * 6250) = 800,000TS
0603+  1B04             ;   ACTUAL DELAY = ((800,000 + 27) / 8) = 100,003US
0604+  1B04             ;
0605+  1B04             	; --- TOTAL COST = (OUTER LOOP + 27) TS ------------------------+
0606+  1B04             VDELAY:				; 17TS (FROM INVOKING CALL)		|
0607+  1B04             ;									|
0608+  1B04             	; --- OUTER LOOP = ((INNER LOOP + 37) * DE) TS ---------+	|
0609+  1B04 3A 2A 1B    	LD	A,(CPUSCL)	; 13TS				|	|
0610+  1B07             ;								|	|
0611+  1B07             VDELAY1:			;				|	|
0612+  1B07             	; --- INNER LOOP = ((CPUSCL * 16) - 5) TS ------+	|	|
0613+  1B07               #IF (BIOS == BIOS_WBW)	;			|	|	|
0614+  1B07~                #IF (CPUFAM == CPU_Z180)	;			|	|	|
0615+  1B07~            	OR	A		; +4TS FOR Z180		|	|	|
0616+  1B07                 #ENDIF			;			|	|	|
0617+  1B07               #ENDIF			;			|	|	|
0618+  1B07 3D          	DEC	A		; 4TS			|	|	|
0619+  1B08 20 FD       	JR	NZ,VDELAY1	; 12TS (NZ) / 7TS (Z)	|	|	|
0620+  1B0A             	; ----------------------------------------------+	|	|
0621+  1B0A             ;								|	|
0622+  1B0A 1B          	DEC	DE		; 6TS				|	|
0623+  1B0B               #IF (BIOS == BIOS_WBW)	;			|	|	|
0624+  1B0B~                #IF (CPUFAM == CPU_Z180)	;				|	|
0625+  1B0B~            	OR	A		; +4TS FOR Z180			|	|
0626+  1B0B                 #ENDIF			;				|	|
0627+  1B0B               #ENDIF			;				|	|
0628+  1B0B 7A          	LD	A,D		; 4TS				|	|
0629+  1B0C B3          	OR	E		; 4TS				|	|
0630+  1B0D C2 04 1B    	JP	NZ,VDELAY	; 10TS				|	|
0631+  1B10             	;-------------------------------------------------------+	|
0632+  1B10             ;									|
0633+  1B10 C9          	RET			; 10TS (FINAL RETURN)			|
0634+  1B11             	;---------------------------------------------------------------+
0635+  1B11             ;
0636+  1B11             ; DELAY ABOUT 0.5 SECONDS
0637+  1B11             ; 500000US / 16US = 31250
0638+  1B11             ;
0639+  1B11             LDELAY:
0640+  1B11 F5          	PUSH	AF
0641+  1B12 D5          	PUSH	DE
0642+  1B13 11 12 7A    	LD	DE,31250
0643+  1B16 CD 04 1B    	CALL	VDELAY
0644+  1B19 D1          	POP	DE
0645+  1B1A F1          	POP	AF
0646+  1B1B C9          	RET
0647+  1B1C             ;
0648+  1B1C             ; INITIALIZE DELAY SCALER BASED ON OPERATING CPU SPEED
0649+  1B1C             ; ENTER WITH A = CPU SPEED IN MHZ
0650+  1B1C             ;
0651+  1B1C             DELAY_INIT:
0652+  1B1C FE 03       	CP	3			; TEST FOR <= 2 (SPECIAL HANDLING)
0653+  1B1E 38 04       	JR	C,DELAY_INIT1		; IF <= 2, SPECIAL PROCESSING
0654+  1B20 D6 02       	SUB	2			; ADJUST AS REQUIRED BY DELAY FUNCTIONS
0655+  1B22 18 02       	JR	DELAY_INIT2		; AND CONTINUE
0656+  1B24             DELAY_INIT1:
0657+  1B24 3E 01       	LD	A,1			; USE THE MIN VALUE OF 1
0658+  1B26             DELAY_INIT2:
0659+  1B26 32 2A 1B    	LD	(CPUSCL),A		; UPDATE CPU SCALER VALUE
0660+  1B29 C9          	RET
0661+  1B2A             
0662+  1B2A~              #IF (CPUMHZ < 3)
0663+  1B2A~            CPUSCL	.DB	1			; CPU SCALER MUST BE > 0
0664+  1B2A               #ELSE
0665+  1B2A 0E          CPUSCL	.DB	CPUMHZ - 2		; OTHERWISE 2 LESS THAN PHI MHZ
0666+  1B2B               #ENDIF
0667+  1B2B             ;
0668+  1B2B             #ENDIF
0669+  1B2B             ;
0670+  1B2B             ; SHORT DELAY FUNCTIONS.  NO CLOCK SPEED COMPENSATION, SO THEY
0671+  1B2B             ; WILL RUN LONGER ON SLOWER SYSTEMS.  THE NUMBER INDICATES THE
0672+  1B2B             ; NUMBER OF CALL/RET INVOCATIONS.  A SINGLE CALL/RET IS
0673+  1B2B             ; 27 T-STATES ON A Z80, 25 T-STATES ON A Z180
0674+  1B2B             ;
0675+  1B2B             ;			; Z80	Z180
0676+  1B2B             ;			; ----	----
0677+  1B2B CD 2E 1B    DLY64:	CALL	DLY32	; 1728	1600
0678+  1B2E CD 31 1B    DLY32:	CALL	DLY16	; 864	800
0679+  1B31 CD 34 1B    DLY16:	CALL	DLY8	; 432	400
0680+  1B34 CD 37 1B    DLY8:	CALL	DLY4	; 216	200
0681+  1B37 CD 3A 1B    DLY4:	CALL	DLY2	; 108	100
0682+  1B3A CD 3D 1B    DLY2:	CALL	DLY1	; 54	50
0683+  1B3D C9          DLY1:	RET		; 27	25
0684+  1B3E             ;
0685+  1B3E             ; MULTIPLY 8-BIT VALUES
0686+  1B3E             ; IN:  MULTIPLY H BY E
0687+  1B3E             ; OUT: HL = RESULT, E = 0, B = 0
0688+  1B3E             ;
0689+  1B3E             MULT8:
0690+  1B3E 16 00       	LD D,0
0691+  1B40 6A          	LD L,D
0692+  1B41 06 08       	LD B,8
0693+  1B43             MULT8_LOOP:
0694+  1B43 29          	ADD HL,HL
0695+  1B44 30 01       	JR NC,MULT8_NOADD
0696+  1B46 19          	ADD HL,DE
0697+  1B47             MULT8_NOADD:
0698+  1B47 10 FA       	DJNZ MULT8_LOOP
0699+  1B49 C9          	RET
0700+  1B4A             ;
0701+  1B4A             ; MULTIPLY A 16 BIT BY 8 BIT INTO 16 BIT
0702+  1B4A             ; IN: MULTIPLY DE BY A
0703+  1B4A             ; OUT: HL = RESULT, B=0, A, C, DE UNCHANGED
0704+  1B4A             ;
0705+  1B4A             MULT8X16:
0706+  1B4A 06 08       	LD	B,8
0707+  1B4C 21 00 00    	LD	HL,0
0708+  1B4F             MULT8X16_1:
0709+  1B4F 29          	ADD	HL,HL
0710+  1B50 07          	RLCA
0711+  1B51 30 01       	JR	NC,MULT8X16_2
0712+  1B53 19          	ADD	HL,DE
0713+  1B54             MULT8X16_2:
0714+  1B54 10 F9       	DJNZ	MULT8X16_1
0715+  1B56 C9          	RET
0716+  1B57             ;;
0717+  1B57             ;; COMPUTE HL / DE
0718+  1B57             ;; RESULT IN BC, REMAINDER IN HL, AND SET ZF DEPENDING ON REMAINDER
0719+  1B57             ;; A, DE DESTROYED
0720+  1B57             ;;
0721+  1B57             ;DIV:
0722+  1B57             ;	XOR	A
0723+  1B57             ;	LD	BC,0
0724+  1B57             ;DIV1:
0725+  1B57             ;	SBC	HL,DE
0726+  1B57             ;	JR	C,DIV2
0727+  1B57             ;	INC	BC
0728+  1B57             ;	JR	DIV1
0729+  1B57             ;DIV2:
0730+  1B57             ;	XOR	A
0731+  1B57             ;	ADC	HL,DE		; USE ADC SO ZF IS SET
0732+  1B57             ;	RET
0733+  1B57             ;===============================================================
0734+  1B57             ;
0735+  1B57             ; COMPUTE HL / DE = BC W/ REMAINDER IN HL & ZF
0736+  1B57             ;
0737+  1B57             DIV16:
0738+  1B57 7C          	LD	A,H			; HL -> AC
0739+  1B58 4D          	LD	C,L			; ...
0740+  1B59 21 00 00    	LD	HL,0			; INIT HL
0741+  1B5C 06 10       	LD	B,16			; INIT LOOP COUNT
0742+  1B5E             DIV16A:
0743+  1B5E 37          	SCF
0744+  1B5F CB 11       	RL	C
0745+  1B61 17          	RLA
0746+  1B62 ED 6A       	ADC	HL,HL
0747+  1B64 ED 52       	SBC	HL,DE
0748+  1B66 30 02       	JR	NC,DIV16B
0749+  1B68 19          	ADD	HL,DE
0750+  1B69 0D          	DEC	C
0751+  1B6A             DIV16B:
0752+  1B6A 10 F2       	DJNZ	DIV16A			; LOOP AS NEEDED
0753+  1B6C 47          	LD	B,A			; AC -> BC
0754+  1B6D 7C          	LD	A,H			; SET ZF
0755+  1B6E B5          	OR	L			; ... BASED ON REMAINDER
0756+  1B6F C9          	RET				; DONE
0757+  1B70             ;
0758+  1B70             ; INTEGER DIVIDE DE:HL BY C
0759+  1B70             ; RESULT IN DE:HL, REMAINDER IN A
0760+  1B70             ; CLOBBERS F, B
0761+  1B70             ;
0762+  1B70             DIV32X8:
0763+  1B70 AF          	XOR	A
0764+  1B71 06 20       	LD	B,32
0765+  1B73             DIV32X8A:
0766+  1B73 29           	ADD	HL,HL
0767+  1B74 CB 13       	RL	E
0768+  1B76 CB 12       	RL	D
0769+  1B78 17          	RLA
0770+  1B79 B9          	CP	C
0771+  1B7A 38 02       	JR	C,DIV32X8B
0772+  1B7C 91          	SUB	C
0773+  1B7D 2C          	INC	L
0774+  1B7E             DIV32X8B:
0775+  1B7E 10 F3        	DJNZ	DIV32X8A
0776+  1B80 C9          	RET
0777+  1B81             ;
0778+  1B81             ; FILL MEMORY AT HL WITH VALUE A, LENGTH IN BC, ALL REGS USED
0779+  1B81             ; LENGTH *MUST* BE GREATER THAN 1 FOR PROPER OPERATION!!!
0780+  1B81             ;
0781+  1B81             FILL:
0782+  1B81 54          	LD	D,H		; SET DE TO HL
0783+  1B82 5D          	LD	E,L		; SO DESTINATION EQUALS SOURCE
0784+  1B83 77          	LD	(HL),A		; FILL THE FIRST BYTE WITH DESIRED VALUE
0785+  1B84 13          	INC	DE		; INCREMENT DESTINATION
0786+  1B85 0B          	DEC	BC		; DECREMENT THE COUNT
0787+  1B86 ED B0       	LDIR			; DO THE REST
0788+  1B88 C9          	RET			; RETURN
0789+  1B89             ;
0790+  1B89             ; SET A BIT IN BYTE ARRAY AT HL, INDEX IN A
0791+  1B89             ;
0792+  1B89             BITSET:
0793+  1B89 CD 9B 1B    	CALL	BITLOC		; LOCATE THE BIT
0794+  1B8C B6          	OR	(HL)		; SET THE SPECIFIED BIT
0795+  1B8D 77          	LD	(HL),A		; SAVE IT
0796+  1B8E C9          	RET			; RETURN
0797+  1B8F             ;
0798+  1B8F             ; CLEAR A BIT IN BYTE ARRAY AT HL, INDEX IN A
0799+  1B8F             ;
0800+  1B8F             BITCLR:
0801+  1B8F CD 9B 1B    	CALL	BITLOC		; LOCATE THE BIT
0802+  1B92 2F          	CPL			; INVERT ALL BITS
0803+  1B93 A6          	AND	(HL)		; CLEAR SPECIFIED BIT
0804+  1B94 77          	LD	(HL),A		; SAVE IT
0805+  1B95 C9          	RET			; RETURN
0806+  1B96             ;
0807+  1B96             ; GET VALUE OF A BIT IN BYTE ARRAY AT HL, INDEX IN A
0808+  1B96             ;
0809+  1B96             BITTST:
0810+  1B96 CD 9B 1B    	CALL	BITLOC		; LOCATE THE BIT
0811+  1B99 A6          	AND	(HL)		; SET Z FLAG BASED ON BIT
0812+  1B9A C9          	RET			; RETURN
0813+  1B9B             ;
0814+  1B9B             ; LOCATE A BIT IN BYTE ARRAY AT HL, INDEX IN A
0815+  1B9B             ; RETURN WITH HL POINTING TO BYTE AND A WITH MASK FOR SPECIFIC BIT
0816+  1B9B             ;
0817+  1B9B             BITLOC:
0818+  1B9B F5          	PUSH	AF		; SAVE BIT INDEX
0819+  1B9C CB 3F       	SRL	A		; DIVIDE BY 8 TO GET BYTE INDEX
0820+  1B9E CB 3F       	SRL	A		; "
0821+  1BA0 CB 3F       	SRL	A		; "
0822+  1BA2 4F          	LD	C,A		; MOVE TO BC
0823+  1BA3 06 00       	LD	B,0		; "
0824+  1BA5 09          	ADD	HL,BC		; HL NOW POINTS TO BYTE CONTAINING BIT
0825+  1BA6 F1          	POP	AF		; RECOVER A (INDEX)
0826+  1BA7 E6 07       	AND	$07		; ISOLATE REMAINDER, Z SET IF ZERO
0827+  1BA9 47          	LD	B,A		; SETUP SHIFT COUNTER
0828+  1BAA 3E 01       	LD	A,1		; SETUP A WITH MASK
0829+  1BAC C8          	RET	Z		; DONE IF ZERO
0830+  1BAD             BITLOC1:
0831+  1BAD CB 27       	SLA	A		; SHIFT
0832+  1BAF 10 FC       	DJNZ	BITLOC1		; LOOP AS NEEDED
0833+  1BB1 C9          	RET			; DONE
0834+  1BB2             ;
0835+  1BB2             ; DECIMAL NUMBER PRINTING ROUTINES
0836+  1BB2             ;
0837+  1BB2             PRTDEC8:	; PRINT VALUE OF A REGISTER IN DECIMAL
0838+  1BB2 FD E5       	PUSH	IY
0839+  1BB4 FD 21 EF 1B 	LD	IY,B2D8
0840+  1BB8 CD D6 1B    	CALL	PRTDECSTR
0841+  1BBB FD E1       	POP	IY
0842+  1BBD C9          	RET
0843+  1BBE             ;
0844+  1BBE             PRTDEC16:	; PRINT VALUE OF HL REGISTER IN DECIMAL
0845+  1BBE FD E5       	PUSH	IY
0846+  1BC0 FD 21 F2 1B 	LD	IY,B2D16
0847+  1BC4 CD D6 1B    	CALL	PRTDECSTR
0848+  1BC7 FD E1       	POP	IY
0849+  1BC9 C9          	RET
0850+  1BCA             ;
0851+  1BCA             PRTDEC32:	; PRINT VALUE OF DE:HL REGISTERS IN DECIMAL
0852+  1BCA FD E5       	PUSH	IY
0853+  1BCC FD 21 F6 1B 	LD	IY,B2D32
0854+  1BD0 CD D6 1B    	CALL	PRTDECSTR
0855+  1BD3 FD E1       	POP	IY
0856+  1BD5 C9          	RET
0857+  1BD6             ;
0858+  1BD6             PRTDECSTR:
0859+  1BD6 F5          	PUSH	AF
0860+  1BD7 C5          	PUSH	BC
0861+  1BD8 D5          	PUSH	DE
0862+  1BD9 E5          	PUSH	HL
0863+  1BDA DD E5       	PUSH	IX
0864+  1BDC CD D0 1A    	CALL	JPIY			; CALL (IY)
0865+  1BDF EB          	EX	DE,HL
0866+  1BE0 3E 24       	LD	A,'$'
0867+  1BE2 32 97 1C    	LD	(B2DEND),A
0868+  1BE5 CD 12 1A    	CALL	WRITESTR
0869+  1BE8 DD E1       	POP	IX
0870+  1BEA E1          	POP	HL
0871+  1BEB D1          	POP	DE
0872+  1BEC C1          	POP	BC
0873+  1BED F1          	POP	AF
0874+  1BEE C9          	RET
0875+  1BEF             ;
0876+  1BEF             ; Combined routine for conversion of different sized binary numbers into
0877+  1BEF             ; directly printable ASCII(Z)-string
0878+  1BEF             ; Input value in registers, number size and -related to that- registers to fill
0879+  1BEF             ; is selected by calling the correct entry:
0880+  1BEF             ;
0881+  1BEF             ;  entry  inputregister(s)  decimal value 0 to:
0882+  1BEF             ;   B2D8             A                    255  (3 digits)
0883+  1BEF             ;   B2D16           HL                  65535   5   "
0884+  1BEF             ;   B2D24         E:HL               16777215   8   "
0885+  1BEF             ;   B2D32        DE:HL             4294967295  10   "
0886+  1BEF             ;   B2D48     BC:DE:HL        281474976710655  15   "
0887+  1BEF             ;   B2D64  IX:BC:DE:HL   18446744073709551615  20   "
0888+  1BEF             ;
0889+  1BEF             ; The resulting string is placed into a small buffer attached to this routine,
0890+  1BEF             ; this buffer needs no initialization and can be modified as desired.
0891+  1BEF             ; The number is aligned to the right, and leading 0's are replaced with spaces.
0892+  1BEF             ; On exit HL points to the first digit, (B)C = number of decimals
0893+  1BEF             ; This way any re-alignment / postprocessing is made easy.
0894+  1BEF             ; Changes: AF,BC,DE,HL,IX
0895+  1BEF             ; P.S. some examples below
0896+  1BEF             ;
0897+  1BEF             ; by Alwin Henseler
0898+  1BEF             ;
0899+  1BEF 26 00       B2D8:	LD	H,0
0900+  1BF1 6F          	LD	L,A
0901+  1BF2 1E 00       B2D16:	LD	E,0
0902+  1BF4 16 00       B2D24:	LD	D,0
0903+  1BF6 01 00 00    B2D32:	LD	BC,0
0904+  1BF9 DD 21 00 00 B2D48:	LD	IX,0			; zero all non-used bits
0905+  1BFD 22 7B 1C    B2D64:	LD	(B2DINV),HL
0906+  1C00 ED 53 7D 1C 	LD	(B2DINV+2),DE
0907+  1C04 ED 43 7F 1C 	LD	(B2DINV+4),BC
0908+  1C08 DD 22 81 1C 	LD	(B2DINV+6),IX		; place full 64-bit input value in buffer
0909+  1C0C 21 83 1C    	LD	HL,B2DBUF
0910+  1C0F 11 84 1C    	LD	DE,B2DBUF+1
0911+  1C12 36 20       	LD	(HL),' '
0912+  1C14             B2DFILC	.EQU	$-1			; address of fill-character
0913+  1C14 01 12 00    	LD	BC,18
0914+  1C17 ED B0       	LDIR				; fill 1st 19 bytes of buffer with spaces
0915+  1C19 ED 43 96 1C 	LD	(B2DEND-1),BC		;set BCD value to "0" & place terminating 0
0916+  1C1D 1E 01       	LD	E,1			; no. of bytes in BCD value
0917+  1C1F 21 83 1C    	LD	HL,B2DINV+8		; (address MSB input)+1
0918+  1C22 01 09 09    	LD	BC,$0909
0919+  1C25 AF          	XOR	A
0920+  1C26 05          B2DSKP0:DEC	B
0921+  1C27 28 29       	JR	Z,B2DSIZ		; all 0: continue with postprocessing
0922+  1C29 2B          	DEC	HL
0923+  1C2A B6          	OR	(HL)			; find first byte <>0
0924+  1C2B 28 F9       	JR	Z,B2DSKP0
0925+  1C2D 0D          B2DFND1:DEC	C
0926+  1C2E 17          	RLA
0927+  1C2F 30 FC       	JR	NC,B2DFND1		; determine no. of most significant 1-bit
0928+  1C31 1F          	RRA
0929+  1C32 57          	LD	D,A			; byte from binary input value
0930+  1C33 E5          B2DLUS2:PUSH	HL
0931+  1C34 C5          	PUSH	BC
0932+  1C35 21 96 1C    B2DLUS1:LD	HL,B2DEND-1		; address LSB of BCD value
0933+  1C38 43          	LD	B,E			; current length of BCD value in bytes
0934+  1C39 CB 12       	RL	D			; highest bit from input value -> carry
0935+  1C3B 7E          B2DLUS0:LD	A,(HL)
0936+  1C3C 8F          	ADC	A,A
0937+  1C3D 27          	DAA
0938+  1C3E 77          	LD	(HL),A			; double 1 BCD byte from intermediate result
0939+  1C3F 2B          	DEC	HL
0940+  1C40 10 F9       	DJNZ	B2DLUS0			; and go on to double entire BCD value (+carry!)
0941+  1C42 30 03       	JR	NC,B2DNXT
0942+  1C44 1C          	INC	E			; carry at MSB -> BCD value grew 1 byte larger
0943+  1C45 36 01       	LD	(HL),1			; initialize new MSB of BCD value
0944+  1C47 0D          B2DNXT:	DEC	C
0945+  1C48 20 EB       	JR	NZ,B2DLUS1		; repeat for remaining bits from 1 input byte
0946+  1C4A C1          	POP	BC			; no. of remaining bytes in input value
0947+  1C4B 0E 08       	LD	C,8			; reset bit-counter
0948+  1C4D E1          	POP	HL			; pointer to byte from input value
0949+  1C4E 2B          	DEC	HL
0950+  1C4F 56          	LD	D,(HL)			; get next group of 8 bits
0951+  1C50 10 E1       	DJNZ	B2DLUS2			; and repeat until last byte from input value
0952+  1C52 21 97 1C    B2DSIZ:	LD	HL,B2DEND		; address of terminating 0
0953+  1C55 4B          	LD	C,E			; size of BCD value in bytes
0954+  1C56 B7          	OR	A
0955+  1C57 ED 42       	SBC	HL,BC			; calculate address of MSB BCD
0956+  1C59 54          	LD	D,H
0957+  1C5A 5D          	LD	E,L
0958+  1C5B ED 42       	SBC	HL,BC
0959+  1C5D EB          	EX	DE,HL			; HL=address BCD value, DE=start of decimal value
0960+  1C5E 41          	LD	B,C			; no. of bytes BCD
0961+  1C5F CB 21       	SLA	C			; no. of bytes decimal (possibly 1 too high)
0962+  1C61 3E 30       	LD	A,'0'
0963+  1C63 ED 6F       	RLD				; shift bits 4-7 of (HL) into bit 0-3 of A
0964+  1C65 FE 30       	CP	'0'			; (HL) was > 9h?
0965+  1C67 20 06       	JR	NZ,B2DEXPH		; if yes, start with recording high digit
0966+  1C69 0D          	DEC	C			; correct number of decimals
0967+  1C6A 13          	INC	DE			; correct start address
0968+  1C6B 18 04       	JR	B2DEXPL			; continue with converting low digit
0969+  1C6D ED 6F       B2DEXP:	RLD				; shift high digit (HL) into low digit of A
0970+  1C6F 12          B2DEXPH:LD	(DE),A			; record resulting ASCII-code
0971+  1C70 13          	INC	DE
0972+  1C71 ED 6F       B2DEXPL:RLD
0973+  1C73 12          	LD	(DE),A
0974+  1C74 13          	INC	DE
0975+  1C75 23          	INC	HL			; next BCD-byte
0976+  1C76 10 F5       	DJNZ	B2DEXP			; and go on to convert each BCD-byte into 2 ASCII
0977+  1C78 ED 42       	SBC	HL,BC			; return with HL pointing to 1st decimal
0978+  1C7A C9          	RET
0979+  1C7B             ;
0980+  1C7B FF FF FF FF B2DINV	.FILL	8			; space for 64-bit input value (LSB first)
0980+  1C7F FF FF FF FF 
0981+  1C83 FF FF FF FF B2DBUF	.FILL	20			; space for 20 decimal digits
0981+  1C87 FF FF FF FF 
0981+  1C8B FF FF FF FF 
0981+  1C8F FF FF FF FF 
0981+  1C93 FF FF FF FF 
0982+  1C97 01          B2DEND	.DB 	1			; space for terminating 0
0983+  1C98             ;
0984+  1C98             ; SHIFT HL:DE BY B BITS
0985+  1C98             ;
0986+  1C98             SRL32:
0987+  1C98             	; ROTATE RIGHT 32 BITS, HIGH ORDER BITS BECOME ZERO
0988+  1C98 CB 3A       	SRL	D
0989+  1C9A CB 1B       	RR	E
0990+  1C9C CB 1C       	RR	H
0991+  1C9E CB 1D       	RR	L
0992+  1CA0 10 F6       	DJNZ	SRL32
0993+  1CA2 C9          	RET
0994+  1CA3             ;
0995+  1CA3             SLA32:
0996+  1CA3             	; ROTATE LEFT 32 BITS, LOW ORDER BITS BECOME ZERO
0997+  1CA3 CB 25       	SLA	L
0998+  1CA5 CB 14       	RL	H
0999+  1CA7 CB 13       	RL	E
1000+  1CA9 CB 12       	RL	D
1001+  1CAB 10 F6       	DJNZ	SLA32
1002+  1CAD C9          	RET
1003+  1CAE             ;
1004+  1CAE             ; PRINT VALUE OF A IN DECIMAL WITH LEADING ZERO SUPPRESSION
1005+  1CAE             ; BELOW ARE NOW OBSOLETE AND MAPPED TO NEW ROUTINES
1006+  1CAE             ;
1007+  1CAE             PRTDECB	.EQU	PRTDEC8
1008+  1CAE             ;;;PRTDECB:
1009+  1CAE             ;;;	PUSH	HL
1010+  1CAE             ;;;	PUSH	AF
1011+  1CAE             ;;;	LD	L,A
1012+  1CAE             ;;;	LD	H,0
1013+  1CAE             ;;;	CALL	PRTDEC
1014+  1CAE             ;;;	POP	AF
1015+  1CAE             ;;;	POP	HL
1016+  1CAE             ;;;	RET
1017+  1CAE             ;
1018+  1CAE             ; PRINT VALUE OF HL IN DECIMAL WITH LEADING ZERO SUPPRESSION
1019+  1CAE             ;
1020+  1CAE             PRTDEC	.EQU	PRTDEC16
1021+  1CAE             ;;;PRTDEC:
1022+  1CAE             ;;;	PUSH	BC
1023+  1CAE             ;;;	PUSH	DE
1024+  1CAE             ;;;	PUSH	HL
1025+  1CAE             ;;;	LD	E,'0'
1026+  1CAE             ;;;	LD	BC,-10000
1027+  1CAE             ;;;	CALL	PRTDEC1
1028+  1CAE             ;;;	LD	BC,-1000
1029+  1CAE             ;;;	CALL	PRTDEC1
1030+  1CAE             ;;;	LD	BC,-100
1031+  1CAE             ;;;	CALL	PRTDEC1
1032+  1CAE             ;;;	LD	C,-10
1033+  1CAE             ;;;	CALL	PRTDEC1
1034+  1CAE             ;;;	LD	E,0
1035+  1CAE             ;;;	LD	C,-1
1036+  1CAE             ;;;	CALL	PRTDEC1
1037+  1CAE             ;;;	POP	HL
1038+  1CAE             ;;;	POP	DE
1039+  1CAE             ;;;	POP	BC
1040+  1CAE             ;;;	RET
1041+  1CAE             ;;;PRTDEC1:
1042+  1CAE             ;;;	LD	A,'0' - 1
1043+  1CAE             ;;;PRTDEC2:
1044+  1CAE             ;;;	INC	A
1045+  1CAE             ;;;	ADD	HL,BC
1046+  1CAE             ;;;	JR	C,PRTDEC2
1047+  1CAE             ;;;	SBC	HL,BC
1048+  1CAE             ;;;	CP	E
1049+  1CAE             ;;;	JR	Z,PRTDEC3
1050+  1CAE             ;;;	LD	E,0
1051+  1CAE             ;;;	CALL	COUT
1052+  1CAE             ;;;PRTDEC3:
1053+  1CAE             ;;;	RET
1054+  1CAE             ;
1055+  1CAE             ; LOAD OR STORE DE:HL
1056+  1CAE             ;
1057+  1CAE             LD32:
1058+  1CAE             	; LD DE:HL,(HL)
1059+  1CAE F5          	PUSH	AF
1060+  1CAF 5E          	LD	E,(HL)
1061+  1CB0 23          	INC	HL
1062+  1CB1 56          	LD	D,(HL)
1063+  1CB2 23          	INC	HL
1064+  1CB3 7E          	LD	A,(HL)
1065+  1CB4 23          	INC	HL
1066+  1CB5 66          	LD	H,(HL)
1067+  1CB6 6F          	LD	L,A
1068+  1CB7 F1          	POP	AF
1069+  1CB8 EB          	EX	DE,HL
1070+  1CB9 C9          	RET
1071+  1CBA             ;
1072+  1CBA             ST32:
1073+  1CBA             	; LD (BC),DE:HL
1074+  1CBA F5          	PUSH	AF
1075+  1CBB 7D          	LD	A,L
1076+  1CBC 02          	LD	(BC),A
1077+  1CBD 03          	INC	BC
1078+  1CBE 7C          	LD	A,H
1079+  1CBF 02          	LD	(BC),A
1080+  1CC0 03          	INC	BC
1081+  1CC1 7B          	LD	A,E
1082+  1CC2 02          	LD	(BC),A
1083+  1CC3 03          	INC	BC
1084+  1CC4 7A          	LD	A,D
1085+  1CC5 02          	LD	(BC),A
1086+  1CC6 F1          	POP	AF
1087+  1CC7 C9          	RET
1088+  1CC8             ;
1089+  1CC8             ; INC/ADD/DEC/SUB 32 BIT VALUE IN DE:HL
1090+  1CC8             ; FOR ADD/SUB, OPERAND IS IN BC
1091+  1CC8             ;
1092+  1CC8             INC32:
1093+  1CC8 01 01 00    	LD	BC,1
1094+  1CCB             ADD32:
1095+  1CCB 09          	ADD	HL,BC
1096+  1CCC D0          	RET	NC
1097+  1CCD 13          	INC	DE
1098+  1CCE C9          	RET
1099+  1CCF             ;
1100+  1CCF             DEC32:
1101+  1CCF 01 01 00    	LD	BC,1
1102+  1CD2             SUB32:
1103+  1CD2 B7          	OR	A
1104+  1CD3 ED 42       	SBC	HL,BC
1105+  1CD5 D0          	RET	NC
1106+  1CD6 1B          	DEC	DE
1107+  1CD7 C9          	RET
1108+  1CD8             ;
1109+  1CD8             ; INC32 (HL)
1110+  1CD8             ; INCREMENT 32 BIT BINARY AT ADDRESS
1111+  1CD8             ;
1112+  1CD8             INC32HL:
1113+  1CD8 34          	INC	(HL)
1114+  1CD9 C0          	RET	NZ
1115+  1CDA 23          	INC	HL
1116+  1CDB 34          	INC	(HL)
1117+  1CDC C0          	RET	NZ
1118+  1CDD 23          	INC	HL
1119+  1CDE 34          	INC	(HL)
1120+  1CDF C0          	RET	NZ
1121+  1CE0 23          	INC	HL
1122+  1CE1 34          	INC	(HL)
1123+  1CE2 C9          	RET
1124+  1CE3             
6288   1CE3             #INCLUDE "time.asm"
0001+  1CE3             ;
0002+  1CE3             ;==================================================================================================
0003+  1CE3             ; TIME ROUTINES
0004+  1CE3             ;==================================================================================================
0005+  1CE3             ;
0006+  1CE3             ; COMPUTE DAY OF WEEK FROM YEAR, MONTH, DAY
0007+  1CE3             ;   INPUT: HL IS FULL YEAR VALUE,
0008+  1CE3             ;          D IS MONTH, E IS DATE
0009+  1CE3             ;   RESULT: A=0-6 (SUN-SAT)
0010+  1CE3             ;
0011+  1CE3             ; DD + MX + YY + (YY/4) + CX
0012+  1CE3             ; MX IS LOOKUP BASED ON ZERO INDEXED MONTH FOR
0013+  1CE3             ;   LEAP YEAR: 0,3,3,6,1,4,6,2,5,0,3,5
0014+  1CE3             ;   NON-LEAP YEAR: -1,2,3,6,1,4,6,2,5,0,3,5
0015+  1CE3             ; CX IS 6 IF CENTURY DIVISIBLE BY 4, THEN, 4, 2, 0
0016+  1CE3             ;   SO 20XX = 6, 19XX = 4, 18XX = 2, 17XX = 0, 16XX = 6, ETC.
0017+  1CE3             ;
0018+  1CE3             DOW:
0019+  1CE3             	; SAVE INCOMING MONTH AND DATE
0020+  1CE3 ED 53 4B 1D 	LD	(DOW_DT),DE	; SAVE DATE TO DT AND MONTH TO MO
0021+  1CE7             	; DETERMINE CENTURY AND YEAR OF CENTURY FROM FULL YEAR
0022+  1CE7 E5          	PUSH	HL		; SAVE FULL YEAR VALUE
0023+  1CE8 11 64 00    	LD	DE,100		; DIVIDE BY 100 TO GET CC/YY
0024+  1CEB CD 57 1B    	CALL	DIV16		; BC NOW HAS CENTURY, HL HAS YEAR OF CENTURY
0025+  1CEE 7D          	LD	A,L		; MOVE YEAR TO A, DISCARD H NOT NEEDED
0026+  1CEF 32 4A 1D    	LD	(DOW_YR),A	; SAVE YY
0027+  1CF2 79          	LD	A,C		; MOVE CENTURY TO A, DISCARD B NOT NEEDED
0028+  1CF3 32 49 1D    	LD	(DOW_CC),A	; SAVE CENTURY
0029+  1CF6             	; USING FULL YEAR VALUE, CHECK FOR LEAP YEAR
0030+  1CF6 E1          	POP	HL		; GET FULL YEAR VALUE BACK
0031+  1CF7 CD DE 1D    	CALL	LEAP		; CHECK FOR LEAP YEAR, Z IF SO
0032+  1CFA             DOW1:
0033+  1CFA             	; LOOKUP MX VALUE BASED MONTH USING APPROPRIATE TABLE
0034+  1CFA 21 31 1D    	LD	HL,DOW_MX1	; POINT TO MONTH VALUE TABLE
0035+  1CFD 20 03       	JR	NZ,DOW2		; NOT LEAP, USE STD TBL
0036+  1CFF 21 3D 1D    	LD	HL,DOW_MX2	; LEAP YEAR, USE LEAP TBL
0037+  1D02             DOW2:
0038+  1D02 3A 4C 1D    	LD	A,(DOW_MO)	; GET MONTH
0039+  1D05 3D          	DEC	A		; ZERO OFFSET
0040+  1D06 CD D2 1A    	CALL	ADDHLA		; LOOKUP SPECIAL MONTH VALUE
0041+  1D09 7E          	LD	A,(HL)		; A NOW HAS SPECIAL MONTH VALUE
0042+  1D0A 47          	LD	B,A		; SAVE IT IN B
0043+  1D0B             ;
0044+  1D0B             	; B NOW HAS INITIAL WORKING VALUE, ADD IN DATE
0045+  1D0B 3A 4B 1D    	LD	A,(DOW_DT)	; GET DATE
0046+  1D0E 80          	ADD	A,B		; ADD WITH SPECIAL MONTH VALUE
0047+  1D0F 47          	LD	B,A		; SAVE IT
0048+  1D10             ;
0049+  1D10             	; ADD IN YEAR OF CENTURY
0050+  1D10 3A 4A 1D    	LD	A,(DOW_YR)	; GET TWO DIGIT YEAR VALUE
0051+  1D13 80          	ADD	A,B		; ADD WITH WORKING VALUE
0052+  1D14 47          	LD	B,A		; SAVE IT
0053+  1D15             ;
0054+  1D15             	; ADD IN (YEAR OF CENTURY / 4)
0055+  1D15 3A 4A 1D    	LD	A,(DOW_YR)	; GET TWO DIGIT YEAR AGAIN
0056+  1D18 CB 3F       	SRL	A		; DIVIDE BY 4
0057+  1D1A CB 3F       	SRL	A		; .. BY SHIFTING
0058+  1D1C 80          	ADD	A,B		; ADD WITH WORKING VALUE
0059+  1D1D 47          	LD	B,A		; SAVE IT
0060+  1D1E             ;
0061+  1D1E             	; DETERMINE CX = 6 - ((CC % 4) * 2)
0062+  1D1E 3A 49 1D    	LD	A,(DOW_CC)	; GET CC
0063+  1D21 E6 03       	AND	3		; MOD 4
0064+  1D23 CB 27       	SLA	A		; * 2
0065+  1D25 ED 44       	NEG
0066+  1D27 C6 06       	ADD	A,6
0067+  1D29             ;
0068+  1D29             	; COMBINE CX WITH WORKING VALUE TO GET FINAL VALUE IN A
0069+  1D29 80          	ADD	A,B		; ADD WITH WORKING VALUE
0070+  1D2A             	; CALC FINAL VALUE MOD 7 TO GET WEEKDAY VALUE 0-6
0071+  1D2A 06 07       	LD	B,7		; SUB IN INCREMENTS OF 7
0072+  1D2C             DOW3:
0073+  1D2C 90          	SUB	B		; NEXT SUBTRACTION
0074+  1D2D 30 FD       	JR	NC,DOW3		; IF NO CARRY, KEEP GOING SUBTRACTING
0075+  1D2F 80          	ADD	A,B		; WENT TOO FAR, ADD 7 BACK TO GET RESULT
0076+  1D30 C9          	RET
0077+  1D31             ;
0078+  1D31 00 03 03 06 DOW_MX1		.DB	0,3,3,6,1,4,6,2,5,0,3,5
0078+  1D35 01 04 06 02 
0078+  1D39 05 00 03 05 
0079+  1D3D FF 02 03 06 DOW_MX2		.DB	-1,2,3,6,1,4,6,2,5,0,3,5
0079+  1D41 01 04 06 02 
0079+  1D45 05 00 03 05 
0080+  1D49             ;
0081+  1D49 00          DOW_CC	.DB	0
0082+  1D4A 00          DOW_YR	.DB	0
0083+  1D4B 00          DOW_DT	.DB	0
0084+  1D4C 00          DOW_MO	.DB	0
0085+  1D4D             ;
0086+  1D4D             ; DERIVE DOW FROM STANDARD TIME BUFFER AT HL
0087+  1D4D             ;   RETURN DOW IN A (0-6: SUN-SAT)
0088+  1D4D             ;
0089+  1D4D             TIMDOW:
0090+  1D4D E5          	PUSH	HL
0091+  1D4E 23          	INC	HL			; POINT TO MONTH
0092+  1D4F 7E          	LD	A,(HL)			; LOAD MONTH (BCD)
0093+  1D50 CD D7 1A    	CALL	BCD2BYTE		; CVT TO BINARY
0094+  1D53 57          	LD	D,A			; D := MONTH (BINARY)
0095+  1D54 23          	INC	HL			; POINT TO DATE
0096+  1D55 7E          	LD	A,(HL)			; LOAD DATE (BCD)
0097+  1D56 CD D7 1A    	CALL	BCD2BYTE		; CVT TO BINARY
0098+  1D59 5F          	LD	E,A			; E := DATE (BINARY)
0099+  1D5A E1          	POP	HL			; RECOVER PTR TO START OF BUF
0100+  1D5B D5          	PUSH	DE			; SAVE DE FOR NOW
0101+  1D5C 7E          	LD	A,(HL)			; LOAD YEAR OF CENTURY (BCD)
0102+  1D5D CD D7 1A    	CALL	BCD2BYTE		; CVT TO BINARY
0103+  1D60 6F          	LD	L,A			; YEAR VALUE
0104+  1D61 26 00       	LD	H,0			; .. IN HL
0105+  1D63 11 D0 07    	LD	DE,2000			; ASSUME CENTURY IS 20XX
0106+  1D66 19          	ADD	HL,DE			; .. AND ADD IT IN TO THE YEAR VALUE IN HL
0107+  1D67 D1          	POP	DE			; RECOVER DE (MONTH, DATE)
0108+  1D68 C3 E3 1C    	JP	DOW
0109+  1D6B             ;
0110+  1D6B             ; PRINT DATE AND TIME
0111+  1D6B             ;   INPUT: YYMMDDHHMMSS BUFFER AT HL (BCD ENCODED)
0112+  1D6B             ;
0113+  1D6B             PRTDT:
0114+  1D6B E5          	PUSH	HL			; SAVE BUFFER POINTER
0115+  1D6C CD 4D 1D    	CALL	TIMDOW
0116+  1D6F CD B2 1D    	CALL	PRTDOW
0117+  1D72 E1          	POP	HL			; RECOVER PTR TO START OF BUF
0118+  1D73 CD D7 18    	CALL	PC_SPACE
0119+  1D76 3E 32       	LD	A,'2'
0120+  1D78 CD FF 28    	CALL	COUT
0121+  1D7B 3E 30       	LD	A,'0'
0122+  1D7D CD FF 28    	CALL	COUT
0123+  1D80 7E          	LD	A,(HL)
0124+  1D81 23          	INC	HL
0125+  1D82 CD 52 19    	CALL	PRTHEXBYTE
0126+  1D85 3E 2D       	LD	A,'-'
0127+  1D87 CD FF 28    	CALL	COUT
0128+  1D8A 7E          	LD	A,(HL)
0129+  1D8B 23          	INC	HL
0130+  1D8C CD 52 19    	CALL	PRTHEXBYTE
0131+  1D8F 3E 2D       	LD	A,'-'
0132+  1D91 CD FF 28    	CALL	COUT
0133+  1D94 7E          	LD	A,(HL)
0134+  1D95 23          	INC	HL
0135+  1D96 CD 52 19    	CALL	PRTHEXBYTE
0136+  1D99 CD D7 18    	CALL	PC_SPACE
0137+  1D9C 7E          	LD	A,(HL)
0138+  1D9D 23          	INC	HL
0139+  1D9E CD 52 19    	CALL	PRTHEXBYTE
0140+  1DA1 CD E1 18    	CALL	PC_COLON
0141+  1DA4 7E          	LD	A,(HL)
0142+  1DA5 23          	INC	HL
0143+  1DA6 CD 52 19    	CALL	PRTHEXBYTE
0144+  1DA9 CD E1 18    	CALL	PC_COLON
0145+  1DAC 7E          	LD	A,(HL)
0146+  1DAD 23          	INC	HL
0147+  1DAE CD 52 19    	CALL	PRTHEXBYTE
0148+  1DB1 C9          	RET
0149+  1DB2             ;
0150+  1DB2             ; PRINT DAY OF WEEK BASED ON A
0151+  1DB2             ;   0-6 IS SUN-SAT
0152+  1DB2             ;
0153+  1DB2             PRTDOW:
0154+  1DB2             	; BOUNDS CHECK FIRST
0155+  1DB2 FE 07       	CP	7		; MAX VALUE + 1
0156+  1DB4 D0          	RET	NC		; ABORT IF OUT OF RANGE!
0157+  1DB5 21 C2 1D    	LD	HL,DOWTBL
0158+  1DB8 CB 27       	SLA	A
0159+  1DBA CB 27       	SLA	A
0160+  1DBC CD D2 1A    	CALL	ADDHLA
0161+  1DBF C3 31 19    	JP	PRTSTR
0162+  1DC2             ;
0163+  1DC2 53 75 6E 24 DOWTBL		.DB	"Sun$", "Mon$", "Tue$", "Wed$"
0163+  1DC6 4D 6F 6E 24 
0163+  1DCA 54 75 65 24 
0163+  1DCE 57 65 64 24 
0164+  1DD2 54 68 75 24 		.DB	"Thu$", "Fri$", "Sat$"
0164+  1DD6 46 72 69 24 
0164+  1DDA 53 61 74 24 
0165+  1DDE             ;
0166+  1DDE             ; SET Z IF YEAR VALUE IN HL REPRESENTS A LEAP YEAR, ELSE NZ
0167+  1DDE             ; HL IS PRESERVED
0168+  1DDE             ;
0169+  1DDE             LEAP:
0170+  1DDE 11 04 00    	LD	DE,4
0171+  1DE1 CD FD 1D    	CALL	LEAPDIV
0172+  1DE4 20 12       	JR	NZ,NOLEAP	; IF YEAR NOT DIVISIBLE BY 4: NOT LEAP
0173+  1DE6 11 64 00    	LD	DE,100
0174+  1DE9 CD FD 1D    	CALL	LEAPDIV
0175+  1DEC 20 0D       	JR	NZ,ISLEAP	; ELSE IF YEAR NOT DIVISIBLE BY 100: LEAP
0176+  1DEE 11 90 01    	LD	DE,400
0177+  1DF1 CD FD 1D    	CALL	LEAPDIV
0178+  1DF4 28 05       	JR	Z,ISLEAP	; ELSE IF YEAR DIVISIBLE BY 400: LEAP
0179+  1DF6 18 00       	JR	NOLEAP		; OTHERWISE NOT LEAP
0180+  1DF8             ;
0181+  1DF8             NOLEAP:
0182+  1DF8 F6 FF       	OR	$FF		; NZ SIGNALS FALSE (NOT LEAP YEAR)
0183+  1DFA C9          	RET
0184+  1DFB             ;
0185+  1DFB             ISLEAP:
0186+  1DFB AF          	XOR	A		; ZF SIGNALS TRUE (IS LEAP YEAR)
0187+  1DFC C9          	RET
0188+  1DFD             ;
0189+  1DFD             LEAPDIV:
0190+  1DFD             	; SET Z FLAG BASED ON REMAINDER OF HL / DE
0191+  1DFD             	; PRESERVE HL
0192+  1DFD E5          	PUSH	HL
0193+  1DFE CD 57 1B    	CALL	DIV16
0194+  1E01             	;LD	A,H
0195+  1E01             	;OR	L
0196+  1E01 E1          	POP	HL
0197+  1E02 C9          	RET
6289   1E03             #INCLUDE "bcd.asm"
0001+  1E03             ;;
0002+  1E03             ;; MAKE A BCD NUMBER FROM A BINARY NUMBER
0003+  1E03             ;; 32 BIT BINARY NUMBER IN HL:BC, RESULT STORED AT (DE)
0004+  1E03             ;; DE IS PRESERVED, ALL OTHER REGS DESTROYED
0005+  1E03             ;;
0006+  1E03             ;BIN2BCD:
0007+  1E03             ;	PUSH	IX		; SAVE IX
0008+  1E03             ;	PUSH	BC		; MOVE BC
0009+  1E03             ;	POP	IX		; ... TO IX
0010+  1E03             ;	LD	C,32		; LOOP FOR 32 BITS OF BINARY DWORD
0011+  1E03             ;;
0012+  1E03             ;BIN2BCD0:
0013+  1E03             ;	; OUTER LOOP (ONCE FOR EACH BIT IN BINARY NUMBER)	
0014+  1E03             ;	LD	B,5		; LOOP FOR 5 BYTES OF RESULT
0015+  1E03             ;	PUSH	DE		; SAVE DE
0016+  1E03             ;	ADD	IX,IX		; LEFT SHIFT NEXT BIT FROM HL:IX
0017+  1E03             ;	ADC	HL,HL		; ... INTO CARRY
0018+  1E03             ;;
0019+  1E03             ;BIN2BCD1:
0020+  1E03             ;	; INNER LOOP (ONCE FOR EACH BYTE OF BCD NUMBER)
0021+  1E03             ;	LD	A,(DE)		; GET IT
0022+  1E03             ;	ADC	A,A		; DOUBLE IT W/ CARRY
0023+  1E03             ;	DAA			; DECIMAL ADJUST
0024+  1E03             ;	LD	(DE),A		; SAVE IT
0025+  1E03             ;	INC	DE		; POINT TO NEXT BCD BYTE
0026+  1E03             ;	DJNZ	BIN2BCD1	; LOOP THRU ALL BCD BYTES
0027+  1E03             ;;
0028+  1E03             ;	; REMAINDER OF OUTER LOOP
0029+  1E03             ;	POP	DE		; RECOVER DE
0030+  1E03             ;	DEC	C		; DEC BIT COUNTER
0031+  1E03             ;	JR	NZ,BIN2BCD0	; LOOP TILL DONE WITH ALL BITS
0032+  1E03             ;	POP	IX		; RESTORE IX
0033+  1E03             ;
0034+  1E03             ; MAKE A BCD NUMBER FROM A BINARY NUMBER
0035+  1E03             ; 32 BIT BINARY NUMBER IN DE:HL, RESULT STORED AT (BC)
0036+  1E03             ; ON OUTPUT HL = BCD BUF ADR
0037+  1E03             ;
0038+  1E03             BIN2BCD:
0039+  1E03 DD E5       	PUSH	IX		; SAVE IX
0040+  1E05             	; CONVERT FROM DE:HL -> (BC) TO HL:IX -> (DE)
0041+  1E05             	; HL -> IX, DE -> HL, BC -> DE
0042+  1E05 EB          	EX	DE,HL
0043+  1E06 D5          	PUSH	DE
0044+  1E07 DD E1       	POP	IX
0045+  1E09 C5          	PUSH	BC
0046+  1E0A D1          	POP	DE
0047+  1E0B             ;
0048+  1E0B 0E 20       	LD	C,32		; LOOP FOR 32 BITS OF BINARY DWORD
0049+  1E0D             ;
0050+  1E0D             BIN2BCD0:
0051+  1E0D             	; OUTER LOOP (ONCE FOR EACH BIT IN BINARY NUMBER)	
0052+  1E0D 06 05       	LD	B,5		; LOOP FOR 5 BYTES OF RESULT
0053+  1E0F D5          	PUSH	DE		; SAVE DE
0054+  1E10 DD 29       	ADD	IX,IX		; LEFT SHIFT NEXT BIT FROM HL:IX
0055+  1E12 ED 6A       	ADC	HL,HL		; ... INTO CARRY
0056+  1E14             ;
0057+  1E14             BIN2BCD1:
0058+  1E14             	; INNER LOOP (ONCE FOR EACH BYTE OF BCD NUMBER)
0059+  1E14 1A          	LD	A,(DE)		; GET IT
0060+  1E15 8F          	ADC	A,A		; DOUBLE IT W/ CARRY
0061+  1E16 27          	DAA			; DECIMAL ADJUST
0062+  1E17 12          	LD	(DE),A		; SAVE IT
0063+  1E18 13          	INC	DE		; POINT TO NEXT BCD BYTE
0064+  1E19 10 F9       	DJNZ	BIN2BCD1	; LOOP THRU ALL BCD BYTES
0065+  1E1B             ;
0066+  1E1B             	; REMAINDER OF OUTER LOOP
0067+  1E1B D1          	POP	DE		; RECOVER DE
0068+  1E1C 0D          	DEC	C		; DEC BIT COUNTER
0069+  1E1D 20 EE       	JR	NZ,BIN2BCD0	; LOOP TILL DONE WITH ALL BITS
0070+  1E1F EB          	EX	DE,HL		; HL -> BCD BUF
0071+  1E20 DD E1       	POP	IX		; RESTORE IX
0072+  1E22 C9          	RET
0073+  1E23             ;
0074+  1E23             ; PRINT CONTENTS OF 5 BYTE BCD NUMBER AT (HL)
0075+  1E23             ; WITH LEADING ZERO SUPPRESSION
0076+  1E23             ; ALL REGS DESTROYED
0077+  1E23             ;
0078+  1E23             PRTBCD:
0079+  1E23 23          	INC	HL		; BUMP HL TO POINT TO
0080+  1E24 23          	INC	HL		; ...
0081+  1E25 23          	INC	HL		; ...
0082+  1E26 23          	INC	HL		; ... LAST BYTE OF BCD
0083+  1E27 06 05       	LD	B,5		; LOOP FOR 5 BYTES
0084+  1E29 0E 00       	LD	C,0		; START BY SUPPRESSING LEADING ZEROES
0085+  1E2B             ;
0086+  1E2B             PRTBCD1:
0087+  1E2B             	; LOOP TO PRINT ONE BCD BYTE (TWO DIGITS)
0088+  1E2B AF          	XOR	A		; CLEAR ACCUM
0089+  1E2C ED 6F       	RLD			; ROTATE FIRST NIBBLE INTO A
0090+  1E2E CD 3B 1E    	CALL	PRTBCD2		; PRINT IT
0091+  1E31 AF          	XOR	A		; CLEAR ACCUM
0092+  1E32 ED 6F       	RLD			; ROTATE SECOND NIBBLE INTO A
0093+  1E34 CD 3B 1E    	CALL	PRTBCD2		; PRINT IT
0094+  1E37 2B          	DEC	HL		; POINT TO PRIOR BYTE
0095+  1E38 10 F1       	DJNZ	PRTBCD1		; LOOP TILL DONE
0096+  1E3A C9          	RET			; RETURN
0097+  1E3B             ;
0098+  1E3B             PRTBCD2:
0099+  1E3B             	; SUBROUTINE TO PRINT A DIGIT IN A
0100+  1E3B B9          	CP	C		; COMPARE INCOMING TO C
0101+  1E3C C8          	RET	Z		; IF EQUAL, SUPPRESSING, ABORT
0102+  1E3D 0D          	DEC	C		; MAKE C NEGATIVE TO STOP SUPPRESSION
0103+  1E3E C6 30       	ADD	A,'0'		; OFFSET TO PRINTABLE VALUE
0104+  1E40 C3 FF 28    	JP	COUT		; EXIT VIA CHARACTER OUT
6290   1E43             #INCLUDE "decode.asm"
0001+  1E43             ;
0002+  1E43             ;==================================================================================================
0003+  1E43             ; DECODE 32-BIT VALUES FROM A 5-BIT SHIFT-ENCODED VALUE
0004+  1E43             ;==================================================================================================
0005+  1E43             ;
0006+  1E43             ;   Copyright (C) 2014 John R. Coffman.  All rights reserved.
0007+  1E43             ;   Provided for hobbyist use on the Z180 SBC Mark IV board.
0008+  1E43             ;
0009+  1E43             ; This program is free software: you can redistribute it and/or modify
0010+  1E43             ; it under the terms of the GNU General Public License as published by
0011+  1E43             ; the Free Software Foundation, either version 3 of the License, or
0012+  1E43             ; (at your option) any later version.
0013+  1E43             ;
0014+  1E43             ; This program is distributed in the hope that it will be useful,
0015+  1E43             ; but WITHOUT ANY WARRANTY; without even the implied warranty of
0016+  1E43             ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
0017+  1E43             ; GNU General Public License for more details.
0018+  1E43             ;
0019+  1E43             ; You should have received a copy of the GNU General Public License
0020+  1E43             ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
0021+  1E43             ;
0022+  1E43             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0023+  1E43             ;
0024+  1E43             ; THE FUNCTION(S) IN THIS FILE ARE BASED ON LIKE FUNCTIONS CREATED BY JOHN COFFMAN
0025+  1E43             ; IN HIS UNA BIOS PROJECT.  THEY ARE INCLUDED HERE BASED ON GPLV3 PERMISSIBLE USE.
0026+  1E43             ;
0027+  1E43             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  1E43             ;
0029+  1E43             ; An encoded value (V) is defined as V = C * 2^X * 3^Y
0030+  1E43             ; where C is a prearranged constant, X is 0 or 1 and Y is 0-15
0031+  1E43             ; The encoded value is stored as 5 bits: YXXXX
0032+  1E43             ; At present, C=75 for baud rate encoding and C=3 for CPU OSC encoding
0033+  1E43             ;
0034+  1E43             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0035+  1E43             ;  DECODE
0036+  1E43             ;
0037+  1E43             ; Enter with:
0038+  1E43             ;	HL	=  word to be decoded (5-bits)    FXXXX
0039+  1E43             ;		   F=extra 3 factor, XXXX=shift factor, reg H must be zero
0040+  1E43             ;	DE	=  encode divisor OSC_DIV = 3, or BAUD_DIV = 75
0041+  1E43             ;
0042+  1E43             ; Exit with:
0043+  1E43             ;	DE:HL	=  decoded value
0044+  1E43             ;       A	=  non-zero on error
0045+  1E43             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0046+  1E43             ;
0047+  1E43             DECODE:
0048+  1E43 7C          	LD	A,H			; SET TO TEST
0049+  1E44 0E FF       	LD	C,$FF			; PRESUME ERROR CONDITION
0050+  1E46 B7          	OR	A			; TEST FOR ZERO
0051+  1E47 20 20       	JR	NZ,DECODE9		; NOT AN ENCODED VALUE
0052+  1E49 7D          	LD	A,L			; GET LOW ORDER 5 BITS
0053+  1E4A FE 20       	CP	32			; TEST FOR ERROR
0054+  1E4C 30 1B       	JR	NC,DECODE9		; ERROR RETURN IF NOT BELOW
0055+  1E4E             	; ARGUMENT HL IS VALIDATED
0056+  1E4E 62          	LD	H,D
0057+  1E4F 6B          	LD	L,E			; COPY TO HL
0058+  1E50 FE 10       	CP	16	
0059+  1E52 38 02       	JR	C,DECODE2		; IF < 16, NO 3 FACTOR
0060+  1E54 19          	ADD	HL,DE			; INTRODUCE FACTOR OF 3
0061+  1E55 19          	ADD	HL,DE			; **
0062+  1E56             DECODE2:	
0063+  1E56 11 00 00    	LD	DE,0			; ZERO THE HIGH ORDER
0064+  1E59 E6 0F       	AND	15			; MASK TO 4 BITS
0065+  1E5B 28 0A       	JR	Z,DECODE8		; GOOD EXIT
0066+  1E5D 48          	LD	C,B			; SAVE B-REG
0067+  1E5E 47          	LD	B,A			;
0068+  1E5F             DECODE3:	
0069+  1E5F 29          	ADD	HL,HL			; SHIFT LEFT BY 1, SET CARRY
0070+  1E60 CB 13       	RL	E	
0071+  1E62 CB 12       	RL	D			; **
0072+  1E64 10 F9       	DJNZ	DECODE3	
0073+  1E66 41          	LD	B,C			; RESTORE B-REG
0074+  1E67             DECODE8:	
0075+  1E67 0E 00       	LD	C,0			; SIGNAL GOOD RETURN
0076+  1E69             DECODE9:	
0077+  1E69 79          	LD	A,C			; ERROR CODE TEST
0078+  1E6A B7          	OR	A			; ERROR CODE IN REG-C AND Z-FLAG
0079+  1E6B C9          	RET
6291   1E6C             #INCLUDE "encode.asm"
0001+  1E6C             ;
0002+  1E6C             ;==================================================================================================
0003+  1E6C             ; ENCODE 32-BIT VALUES TO A 5-BIT SHIFT-ENCODED VALUE
0004+  1E6C             ;==================================================================================================
0005+  1E6C             ;
0006+  1E6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007+  1E6C             ;
0008+  1E6C             ; An encoded value (V) is defined as V = C * 2^X * 3^Y
0009+  1E6C             ; where C is a prearranged constant, Y is 0 or 1 and X is 0-15
0010+  1E6C             ; The encoded value is stored as 5 bits: YXXXX
0011+  1E6C             ; At present, C=75 for baud rate encoding and C=3 for CPU OSC encoding
0012+  1E6C             ;
0013+  1E6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1E6C             ;  ENCODE
0015+  1E6C             ;
0016+  1E6C             ; Enter with:
0017+  1E6C             ;	DE:HL	=  dword value to be encoded
0018+  1E6C             ;	C	=  divisor (0 < C < 256)
0019+  1E6C             ;		   encode divisor OSC_DIV = 3, or BAUD_DIV = 75
0020+  1E6C             ;
0021+  1E6C             ; Exit with:
0022+  1E6C             ;	C	=  encoded value
0023+  1E6C             ;       A	=  non-zero on error
0024+  1E6C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0025+  1E6C             ;
0026+  1E6C             ENCODE:
0027+  1E6C             	; INCOMING VALUE OF ZERO IS A FAILURE
0028+  1E6C CD 9D 1E    	CALL	ENCODE5			; TEST DE:HL FOR ZERO
0029+  1E6F 28 29       	JR	Z,ENCODE4		; IF ZERO, FAILURE RETURN
0030+  1E71             ;
0031+  1E71             	; APPLY ENCODING DIVISOR
0032+  1E71 CD 70 1B    	CALL	DIV32X8			; DE:HL / C (REMAINDER IN A)
0033+  1E74 B7          	OR	A			; SET FLAGS TO TEST FOR ZERO
0034+  1E75 C0          	RET	NZ			; ERROR IF NOT EVENLY DIVISIBLE
0035+  1E76             ;
0036+  1E76             	; TEST DIVIDE BY 3 TO SEE IF IT IS POSSIBLE
0037+  1E76 D5          	PUSH	DE			; SAVE WORKING
0038+  1E77 E5          	PUSH	HL			; ... VALUE
0039+  1E78 0E 03       	LD	C,3			; DIVIDE BY 3
0040+  1E7A CD 70 1B    	CALL	DIV32X8			; ... TEST
0041+  1E7D E1          	POP	HL			; RESTORE WORKING
0042+  1E7E D1          	POP	DE			; ... VALUE
0043+  1E7F             ;
0044+  1E7F             	; IMPLMEMENT DIVIDE BY 3 IF POSSIBLE
0045+  1E7F 0E 00       	LD	C,$00			; INIT RESULT IN C W/ DEV 3 FLAG CLEAR
0046+  1E81 B7          	OR	A			; SET FLAGS TO TEST FOR REMAINDER
0047+  1E82 20 07       	JR	NZ,ENCODE2		; JUMP IF IT FAILED
0048+  1E84             ;
0049+  1E84             	; IF DIVIDE BY 3 WORKED, DO IT AGAIN FOR REAL
0050+  1E84 0E 03       	LD	C,3			; SETUP TO DIVIDE BY 3 AGAIN
0051+  1E86 CD 70 1B    	CALL	DIV32X8			; DO IT
0052+  1E89 0E 10       	LD	C,$10			; INIT RESULT IN C W/ DIV 3 FLAG SET
0053+  1E8B             ;
0054+  1E8B             ENCODE2:
0055+  1E8B             	; LOOP TO DETERMINE POWER OF 2
0056+  1E8B 06 10       	LD	B,16			; CAN ONLY REPRESENT UP TO 2^15
0057+  1E8D             ENCODE3:
0058+  1E8D CB 3A       	SRL	D			; RIGHT SHIFT DE:HL INTO CARRY
0059+  1E8F CB 1B       	RR	E			; ...
0060+  1E91 CB 1C       	RR	H			; ...
0061+  1E93 CB 1D       	RR	L			; ...
0062+  1E95 38 06       	JR	C,ENCODE5		; IF CARRY, THEN DONE, C HAS RESULT
0063+  1E97 0C          	INC	C			; BUMP THE RESULT VALUE
0064+  1E98 10 F3       	DJNZ	ENCODE3			; KEEP SHIFTING IF POSSIBLE
0065+  1E9A             ENCODE4:
0066+  1E9A F6 FF       	OR	$FF			; SIGNAL ERROR
0067+  1E9C C9          	RET				; AND DONE
0068+  1E9D             ;
0069+  1E9D             ENCODE5:
0070+  1E9D             	; TEST DE:HL FOR ZERO (SETS ZF, CLOBBERS A)
0071+  1E9D 7C          	LD	A,H
0072+  1E9E B5          	OR	L
0073+  1E9F B2          	OR	D
0074+  1EA0 B3          	OR	E
0075+  1EA1 C9          	RET				; RET W/ Z SET IF DE:HL == 0
6292   1EA2             ;
6293   1EA2~            #IF (WBWDEBUG == USEXIO)
6294   1EA2~            #INCLUDE "xio.asm"
6295   1EA2             #ENDIF
6296   1EA2~            #IF (WBWDEBUG == USEMIO)
6297   1EA2~            #INCLUDE "mio.asm"
6298   1EA2             #ENDIF
6299   1EA2             ;
6300   1EA2~            #IF (DSKYENABLE)
6301   1EA2~            #DEFINE	DSKY_KBD
6302   1EA2~              #IF (DSKYMODE == DSKYMODE_V1)
6303   1EA2~            #INCLUDE "dsky.asm"
6304   1EA2~              #ENDIF
6305   1EA2~              #IF (DSKYMODE == DSKYMODE_NG)
6306   1EA2~            #INCLUDE "dskyng.asm"
6307   1EA2~              #ENDIF
6308   1EA2             #ENDIF
6309   1EA2             ;
6310   1EA2             #IF (H8FPENABLE)
6311   1EA2             #INCLUDE "h8p.asm"
0001+  1EA2             ;
0002+  1EA2             ;==================================================================================================
0003+  1EA2             ; HEATH H8 FRONT PANEL (DISPLAY AND KEYBOARD) ROUTINES
0004+  1EA2             ;==================================================================================================
0005+  1EA2             ;
0006+  1EA2             ; LED SEGMENTS (BIT VALUES)
0007+  1EA2             ;
0008+  1EA2             ;	+--02--+
0009+  1EA2             ;	40    04
0010+  1EA2             ;	+--01--+
0011+  1EA2             ;	20    08
0012+  1EA2             ;	+--10--+  80
0013+  1EA2             ;
0014+  1EA2             H8PKEYNONE	.EQU	$FF		; NONE
0015+  1EA2             H8PKEY0		.EQU	$FE
0016+  1EA2             H8PKEY1		.EQU	$FC
0017+  1EA2             H8PKEY2		.EQU	$FA
0018+  1EA2             H8PKEY3		.EQU	$F8
0019+  1EA2             H8PKEY4		.EQU	$F6
0020+  1EA2             H8PKEY5		.EQU	$F4
0021+  1EA2             H8PKEY6		.EQU	$F2
0022+  1EA2             H8PKEY7		.EQU	$F0
0023+  1EA2             H8PKEY8		.EQU	$EF
0024+  1EA2             H8PKEY9		.EQU	$CF
0025+  1EA2             H8PKEYPLUS	.EQU	$AF		; PLUS
0026+  1EA2             H8PKEYMINUS	.EQU	$8F		; MINUS
0027+  1EA2             H8PKEYMUL	.EQU	$6F		; MULTIPLY
0028+  1EA2             H8PKEYDIV	.EQU	$4F		; DIVIDE
0029+  1EA2             H8PKEYNUM	.EQU	$2F		; NUMBER
0030+  1EA2             H8PKEYDOT	.EQU	$0F		; DOT
0031+  1EA2             ;
0032+  1EA2             FPLED_IO	.EQU	$F0
0033+  1EA2             FPSW_IO		.EQU	$F0
0034+  1EA2             ;
0035+  1EA2             ;__H8P_PREINIT_______________________________________________________________________________________
0036+  1EA2             ;
0037+  1EA2             ;  CONFIGURE AND RESET PANEL
0038+  1EA2             ;____________________________________________________________________________________________________
0039+  1EA2             ;
0040+  1EA2             ; HARDWARE RESET PRIOR TO ROMWBW CONSOLE INITIALIZATION
0041+  1EA2             ;
0042+  1EA2             H8P_PREINIT:
0043+  1EA2             ;
0044+  1EA2             #IF (INTMODE == 1)
0045+  1EA2 21 C4 1E    	LD	HL,H8P_STAT
0046+  1EA5 CD 98 0C    	CALL	HB_ADDIM1		; ADD TO IM1 CALL LIST
0047+  1EA8             #ENDIF
0048+  1EA8             ;
0049+  1EA8 C9          	RET
0050+  1EA9             ;
0051+  1EA9             ;__H8P_INIT__________________________________________________________________________________________
0052+  1EA9             ;
0053+  1EA9             ;  DISPLAY DSKY INFO ON ROMWBW CONSOLE
0054+  1EA9             ;____________________________________________________________________________________________________
0055+  1EA9             ;
0056+  1EA9             H8P_INIT:
0057+  1EA9 CD 20 19    	CALL	NEWLINE			; FORMATTING
0058+  1EAC CD 3B 19    	PRTS("H8P:$")			; DRIVER TAG
0058+  1EAF 48 38 50 3A 
0058+  1EB3 24 
0059+  1EB4             ;
0060+  1EB4 CD 3B 19    	PRTS(" IO=0x$")			; FORMATTING
0060+  1EB7 20 49 4F 3D 
0060+  1EBB 30 78 24 
0061+  1EBE 3E F0       	LD	A,FPLED_IO		; GET BASE PORT
0062+  1EC0 CD 52 19    	CALL	PRTHEXBYTE		; PRINT BASE PORT
0063+  1EC3             ;
0064+  1EC3 C9          	RET				; DONE
0065+  1EC4             ;
0066+  1EC4             ;  INTERRUPT ENTRY POINT
0067+  1EC4             ;
0068+  1EC4             H8P_STAT:
0069+  1EC4 2A 4E 23    	LD	HL,(H8P_TICCNT)
0070+  1EC7 23          	INC	HL
0071+  1EC8 22 4E 23    	LD	(H8P_TICCNT),HL
0072+  1ECB 3A 26 23    	LD	A,(H8P_ENABLE)
0073+  1ECE B7          	OR	A
0074+  1ECF 28 18       	JR	Z,H8P_STAT1
0075+  1ED1             ;
0076+  1ED1 7D          	LD	A,L
0077+  1ED2 E6 1F       	AND	$1F
0078+  1ED4 CC 50 1F    	CALL	Z,H8P_UPDREGS		; UPDATE VALUES EVERY 32 INTS
0079+  1ED7 3A 5B 23    	LD	A,(H8P_LASTKEY)
0080+  1EDA 4F          	LD	C,A
0081+  1EDB DB F0       	IN	A,(FPSW_IO)		; READ KEYPAD
0082+  1EDD B9          	CP	C
0083+  1EDE C4 60 20    	CALL	NZ,H8P_HDLKEY		; HANDLE KEYPAD FUNCTIONS
0084+  1EE1 CD F6 22    	CALL	H8P_SPEAKER
0085+  1EE4 CD 19 1F    	CALL	H8P_UPDLEDS
0086+  1EE7 18 1D       	JR	H8P_STAT2
0087+  1EE9             H8P_STAT1:
0088+  1EE9 CD F6 22    	CALL	H8P_SPEAKER
0089+  1EEC 3E 50       	LD	A,$50
0090+  1EEE B1          	OR	C
0091+  1EEF D3 F0       	OUT	(FPLED_IO),A
0092+  1EF1 3E FF       	LD	A,$FF
0093+  1EF3 D3 F1       	OUT	(FPLED_IO+1),A
0094+  1EF5 3A 5B 23    	LD	A,(H8P_LASTKEY)
0095+  1EF8 4F          	LD	C,A
0096+  1EF9 DB F0       	IN	A,(FPSW_IO)
0097+  1EFB B9          	CP	C
0098+  1EFC 28 08       	JR	Z,H8P_STAT2
0099+  1EFE 32 5B 23    	LD	(H8P_LASTKEY),A
0100+  1F01 FE 6F       	CP	H8PKEYMUL
0101+  1F03 CC CA 21    	CALL	Z,H8P_HDLKEYMUL
0102+  1F06             ;
0103+  1F06             H8P_STAT2:
0104+  1F06 3A 50 23    	LD	A,(H8P_HBTICK)
0105+  1F09 3C          	INC	A
0106+  1F0A 32 50 23    	LD	(H8P_HBTICK),A
0107+  1F0D FE 0A       	CP	$0A			; CALL HB_TICK EVERY 10 INTERRUPTS (50HZ)
0108+  1F0F C0          	RET	NZ			; NOT TIME THEN JUST RETURN
0109+  1F10 CD B4 0C    	CALL	HB_TICK
0110+  1F13 AF          	XOR	A
0111+  1F14 32 50 23    	LD	(H8P_HBTICK),A		; RESET HBTICK COUNTER
0112+  1F17 3C          	INC	A			; INTERRUPT HANDLED
0113+  1F18 C9          	RET
0114+  1F19             ;
0115+  1F19             H8P_UPDLEDS:
0116+  1F19 0E 80       	LD	C,$80			; SPEAKER OFF
0117+  1F1B 3A 5C 23    	LD	A,(H8P_SPKDLY)
0118+  1F1E B7          	OR	A
0119+  1F1F 28 02       	JR	Z,H8P_UPDLEDS0
0120+  1F21 0E 00       	LD	C,0			; SPEAKER ON
0121+  1F23             H8P_UPDLEDS0:
0122+  1F23 3A 5A 23    	LD	A,(H8P_LEDNUM)
0123+  1F26 3C          	INC	A
0124+  1F27 32 5A 23    	LD	(H8P_LEDNUM),A
0125+  1F2A FE 0A       	CP	$0A
0126+  1F2C 20 05       	JR	NZ,H8P_UPDLEDS1
0127+  1F2E 3E 01       	LD	A,1
0128+  1F30 32 5A 23    	LD	(H8P_LEDNUM),A
0129+  1F33             H8P_UPDLEDS1:
0130+  1F33 3A 5A 23    	LD	A,(H8P_LEDNUM)
0131+  1F36 5F          	LD	E,A
0132+  1F37 F6 50       	OR	$50			; MON LIGHT OFF 0101.XXXX
0133+  1F39 B1          	OR	C			; SPEAKER 1000.000 = OFF / 0000.0000 = ON
0134+  1F3A D3 F0       	OUT	(FPLED_IO),A		; SELECT DIGIT (1 THRU 9)
0135+  1F3C 21 51 23    	LD	HL,H8P_LEDPAT
0136+  1F3F 1D          	DEC	E
0137+  1F40 16 00       	LD	D,0
0138+  1F42 19          	ADD	HL,DE			; HL = POINTER TO LED PATTERN
0139+  1F43 7E          	LD	A,(HL)
0140+  1F44 2F          	CPL				; COMPLEMENT PATTERN
0141+  1F45 E6 7F       	AND	$7F			; TURN ON DOT
0142+  1F47 F5          	PUSH	AF
0143+  1F48 CD DD 22    	CALL	H8P_GETDOT		; DETERMINE IF DOT SHOULD BE ON/OFF
0144+  1F4B F1          	POP	AF
0145+  1F4C B1          	OR	C
0146+  1F4D D3 F1       	OUT	(FPLED_IO+1),A		; SELECT SEGMENTS
0147+  1F4F C9          	RET
0148+  1F50             ; UPDATE REGISTER VALUES
0149+  1F50             H8P_UPDREGS:
0150+  1F50 2A 28 FF    	LD	HL,(HBX_INT_SP)
0151+  1F53 22 4A 23    	LD	(H8P_SPVAL),HL
0152+  1F56 5E          	LD	E,(HL)		; L
0153+  1F57 2B          	DEC	HL
0154+  1F58 56          	LD	D,(HL)		; H
0155+  1F59 2B          	DEC	HL
0156+  1F5A ED 53 48 23 	LD	(H8P_HLVAL),DE
0157+  1F5E 5E          	LD	E,(HL)		; PC LOW
0158+  1F5F 2B          	DEC	HL
0159+  1F60 56          	LD	D,(HL)		; PC HI
0160+  1F61 ED 53 4C 23 	LD	(H8P_PCVAL),DE
0161+  1F65 21 00 FF    	LD	HL,HBX_INTSTK
0162+  1F68 2B          	DEC	HL		; IY LOW
0163+  1F69 2B          	DEC	HL		; IY HIGH
0164+  1F6A 5E          	LD	E,(HL)		; E
0165+  1F6B 2B          	DEC	HL
0166+  1F6C 56          	LD	D,(HL)		; D
0167+  1F6D 2B          	DEC	HL
0168+  1F6E ED 53 46 23 	LD	(H8P_DEVAL),DE
0169+  1F72 5E          	LD	E,(HL)		; C
0170+  1F73 2B          	DEC	HL
0171+  1F74 56          	LD	D,(HL)		; B
0172+  1F75 2B          	DEC	HL
0173+  1F76 ED 53 44 23 	LD	(H8P_BCVAL),DE
0174+  1F7A 5E          	LD	E,(HL)		; AF LOW
0175+  1F7B 2B          	DEC	HL
0176+  1F7C 56          	LD	D,(HL)		; AF HIGH
0177+  1F7D ED 53 42 23 	LD	(H8P_AFVAL),DE
0178+  1F81 CD 85 1F    	CALL	H8P_UPDPATS
0179+  1F84 C9          	RET
0180+  1F85             ; UPDATE LED PATTERN ARRAY
0181+  1F85             H8P_UPDPATS:
0182+  1F85 3A 27 23    	LD	A,(H8P_DISPMODE)
0183+  1F88 FE 01       	CP	$01
0184+  1F8A C8          	RET	Z
0185+  1F8B FE 02       	CP	$02
0186+  1F8D CA E7 1F    	JP	Z,H8P_UPDPATS2
0187+  1F90 FE 03       	CP	$03
0188+  1F92 CA FD 1F    	JP	Z,H8P_UPDPATS3
0189+  1F95 2A 2E 23    	LD	HL,(H8P_CURVAL)
0190+  1F98 4D          	LD	C,L
0191+  1F99 44          	LD	B,H
0192+  1F9A 3A 28 23    	LD	A,(H8P_MEMMODE)
0193+  1F9D B7          	OR	A
0194+  1F9E 20 03       	JR	NZ,H8P_UPDPATS1
0195+  1FA0 4E          	LD	C,(HL)
0196+  1FA1 23          	INC	HL
0197+  1FA2 46          	LD	B,(HL)
0198+  1FA3             H8P_UPDPATS1:
0199+  1FA3 78          	LD	A,B
0200+  1FA4 CD C1 22    	CALL	H8P_GETOCTH	; CONVERT A TO HIGH OCTAL BITS (1100.0000)
0201+  1FA7 CD 14 20    	CALL	H8P_SETDIG0	; SET PATTERN
0202+  1FAA 78          	LD	A,B
0203+  1FAB CD CB 22    	CALL	H8P_GETOCTM	; CONVERT A TO MEDIUM OCTAL BITS (0011.1000)
0204+  1FAE CD 19 20    	CALL	H8P_SETDIG1
0205+  1FB1 78          	LD	A,B
0206+  1FB2 CD D2 22    	CALL	H8P_GETOCTL	; CONVERT A TO LOW OCTAL BITS (0000.0111)
0207+  1FB5 CD 1E 20    	CALL	H8P_SETDIG2
0208+  1FB8 79          	LD	A,C
0209+  1FB9 CD C1 22    	CALL	H8P_GETOCTH
0210+  1FBC CD 23 20    	CALL	H8P_SETDIG3
0211+  1FBF 79          	LD	A,C
0212+  1FC0 CD CB 22    	CALL	H8P_GETOCTM
0213+  1FC3 CD 28 20    	CALL	H8P_SETDIG4
0214+  1FC6 79          	LD	A,C
0215+  1FC7 CD D2 22    	CALL	H8P_GETOCTL
0216+  1FCA CD 2D 20    	CALL	H8P_SETDIG5
0217+  1FCD 3A 28 23    	LD	A,(H8P_MEMMODE)
0218+  1FD0 B7          	OR	A
0219+  1FD1 C2 41 20    	JP	NZ,H8P_UPDMEM
0220+  1FD4 ED 4B 2C 23 	LD	BC,(H8P_CURREG)	; PATTERNS FOR CURRENT REGISTER (AF,BC,ETC.)
0221+  1FD8 0A          	LD	A,(BC)
0222+  1FD9 CD 32 20    	CALL	H8P_SETDIG6
0223+  1FDC 03          	INC	BC
0224+  1FDD 0A          	LD	A,(BC)
0225+  1FDE CD 37 20    	CALL	H8P_SETDIG7
0226+  1FE1 03          	INC	BC
0227+  1FE2 0A          	LD	A,(BC)
0228+  1FE3 CD 3C 20    	CALL	H8P_SETDIG8
0229+  1FE6 C9          	RET
0230+  1FE7             ; BLANK THE DISPLAYS
0231+  1FE7             H8P_UPDPATS2:
0232+  1FE7 21 51 23    	LD	HL,H8P_LEDPAT
0233+  1FEA AF          	XOR	A
0234+  1FEB 77          	LD	(HL),A
0235+  1FEC 23          	INC	HL
0236+  1FED 77          	LD	(HL),A
0237+  1FEE 23          	INC	HL
0238+  1FEF 77          	LD	(HL),A
0239+  1FF0 23          	INC	HL
0240+  1FF1 77          	LD	(HL),A
0241+  1FF2 23          	INC	HL
0242+  1FF3 77          	LD	(HL),A
0243+  1FF4 23          	INC	HL
0244+  1FF5 77          	LD	(HL),A
0245+  1FF6 23          	INC	HL
0246+  1FF7 77          	LD	(HL),A
0247+  1FF8 23          	INC	HL
0248+  1FF9 77          	LD	(HL),A
0249+  1FFA 23          	INC	HL
0250+  1FFB 77          	LD	(HL),A
0251+  1FFC C9          	RET
0252+  1FFD             ; TURN ON ALL SEGMENTS
0253+  1FFD             H8P_UPDPATS3:
0254+  1FFD 21 51 23    	LD	HL,H8P_LEDPAT
0255+  2000 3E FF       	LD	A,$FF
0256+  2002 77          	LD	(HL),A
0257+  2003 23          	INC	HL
0258+  2004 77          	LD	(HL),A
0259+  2005 23          	INC	HL
0260+  2006 77          	LD	(HL),A
0261+  2007 23          	INC	HL
0262+  2008 77          	LD	(HL),A
0263+  2009 23          	INC	HL
0264+  200A 77          	LD	(HL),A
0265+  200B 23          	INC	HL
0266+  200C 77          	LD	(HL),A
0267+  200D 23          	INC	HL
0268+  200E 77          	LD	(HL),A
0269+  200F 23          	INC	HL
0270+  2010 77          	LD	(HL),A
0271+  2011 23          	INC	HL
0272+  2012 77          	LD	(HL),A
0273+  2013 C9          	RET
0274+  2014             ;
0275+  2014             H8P_SETDIG0:
0276+  2014 21 51 23    	LD	HL,H8P_LEDPAT
0277+  2017 18 26       	JR	H8P_SETDIGX
0278+  2019             H8P_SETDIG1:
0279+  2019 21 52 23    	LD	HL,H8P_LEDPAT+1
0280+  201C 18 21       	JR	H8P_SETDIGX
0281+  201E             H8P_SETDIG2:
0282+  201E 21 53 23    	LD	HL,H8P_LEDPAT+2
0283+  2021 18 1C       	JR	H8P_SETDIGX
0284+  2023             H8P_SETDIG3:
0285+  2023 21 54 23    	LD	HL,H8P_LEDPAT+3
0286+  2026 18 17       	JR	H8P_SETDIGX
0287+  2028             H8P_SETDIG4:
0288+  2028 21 55 23    	LD	HL,H8P_LEDPAT+4
0289+  202B 18 12       	JR	H8P_SETDIGX
0290+  202D             H8P_SETDIG5:
0291+  202D 21 56 23    	LD	HL,H8P_LEDPAT+5
0292+  2030 18 0D       	JR	H8P_SETDIGX
0293+  2032             H8P_SETDIG6:
0294+  2032 21 57 23    	LD	HL,H8P_LEDPAT+6
0295+  2035 18 08       	JR	H8P_SETDIGX
0296+  2037             H8P_SETDIG7:
0297+  2037 21 58 23    	LD	HL,H8P_LEDPAT+7
0298+  203A 18 03       	JR	H8P_SETDIGX
0299+  203C             H8P_SETDIG8:
0300+  203C 21 59 23    	LD	HL,H8P_LEDPAT+8
0301+  203F             H8P_SETDIGX:
0302+  203F 77          	LD	(HL),A
0303+  2040 C9          	RET
0304+  2041             ; UPDATE MEMORY LOCATION VALUE
0305+  2041             H8P_UPDMEM:
0306+  2041 3A 27 23    	LD	A,(H8P_DISPMODE)
0307+  2044 B7          	OR	A
0308+  2045 C0          	RET	NZ
0309+  2046 2A 2E 23    	LD	HL,(H8P_CURVAL)
0310+  2049 7E          	LD	A,(HL)
0311+  204A 4F          	LD	C,A
0312+  204B CD C1 22    	CALL	H8P_GETOCTH
0313+  204E CD 32 20    	CALL	H8P_SETDIG6
0314+  2051 79          	LD	A,C
0315+  2052 CD CB 22    	CALL	H8P_GETOCTM
0316+  2055 CD 37 20    	CALL	H8P_SETDIG7
0317+  2058 79          	LD	A,C
0318+  2059 CD D2 22    	CALL	H8P_GETOCTL
0319+  205C CD 3C 20    	CALL	H8P_SETDIG8
0320+  205F C9          	RET
0321+  2060             ; HANDLE KEYPAD INPUT
0322+  2060             H8P_HDLKEY:
0323+  2060 32 5B 23    	LD	(H8P_LASTKEY),A
0324+  2063 FE FF       	CP	H8PKEYNONE	; NO KEY PRESSED
0325+  2065 C8          	RET	Z
0326+  2066 F5          	PUSH	AF
0327+  2067 CD 04 23    	CALL	H8P_CLICK
0328+  206A F1          	POP	AF
0329+  206B FE CF       	CP	H8PKEY9
0330+  206D CA 96 21    	JP	Z,H8P_HDLKEY9
0331+  2070 4F          	LD	C,A
0332+  2071 3A 27 23    	LD	A,(H8P_DISPMODE)
0333+  2074 B7          	OR	A
0334+  2075 C0          	RET	NZ
0335+  2076 79          	LD	A,C
0336+  2077 FE FE       	CP	H8PKEY0
0337+  2079 CA DB 20    	JP	Z,H8P_HDLKEY0
0338+  207C FE FC       	CP	H8PKEY1
0339+  207E CA E6 20    	JP	Z,H8P_HDLKEY1
0340+  2081 FE FA       	CP	H8PKEY2
0341+  2083 CA 00 21    	JP	Z,H8P_HDLKEY2
0342+  2086 FE F8       	CP	H8PKEY3
0343+  2088 CA 1B 21    	JP	Z,H8P_HDLKEY3
0344+  208B FE F6       	CP	H8PKEY4
0345+  208D CA 36 21    	JP	Z,H8P_HDLKEY4
0346+  2090 FE F4       	CP	H8PKEY5
0347+  2092 CA 51 21    	JP	Z,H8P_HDLKEY5
0348+  2095 FE F2       	CP	H8PKEY6
0349+  2097 CA 6C 21    	JP	Z,H8P_HDLKEY6
0350+  209A FE F0       	CP	H8PKEY7
0351+  209C CA 87 21    	JP	Z,H8P_HDLKEY7
0352+  209F FE EF       	CP	H8PKEY8
0353+  20A1 CA 91 21    	JP	Z,H8P_HDLKEY8
0354+  20A4 FE AF       	CP	H8PKEYPLUS
0355+  20A6 CA A4 21    	JP	Z,H8P_HDLKEYPLUS
0356+  20A9 FE 8F       	CP	H8PKEYMINUS
0357+  20AB CA B7 21    	JP	Z,H8P_HDLKEYMINUS
0358+  20AE FE 4F       	CP	H8PKEYDIV
0359+  20B0 CA D4 21    	JP	Z,H8P_HDLKEYDIV
0360+  20B3 FE 6F       	CP	H8PKEYMUL
0361+  20B5 CA CA 21    	JP	Z,H8P_HDLKEYMUL
0362+  20B8 FE 2F       	CP	H8PKEYNUM
0363+  20BA CA D9 21    	JP	Z,H8P_HDLKEYNUM
0364+  20BD             ;
0365+  20BD             H8P_HDLKEYDOT:
0366+  20BD AF          	XOR	A
0367+  20BE 32 28 23    	LD	(H8P_MEMMODE),A
0368+  20C1 3A 2B 23    	LD	A,(H8P_REGNUM)
0369+  20C4 B7          	OR	A
0370+  20C5 CA E6 20    	JP	Z,H8P_HDLKEY1
0371+  20C8 3D          	DEC	A
0372+  20C9 CA 00 21    	JP	Z,H8P_HDLKEY2
0373+  20CC 3D          	DEC	A
0374+  20CD CA 1B 21    	JP	Z,H8P_HDLKEY3
0375+  20D0 3D          	DEC	A
0376+  20D1 CA 36 21    	JP	Z,H8P_HDLKEY4
0377+  20D4 3D          	DEC	A
0378+  20D5 CA 51 21    	JP	Z,H8P_HDLKEY5
0379+  20D8 C3 6C 21    	JP	H8P_HDLKEY6
0380+  20DB             H8P_HDLKEY0:
0381+  20DB 3A 28 23    	LD	A,(H8P_MEMMODE)
0382+  20DE B7          	OR	A
0383+  20DF C8          	RET	Z
0384+  20E0 0E 00       	LD	C,0
0385+  20E2 CD 16 22    	CALL	H8P_SETMEM
0386+  20E5 C9          	RET
0387+  20E6             H8P_HDLKEY1:
0388+  20E6 0E 01       	LD	C,1
0389+  20E8 3A 28 23    	LD	A,(H8P_MEMMODE)
0390+  20EB B7          	OR	A
0391+  20EC C2 16 22    	JP	NZ,H8P_SETMEM
0392+  20EF AF          	XOR	A
0393+  20F0 32 2B 23    	LD	(H8P_REGNUM),A
0394+  20F3 21 3C 23    	LD	HL,H8P_REGSP
0395+  20F6 22 2C 23    	LD	(H8P_CURREG),HL
0396+  20F9 21 4A 23    	LD	HL,H8P_SPVAL
0397+  20FC 22 2E 23    	LD	(H8P_CURVAL),HL
0398+  20FF C9          	RET
0399+  2100             H8P_HDLKEY2:
0400+  2100 0E 02       	LD	C,2
0401+  2102 3A 28 23    	LD	A,(H8P_MEMMODE)
0402+  2105 B7          	OR	A
0403+  2106 C2 16 22    	JP	NZ,H8P_SETMEM
0404+  2109 3E 01       	LD	A,1
0405+  210B 32 2B 23    	LD	(H8P_REGNUM),A
0406+  210E 21 30 23    	LD	HL,H8P_REGAF
0407+  2111 22 2C 23    	LD	(H8P_CURREG),HL
0408+  2114 21 42 23    	LD	HL,H8P_AFVAL
0409+  2117 22 2E 23    	LD	(H8P_CURVAL),HL
0410+  211A C9          	RET
0411+  211B             H8P_HDLKEY3:
0412+  211B 0E 03       	LD	C,3
0413+  211D 3A 28 23    	LD	A,(H8P_MEMMODE)
0414+  2120 B7          	OR	A
0415+  2121 C2 16 22    	JP	NZ,H8P_SETMEM
0416+  2124 3E 02       	LD	A,2
0417+  2126 32 2B 23    	LD	(H8P_REGNUM),A
0418+  2129 21 33 23    	LD	HL,H8P_REGBC
0419+  212C 22 2C 23    	LD	(H8P_CURREG),HL
0420+  212F 21 44 23    	LD	HL,H8P_BCVAL
0421+  2132 22 2E 23    	LD	(H8P_CURVAL),HL
0422+  2135 C9          	RET
0423+  2136             H8P_HDLKEY4:
0424+  2136 0E 04       	LD	C,4
0425+  2138 3A 28 23    	LD	A,(H8P_MEMMODE)
0426+  213B B7          	OR	A
0427+  213C C2 16 22    	JP	NZ,H8P_SETMEM
0428+  213F 3E 03       	LD	A,3
0429+  2141 32 2B 23    	LD	(H8P_REGNUM),A
0430+  2144 21 36 23    	LD	HL,H8P_REGDE
0431+  2147 22 2C 23    	LD	(H8P_CURREG),HL
0432+  214A 21 46 23    	LD	HL,H8P_DEVAL
0433+  214D 22 2E 23    	LD	(H8P_CURVAL),HL
0434+  2150 C9          	RET
0435+  2151             H8P_HDLKEY5:
0436+  2151 0E 05       	LD	C,5
0437+  2153 3A 28 23    	LD	A,(H8P_MEMMODE)
0438+  2156 B7          	OR	A
0439+  2157 C2 16 22    	JP	NZ,H8P_SETMEM
0440+  215A 3E 04       	LD	A,4
0441+  215C 32 2B 23    	LD	(H8P_REGNUM),A
0442+  215F 21 39 23    	LD	HL,H8P_REGHL
0443+  2162 22 2C 23    	LD	(H8P_CURREG),HL
0444+  2165 21 48 23    	LD	HL,H8P_HLVAL
0445+  2168 22 2E 23    	LD	(H8P_CURVAL),HL
0446+  216B C9          	RET
0447+  216C             H8P_HDLKEY6:
0448+  216C 0E 06       	LD	C,6
0449+  216E 3A 28 23    	LD	A,(H8P_MEMMODE)
0450+  2171 B7          	OR	A
0451+  2172 C2 16 22    	JP	NZ,H8P_SETMEM
0452+  2175 3E 05       	LD	A,5
0453+  2177 32 2B 23    	LD	(H8P_REGNUM),A
0454+  217A 21 3F 23    	LD	HL,H8P_REGPC
0455+  217D 22 2C 23    	LD	(H8P_CURREG),HL
0456+  2180 21 4C 23    	LD	HL,H8P_PCVAL
0457+  2183 22 2E 23    	LD	(H8P_CURVAL),HL
0458+  2186 C9          	RET
0459+  2187             H8P_HDLKEY7:
0460+  2187 0E 07       	LD	C,7
0461+  2189 3A 28 23    	LD	A,(H8P_MEMMODE)
0462+  218C B7          	OR	A
0463+  218D C2 16 22    	JP	NZ,H8P_SETMEM
0464+  2190 C9          	RET
0465+  2191             H8P_HDLKEY8:
0466+  2191 AF          	XOR	A
0467+  2192 32 2A 23    	LD	(H8P_MEMINP),A
0468+  2195 C9          	RET
0469+  2196             H8P_HDLKEY9:
0470+  2196 AF          	XOR	A
0471+  2197 32 2A 23    	LD	(H8P_MEMINP),A
0472+  219A 3A 27 23    	LD	A,(H8P_DISPMODE)
0473+  219D 3C          	INC	A
0474+  219E E6 03       	AND	$03
0475+  21A0 32 27 23    	LD	(H8P_DISPMODE),A
0476+  21A3 C9          	RET
0477+  21A4             H8P_HDLKEYPLUS:
0478+  21A4 AF          	XOR	A
0479+  21A5 32 2A 23    	LD	(H8P_MEMINP),A
0480+  21A8 3A 28 23    	LD	A,(H8P_MEMMODE)
0481+  21AB B7          	OR	A
0482+  21AC CA EF 21    	JP	Z,H8P_NEXTREG
0483+  21AF 2A 2E 23    	LD	HL,(H8P_CURVAL)
0484+  21B2 23          	INC	HL
0485+  21B3 22 2E 23    	LD	(H8P_CURVAL),HL
0486+  21B6 C9          	RET
0487+  21B7             H8P_HDLKEYMINUS:
0488+  21B7 AF          	XOR	A
0489+  21B8 32 2A 23    	LD	(H8P_MEMINP),A
0490+  21BB 3A 28 23    	LD	A,(H8P_MEMMODE)
0491+  21BE B7          	OR	A
0492+  21BF CA 02 22    	JP	Z,H8P_PREVREG
0493+  21C2 2A 2E 23    	LD	HL,(H8P_CURVAL)
0494+  21C5 2B          	DEC	HL
0495+  21C6 22 2E 23    	LD	(H8P_CURVAL),HL
0496+  21C9 C9          	RET
0497+  21CA             H8P_HDLKEYMUL:
0498+  21CA 3A 26 23    	LD	A,(H8P_ENABLE)
0499+  21CD 3C          	INC	A
0500+  21CE E6 01       	AND	1
0501+  21D0 32 26 23    	LD	(H8P_ENABLE),A
0502+  21D3 C9          	RET
0503+  21D4             H8P_HDLKEYDIV:
0504+  21D4 AF          	XOR	A
0505+  21D5 32 2A 23    	LD	(H8P_MEMINP),A
0506+  21D8 C9          	RET
0507+  21D9             H8P_HDLKEYNUM:
0508+  21D9 3E 01       	LD	A,1
0509+  21DB 32 28 23    	LD	(H8P_MEMMODE),A
0510+  21DE 32 2A 23    	LD	(H8P_MEMINP),A
0511+  21E1 AF          	XOR	A
0512+  21E2 32 29 23    	LD	(H8P_MEMDIG),A
0513+  21E5 2A 2E 23    	LD	HL,(H8P_CURVAL)
0514+  21E8 5E          	LD	E,(HL)
0515+  21E9 23          	INC	HL
0516+  21EA 56          	LD	D,(HL)
0517+  21EB 22 2E 23    	LD	(H8P_CURVAL),HL
0518+  21EE C9          	RET
0519+  21EF             ;
0520+  21EF             H8P_NEXTREG:
0521+  21EF 3A 2B 23    	LD	A,(H8P_REGNUM)
0522+  21F2 3C          	INC	A
0523+  21F3 32 2B 23    	LD	(H8P_REGNUM),A
0524+  21F6 FE 06       	CP	$06
0525+  21F8 C2 BD 20    	JP	NZ,H8P_HDLKEYDOT
0526+  21FB AF          	XOR	A
0527+  21FC 32 2B 23    	LD	(H8P_REGNUM),A
0528+  21FF C3 BD 20    	JP	H8P_HDLKEYDOT
0529+  2202             ;
0530+  2202             H8P_PREVREG:
0531+  2202 3A 2B 23    	LD	A,(H8P_REGNUM)
0532+  2205 3D          	DEC	A
0533+  2206 32 2B 23    	LD	(H8P_REGNUM),A
0534+  2209 FE FF       	CP	$FF
0535+  220B C2 BD 20    	JP	NZ,H8P_HDLKEYDOT
0536+  220E 3E 05       	LD	A,$05
0537+  2210 32 2B 23    	LD	(H8P_REGNUM),A
0538+  2213 C3 BD 20    	JP	H8P_HDLKEYDOT
0539+  2216             ;
0540+  2216             H8P_SETMEM:
0541+  2216 3A 2A 23    	LD	A,(H8P_MEMINP)
0542+  2219 B7          	OR	A
0543+  221A C8          	RET	Z
0544+  221B 3A 29 23    	LD	A,(H8P_MEMDIG)
0545+  221E B7          	OR	A
0546+  221F CA 37 22    	JP	Z,H8P_SETMEM0
0547+  2222 3D          	DEC	A
0548+  2223 CA 45 22    	JP	Z,H8P_SETMEM1
0549+  2226 3D          	DEC	A
0550+  2227 CA 53 22    	JP	Z,H8P_SETMEM2
0551+  222A 3D          	DEC	A
0552+  222B CA 61 22    	JP	Z,H8P_SETMEM3
0553+  222E 3D          	DEC	A
0554+  222F CA 6F 22    	JP	Z,H8P_SETMEM4
0555+  2232 3D          	DEC	A
0556+  2233 CA 7D 22    	JP	Z,H8P_SETMEM5
0557+  2236 C9          	RET
0558+  2237             H8P_SETMEM0:
0559+  2237 2A 2E 23    	LD	HL,(H8P_CURVAL)
0560+  223A 44          	LD	B,H
0561+  223B CD 98 22    	CALL	H8P_SETOCTH
0562+  223E 67          	LD	H,A
0563+  223F 22 2E 23    	LD	(H8P_CURVAL),HL
0564+  2242 C3 90 22    	JP	H8P_NEXTDIG
0565+  2245             H8P_SETMEM1:
0566+  2245 2A 2E 23    	LD	HL,(H8P_CURVAL)
0567+  2248 44          	LD	B,H
0568+  2249 CD A7 22    	CALL	H8P_SETOCTM
0569+  224C 67          	LD	H,A
0570+  224D 22 2E 23    	LD	(H8P_CURVAL),HL
0571+  2250 C3 90 22    	JP	H8P_NEXTDIG
0572+  2253             H8P_SETMEM2:
0573+  2253 2A 2E 23    	LD	HL,(H8P_CURVAL)
0574+  2256 44          	LD	B,H
0575+  2257 CD B3 22    	CALL	H8P_SETOCTL
0576+  225A 67          	LD	H,A
0577+  225B 22 2E 23    	LD	(H8P_CURVAL),HL
0578+  225E C3 90 22    	JP	H8P_NEXTDIG
0579+  2261             H8P_SETMEM3:
0580+  2261 2A 2E 23    	LD	HL,(H8P_CURVAL)
0581+  2264 45          	LD	B,L
0582+  2265 CD 98 22    	CALL	H8P_SETOCTH
0583+  2268 6F          	LD	L,A
0584+  2269 22 2E 23    	LD	(H8P_CURVAL),HL
0585+  226C C3 90 22    	JP	H8P_NEXTDIG
0586+  226F             H8P_SETMEM4:
0587+  226F 2A 2E 23    	LD	HL,(H8P_CURVAL)
0588+  2272 45          	LD	B,L
0589+  2273 CD A7 22    	CALL	H8P_SETOCTM
0590+  2276 6F          	LD	L,A
0591+  2277 22 2E 23    	LD	(H8P_CURVAL),HL
0592+  227A C3 90 22    	JP	H8P_NEXTDIG
0593+  227D             H8P_SETMEM5:
0594+  227D 2A 2E 23    	LD	HL,(H8P_CURVAL)
0595+  2280 45          	LD	B,L
0596+  2281 CD B3 22    	CALL	H8P_SETOCTL
0597+  2284 6F          	LD	L,A
0598+  2285 22 2E 23    	LD	(H8P_CURVAL),HL
0599+  2288 AF          	XOR	A
0600+  2289 32 29 23    	LD	(H8P_MEMDIG),A
0601+  228C 32 2A 23    	LD	(H8P_MEMINP),A
0602+  228F C9          	RET
0603+  2290             ;
0604+  2290             H8P_NEXTDIG:
0605+  2290 3A 29 23    	LD	A,(H8P_MEMDIG)
0606+  2293 3C          	INC	A
0607+  2294 32 29 23    	LD	(H8P_MEMDIG),A
0608+  2297 C9          	RET
0609+  2298             ;
0610+  2298             H8P_SETOCTH:
0611+  2298 79          	LD	A,C
0612+  2299 E6 03       	AND	$03
0613+  229B 17          	RLA
0614+  229C 17          	RLA
0615+  229D 17          	RLA
0616+  229E 17          	RLA
0617+  229F 17          	RLA
0618+  22A0 17          	RLA
0619+  22A1 4F          	LD	C,A
0620+  22A2 78          	LD	A,B
0621+  22A3 E6 3F       	AND	$3F
0622+  22A5 B1          	OR	C
0623+  22A6 C9          	RET
0624+  22A7             H8P_SETOCTM:
0625+  22A7 79          	LD	A,C
0626+  22A8 E6 07       	AND	$07
0627+  22AA 17          	RLA
0628+  22AB 17          	RLA
0629+  22AC 17          	RLA
0630+  22AD 4F          	LD	C,A
0631+  22AE 78          	LD	A,B
0632+  22AF E6 C7       	AND	$C7
0633+  22B1 B1          	OR	C
0634+  22B2 C9          	RET
0635+  22B3             H8P_SETOCTL:
0636+  22B3 79          	LD	A,C
0637+  22B4 E6 07       	AND	$07
0638+  22B6 4F          	LD	C,A
0639+  22B7 78          	LD	A,B
0640+  22B8 E6 F8       	AND	$F8
0641+  22BA B1          	OR	C
0642+  22BB F5          	PUSH	AF
0643+  22BC CD 0A 23    	CALL	H8P_BEEP
0644+  22BF F1          	POP	AF
0645+  22C0 C9          	RET
0646+  22C1             ; HIGH OCTAL BITS
0647+  22C1             H8P_GETOCTH:
0648+  22C1 E6 C0       	AND	$C0
0649+  22C3 1F          	RRA
0650+  22C4 1F          	RRA
0651+  22C5 1F          	RRA
0652+  22C6 1F          	RRA
0653+  22C7 1F          	RRA
0654+  22C8 1F          	RRA
0655+  22C9 18 09       	JR	H8P_GETOCTX
0656+  22CB             ; MEDIUM OCTAL BITS
0657+  22CB             H8P_GETOCTM:
0658+  22CB E6 38       	AND	$38
0659+  22CD 1F          	RRA
0660+  22CE 1F          	RRA
0661+  22CF 1F          	RRA
0662+  22D0 18 02       	JR	H8P_GETOCTX
0663+  22D2             ; LOW OCTAL BITS
0664+  22D2             H8P_GETOCTL:
0665+  22D2 E6 07       	AND	$07
0666+  22D4             H8P_GETOCTX:
0667+  22D4 5F          	LD	E,A
0668+  22D5 16 00       	LD	D,0
0669+  22D7 21 16 23    	LD	HL,H8P_DIGMAP
0670+  22DA 19          	ADD	HL,DE
0671+  22DB 7E          	LD	A,(HL)		; VALUE CONVERTED TO LED SEGMENT PATTERN
0672+  22DC C9          	RET
0673+  22DD             ;
0674+  22DD             H8P_GETDOT:
0675+  22DD 0E 80       	LD	C,$80		; DOT OFF
0676+  22DF 3A 28 23    	LD	A,(H8P_MEMMODE)
0677+  22E2 B7          	OR	A
0678+  22E3 C8          	RET	Z
0679+  22E4 3A 2A 23    	LD	A,(H8P_MEMINP)
0680+  22E7 B7          	OR	A
0681+  22E8 C8          	RET	Z
0682+  22E9 3A 29 23    	LD	A,(H8P_MEMDIG)
0683+  22EC 47          	LD	B,A
0684+  22ED 3A 5A 23    	LD	A,(H8P_LEDNUM)
0685+  22F0 3D          	DEC	A
0686+  22F1 B8          	CP	B
0687+  22F2 C0          	RET	NZ
0688+  22F3 0E 00       	LD	C,0		; DOT ON
0689+  22F5 C9          	RET
0690+  22F6             ;
0691+  22F6             H8P_SPEAKER:
0692+  22F6 0E 80       	LD	C,$80		; SPEAKER OFF
0693+  22F8 3A 5C 23    	LD	A,(H8P_SPKDLY)
0694+  22FB B7          	OR	A
0695+  22FC C8          	RET	Z
0696+  22FD 3D          	DEC	A
0697+  22FE 32 5C 23    	LD	(H8P_SPKDLY),A
0698+  2301 0E 00       	LD	C,0
0699+  2303 C9          	RET
0700+  2304             ;
0701+  2304             H8P_CLICK:
0702+  2304 3E 04       	LD	A,4
0703+  2306 32 5C 23    	LD	(H8P_SPKDLY),A
0704+  2309 C9          	RET
0705+  230A             ;
0706+  230A             H8P_BEEP:
0707+  230A 3E 10       	LD	A,16
0708+  230C 32 5C 23    	LD	(H8P_SPKDLY),A
0709+  230F C9          	RET
0710+  2310             ;
0711+  2310             H8P_ALARM:
0712+  2310 3E 20       	LD	A,32
0713+  2312 32 5C 23    	LD	(H8P_SPKDLY),A
0714+  2315 C9          	RET
0715+  2316             ;
0716+  2316             ; DEVICE INFORMATION
0717+  2316             ;
0718+  2316             ;H8P_DEVICE:
0719+  2316             ;	LD	D,DSKYDEV_H8P		; D := DEVICE TYPE
0720+  2316             ;	LD	E,0			; E := PHYSICAL DEVICE NUMBER
0721+  2316             ;	LD	H,0			; H := MODE
0722+  2316             ;	LD	L,FPLED_IO		; L := BASE I/O ADDRESS
0723+  2316             ;	XOR	A			; SIGNAL SUCCESS
0724+  2316             ;	RET
0725+  2316             ;
0726+  2316             ;	+--02--+
0727+  2316             ;	40    04
0728+  2316             ;	+--01--+
0729+  2316             ;	20    08
0730+  2316             ;	+--10--+  80
0731+  2316             ;
0732+  2316             H8P_DIGMAP:
0733+  2316             	; DIGITS TO LED PATTERNS
0734+  2316             	;	  0    1    2    3    4    5    6    7
0735+  2316 7E 0C 37 1F 	.DB	$7E, $0C, $37, $1F, $4D, $5B, $7B, $0E
0735+  231A 4D 5B 7B 0E 
0736+  231E             	;	  8    9    A    B    C    D    E    F
0737+  231E 7F 5F 6F 79 	.DB	$7F, $5F, $6F, $79, $72, $3D, $73, $63
0737+  2322 72 3D 73 63 
0738+  2326             ;
0739+  2326             H8P_ENABLE:
0740+  2326 01          	.DB	1
0741+  2327             H8P_DISPMODE:
0742+  2327 00          	.DB	0
0743+  2328             H8P_MEMMODE:
0744+  2328 00          	.DB	0
0745+  2329             H8P_MEMDIG:
0746+  2329 00          	.DB	0
0747+  232A             H8P_MEMINP:
0748+  232A 00          	.DB	0
0749+  232B             H8P_REGNUM:
0750+  232B 00          	.DB	0
0751+  232C             H8P_CURREG:
0752+  232C 3C 23       	.DW	H8P_REGSP
0753+  232E             H8P_CURVAL:
0754+  232E 4A 23       	.DW	H8P_SPVAL
0755+  2330             H8P_REGAF:
0756+  2330 00 6F 63    	.DB	$00, $6F, $63
0757+  2333             H8P_REGBC:
0758+  2333 00 79 72    	.DB	$00, $79, $72
0759+  2336             H8P_REGDE:
0760+  2336 00 3D 73    	.DB	$00, $3D, $73
0761+  2339             H8P_REGHL:
0762+  2339 00 6D 70    	.DB	$00, $6D, $70
0763+  233C             H8P_REGSP:
0764+  233C 00 5B 67    	.DB	$00, $5B, $67
0765+  233F             H8P_REGPC:
0766+  233F 00 67 72    	.DB	$00, $67, $72
0767+  2342             H8P_AFVAL:
0768+  2342 00 00       	.DW	0
0769+  2344             H8P_BCVAL:
0770+  2344 00 00       	.DW	0
0771+  2346             H8P_DEVAL:
0772+  2346 00 00       	.DW	0
0773+  2348             H8P_HLVAL:
0774+  2348 00 00       	.DW	0
0775+  234A             H8P_SPVAL:
0776+  234A 00 00       	.DW	0
0777+  234C             H8P_PCVAL:
0778+  234C 00 00       	.DW	0
0779+  234E             H8P_TICCNT:
0780+  234E 00 00       	.DW	0
0781+  2350             H8P_HBTICK:
0782+  2350 00          	.DB	0
0783+  2351             H8P_LEDPAT:
0784+  2351 00 00 00 00 	.DB	$00, $00, $00, $00, $00, $00, $00, $00, $00
0784+  2355 00 00 00 00 
0784+  2359 00 
0785+  235A             H8P_LEDNUM:
0786+  235A 00          	.DB	0
0787+  235B             H8P_LASTKEY:
0788+  235B 00          	.DB	0
0789+  235C             H8P_SPKDLY:
0790+  235C 20          	.DB	32
6312   235D             #ENDIF
6313   235D             ;
6314   235D             ; INCLUDE LZSA2 decompression engine if required.
6315   235D             ;
6316   235D~            #IF ((VGAENABLE | CVDUENABLE | TMSENABLE | GDCENABLE) & USELZSA2)
6317   235D~            #INCLUDE "unlzsa2s.asm"
6318   235D             #ENDIF
6319   235D             ;
6320   235D             ; DETECT CPU SPEED USING DS-1302 RTC
6321   235D             ;
6322   235D             HB_CPUSPD:
6323   235D             ;
6324   235D~            #IF (DSRTCENABLE & ((CPUFAM == CPU_Z80) | (CPUFAM == CPU_Z180)))
6325   235D~            ;
6326   235D~            	LD	A,(DSRTC_STAT)		; GET RTC STATUS
6327   235D~            	OR	A			; SET FLAGS
6328   235D~            	RET	NZ			; NOT ZERO IS ERROR
6329   235D~            ;
6330   235D~            HB_CPUSPD1:
6331   235D~              #IF (CPUFAM == CPU_Z180)
6332   235D~            	; USE MEM W/S = 2 AND I/O W/S = 3 FOR TEST
6333   235D~            	IN0	A,(Z180_DCNTL)
6334   235D~            	PUSH	AF
6335   235D~            	LD	A,$B0
6336   235D~            	;LD	A,$F0
6337   235D~            	OUT0	(Z180_DCNTL),A
6338   235D~              #ENDIF
6339   235D~            
6340   235D~            	; WAIT FOR AN INITIAL TICK TO ALIGN, THEN WAIT
6341   235D~            	; FOR A SECOND TICK TO GET A FULL ONE SECOND LOOP COUNT.
6342   235D~            	; WAITSEC WILL SET ZF IF AN OVERFLOW OCCURS (MEANING THAT THE
6343   235D~            	; CLOCK IS NOT TICKING).  THERE IS NO
6344   235D~            	; POINT IN CALLING HB_WAITSEC AGAIN IN THAT CASE, SO WE ONLY
6345   235D~            	; CALL HB_WAITSEC AGAIN IF ZF IS NOT SET.
6346   235D~            	CALL	DSRTC_START
6347   235D~            	CALL	HB_RDSEC		; GET SECONDS
6348   235D~            	LD	(HB_CURSEC),A		; AND INIT CURSEC
6349   235D~            	CALL	HB_WAITSEC		; WAIT FOR SECONDS TICK
6350   235D~            	LD	(HB_CURSEC),A		; SAVE NEW VALUE
6351   235D~            	; CALL HB_WAITSEC AGAIN, BUT ONLY IF ZF IS NOT SET
6352   235D~            	CALL	NZ,HB_WAITSEC		; WAIT FOR SECONDS TICK
6353   235D~            ;
6354   235D~              #IF (CPUFAM == CPU_Z180)
6355   235D~            	; RESTORE W/S SETTINGS FROM BEFORE TEST
6356   235D~            	POP	AF
6357   235D~            	OUT0	(Z180_DCNTL),A
6358   235D~              #ENDIF
6359   235D~            ;
6360   235D~            	; MOVE LOOP COUNT TO HL
6361   235D~            	PUSH	DE
6362   235D~            	POP	HL
6363   235D~            ;
6364   235D~            	; CHECK FOR OVERFLOW (NOT TICKING)
6365   235D~            	LD	A,H
6366   235D~            	OR	L
6367   235D~            	JR	Z,HB_CPUSPD2		; FAILURE, USE DEFAULT CPU SPEED
6368   235D~            ;
6369   235D~            	; TIMES 4 FOR CPU SPEED IN KHZ
6370   235D~            ;	RES	0,L			; GRANULARITY
6371   235D~            	SLA	L
6372   235D~            	RL	H
6373   235D~            	SLA	L
6374   235D~            	RL	H
6375   235D~            ;
6376   235D~            	; RETURN CURRENT CPU SPD (KHZ) IN HL
6377   235D~            	XOR	A			; SIGNAL SUCCESS
6378   235D~            	RET
6379   235D~            ;
6380   235D~            HB_WAITSEC:
6381   235D~            	; WAIT FOR SECONDS TICK
6382   235D~            	; RETURN SECS VALUE IN A, LOOP COUNT IN DE
6383   235D~            	; ZF IS SET ON OVERFLOW (CLOCK NOT TICKING)
6384   235D~            	LD	DE,0			; INIT LOOP COUNTER
6385   235D~            HB_WAITSEC1:
6386   235D~            ;
6387   235D~              #IF (CPUFAM == CPU_Z80)
6388   235D~            	; LOOP TARGET IS 4000 T-STATES, SO CPU FREQ IN KHZ = LOOP COUNT * 4
6389   235D~            	CALL	DLY32
6390   235D~            	CALL	DLY16
6391   235D~            	CALL	DLY1			; 27 TSTATES
6392   235D~            	SBC	HL,HL			; 15 TSTATES
6393   235D~            	SBC	HL,HL			; 15 TSTATES
6394   235D~            	INC	HL			; 6 TSTATES
6395   235D~            	INC	HL			; 6 TSTATES
6396   235D~              #ENDIF
6397   235D~            ;
6398   235D~              #IF (CPUFAM == CPU_Z180)
6399   235D~            	; LOOP TARGET IS 4000 T-STATES, SO CPU FREQ IN KHZ = LOOP COUNT * 4
6400   235D~            	CALL	DLY2
6401   235D~            	ADD	IX,BC			; 10 + 4 = 14 TSTATES
6402   235D~            	NOP				; 5 TSTATES
6403   235D~            	NOP				; 5 TSTATES
6404   235D~            	NOP				; 5 TSTATES
6405   235D~            	NOP				; 5 TSTATES
6406   235D~              #ENDIF
6407   235D~            ;
6408   235D~            	PUSH	DE			; SAVE COUNTER
6409   235D~            	CALL	HB_RDSEC		; GET SECONDS
6410   235D~            	POP	DE			; RESTORE COUNTER
6411   235D~            	INC	DE			; BUMP COUNTER
6412   235D~            	LD	HL,HB_CURSEC		; POINT TO COMP VALUE
6413   235D~            	CP	(HL)			; TEST FOR CHANGE
6414   235D~            	RET	NZ			; DONE IF TICK OCCURRED
6415   235D~            	LD	A,D			; CHECK DE
6416   235D~            	OR	E			; ... FOR OVERFLOW
6417   235D~            	RET	Z			; TIMEOUT, SOMETHING IS WRONG
6418   235D~            	JR	HB_WAITSEC1		; LOOP
6419   235D~            ;
6420   235D~            HB_RDSEC:
6421   235D~            	; READ SECONDS BYTE INTO A
6422   235D~            	LD	E,$81			; SECONDS REGISTER
6423   235D~            	CALL	DSRTC_CMD		; SEND THE COMMAND
6424   235D~            	CALL	DSRTC_GET		; READ THE REGISTER
6425   235D~            	CALL	DSRTC_END		; FINISH IT
6426   235D~            	LD	A,E			; VALUE TO A
6427   235D~            	RET
6428   235D~            ;
6429   235D             #ENDIF
6430   235D             ;
6431   235D             HB_CPUSPD2:
6432   235D             	; HANDLE NO RTC OR NOT TICKING
6433   235D F6 FF       	OR	$FF			; SIGNAL ERROR
6434   235F C9          	RET				; AND DONE
6435   2360             ;
6436   2360             ; SYSTEM CHECK: DUMP MACHINE STATE AND CONTINUE?
6437   2360             ;
6438   2360             SYSCHKA:
6439   2360             	; CHECK DIAG LEVEL TO SEE IF WE SHOULD DISPLAY
6440   2360 F5          	PUSH	AF			; PRESERVE INCOMING AF VALUE
6441   2361 3A 13 01    	LD	A,(CB_DIAGLVL)		; GET DIAGNOSTIC LEVEL
6442   2364 FE 08       	CP	DL_ERROR		; >= ERROR LEVEL
6443   2366 38 18       	JR	C,SYSCHK1		; IF NOT, GO HOME
6444   2368 F1          	POP	AF			; RESTORE INCOMING AF VALUE
6445   2369             ;
6446   2369             	; DISPLAY SYSCHK MESSAGE
6447   2369 D5          	PUSH	DE			; PRESERVE DE VALUE
6448   236A 11 F5 29    	LD	DE,STR_SYSCHK		; POINT TO PREFIX STRING
6449   236D CD 12 1A    	CALL	WRITESTR		; PRINT IT
6450   2370 D1          	POP	DE			; RESTORE DE VALUE
6451   2371 CD 36 1A    	CALL	XREGDMP			; DUMP REGISTERS
6452   2374             
6453   2374             	; DISPLAY ERROR CODE. IT IS AT RETURN ADDRESS+1 .. LD A,XX
6454   2374 E3          	EX	(SP),HL			; GET RETURN ADDRESS
6455   2375 23          	INC	HL			; POINT TO THE ERROR CODE
6456   2376 F5          	PUSH	AF
6457   2377 7E          	LD	A,(HL)			; DISPLAY
6458   2378 CD 52 19    	CALL	PRTHEXBYTE
6459   237B F1          	POP	AF
6460   237C 2B          	DEC	HL			; RESTORE RETURN ADDRESS
6461   237D E3          	EX	(SP),HL
6462   237E             ;
6463   237E 18 0F       	JR	CONTINUE		; CHECK W/ USER
6464   2380             ;
6465   2380             SYSCHK1:
6466   2380             	; RETURN IF MESSAGING BYPASSED BY DIAG LEVEL
6467   2380 F1          	POP	AF
6468   2381 C9          	RET
6469   2382             ;
6470   2382             ; PANIC: DUMP MACHINE STATE AND HALT
6471   2382             ;
6472   2382             PANIC:
6473   2382 D5          	PUSH	DE
6474   2383 11 E7 29    	LD	DE,STR_PANIC
6475   2386 CD 12 1A    	CALL	WRITESTR
6476   2389 D1          	POP	DE
6477   238A CD 36 1A    	CALL	XREGDMP			; DUMP REGISTERS
6478   238D 18 20       	JR	SYSHALT			; FULL STOP
6479   238F             ;
6480   238F             ;
6481   238F             ;
6482   238F             CONTINUE:
6483   238F F5          	PUSH	AF
6484   2390             CONTINUE1:
6485   2390 D5          	PUSH	DE
6486   2391 11 04 2A    	LD	DE,STR_CONTINUE
6487   2394 CD 12 1A    	CALL	WRITESTR
6488   2397 D1          	POP	DE
6489   2398 CD 18 29    	CALL	CIN
6490   239B CB AF       	RES	5,A			; FORCE UPPERCASE (IMPERFECTLY)
6491   239D CD FF 28    	CALL	COUT			; ECHO
6492   23A0 FE 59       	CP	'Y'
6493   23A2 28 06       	JR	Z,CONTINUE3
6494   23A4 FE 4E       	CP	'N'
6495   23A6 28 07       	JR	Z,SYSHALT
6496   23A8 18 E6       	JR	CONTINUE1
6497   23AA             CONTINUE3:
6498   23AA CD 20 19    	CALL	NEWLINE
6499   23AD F1          	POP	AF
6500   23AE C9          	RET
6501   23AF             ;
6502   23AF             ;
6503   23AF             ;
6504   23AF             SYSHALT:
6505   23AF 11 A5 1A    	LD	DE,STR_HALT
6506   23B2 CD 12 1A    	CALL	WRITESTR
6507   23B5 F3          	DI
6508   23B6 76          	HALT
6509   23B7             ;
6510   23B7             ; PRINT VALUE OF HL AS THOUSANDTHS, IE. 0.000
6511   23B7             ;
6512   23B7             PRTD3M:
6513   23B7 C5          	PUSH	BC
6514   23B8 D5          	PUSH	DE
6515   23B9 E5          	PUSH	HL
6516   23BA 1E 30       	LD	E,'0'
6517   23BC 01 F0 D8    	LD	BC,-10000
6518   23BF CD E1 23    	CALL	PRTD3M1
6519   23C2 1E 00       	LD	E,0
6520   23C4 01 18 FC    	LD	BC,-1000
6521   23C7 CD E1 23    	CALL	PRTD3M1
6522   23CA CD DC 18    	CALL	PC_PERIOD
6523   23CD 01 9C FF    	LD	BC,-100
6524   23D0 CD E1 23    	CALL	PRTD3M1
6525   23D3 0E F6       	LD	C,-10
6526   23D5 CD E1 23    	CALL	PRTD3M1
6527   23D8 0E FF       	LD	C,-1
6528   23DA CD E1 23    	CALL	PRTD3M1
6529   23DD E1          	POP	HL
6530   23DE D1          	POP	DE
6531   23DF C1          	POP	BC
6532   23E0 C9          	RET
6533   23E1             PRTD3M1:
6534   23E1 3E 2F       	LD	A,'0' - 1
6535   23E3             PRTD3M2:
6536   23E3 3C          	INC	A
6537   23E4 09          	ADD	HL,BC
6538   23E5 38 FC       	JR	C,PRTD3M2
6539   23E7 ED 42       	SBC	HL,BC
6540   23E9 BB          	CP	E
6541   23EA 28 05       	JR	Z,PRTD3M3
6542   23EC 1E 00       	LD	E,0
6543   23EE CD FF 28    	CALL	COUT
6544   23F1             PRTD3M3:
6545   23F1 C9          	RET
6546   23F2             ;==================================================================================================
6547   23F2             ; DISPLAY SUMMARY OF ATTACHED UNITS/DEVICES
6548   23F2             ;==================================================================================================
6549   23F2             ;
6550   23F2             PRTSUM:
6551   23F2 CD 1D 19    	CALL	NEWLINE2		; SKIP A LINE
6552   23F5 11 85 28    	LD	DE,PS_STRHDR		; POINT TO HEADER
6553   23F8 CD 12 1A    	CALL	WRITESTR		; PRINT IT
6554   23FB             ;
6555   23FB 0E 00       	LD	C,BF_SYSGET_CIOCNT	; CHARACTER DEVICES
6556   23FD 21 F8 24    	LD	HL,PS_SERIAL
6557   2400 CD 1C 24    	CALL	PRT_ALLD
6558   2403             ;
6559   2403 0E 10       	LD	C,BF_SYSGET_DIOCNT	; DISK DRIVES
6560   2405 21 32 24    	LD	HL,PS_DISK
6561   2408 CD 1C 24    	CALL	PRT_ALLD
6562   240B             ;
6563   240B 0E 40       	LD	C,BF_SYSGET_VDACNT	; VIDEO DEVICES
6564   240D 21 E3 25    	LD	HL,PS_VIDEO
6565   2410 CD 1C 24    	CALL	PRT_ALLD
6566   2413             ;
6567   2413 0E 50       	LD	C,BF_SYSGET_SNDCNT	; SOUND DEVICES
6568   2415 21 35 26    	LD	HL,PS_SOUND
6569   2418 CD 1C 24    	CALL	PRT_ALLD
6570   241B C9          	RET
6571   241C             ;
6572   241C             PRT_ALLD:
6573   241C 06 F8       	LD	B,BF_SYSGET		; FUNC: SYSTEM INFO GET
6574   241E CF          	RST	08			; E := UNIT COUNT
6575   241F 43          	LD	B,E			; MOVE TO B FOR LOOP COUNT
6576   2420 7B          	LD	A,E			; MOVE TO ACCUM
6577   2421 B7          	OR	A			; SET FLAGS
6578   2422 C8          	RET	Z			; IF NONE, JUST RETURN
6579   2423 0E 00       	LD	C,0			; C WILL BE UNIT INDEX
6580   2425             PRT_ALLD1:
6581   2425 C5          	PUSH	BC			; SAVE LOOP CONTROL
6582   2426 D5          	PUSH	DE
6583   2427 E5          	PUSH	HL
6584   2428 CD CD 1A    	CALL	JPHL			; CALL THE ROUTINE PASSED IN HL
6585   242B E1          	POP	HL
6586   242C D1          	POP	DE
6587   242D C1          	POP	BC			; RESTORE LOOP CONTROL
6588   242E 0C          	INC	C			; BUMP UNIT INDEX
6589   242F 10 F4       	DJNZ	PRT_ALLD1		; LOOP THRU ALL DEVICES
6590   2431 C9          	RET
6591   2432             ;
6592   2432             ; PRINT ONE LINE DISK UNIT/DEVICE INFO, DISK UNIT INDEX IN C
6593   2432             ;
6594   2432             PS_DISK:
6595   2432 C5          	PUSH	BC			; SAVE UNIT INDEX FOR LATER
6596   2433             ;
6597   2433             	; UNIT COLUMN
6598   2433 CD 3B 19    	PRTS("Disk $")
6598   2436 44 69 73 6B 
6598   243A 20 24 
6599   243C 79          	LD	A,C			; MOVE UNIT NUM TO A
6600   243D CD B2 1B    	CALL	PRTDECB			; PRINT IT
6601   2440 FE 0A       	CP	10			; CHECK FOR MULTIPLE DIGITS
6602   2442 DC D7 18    	CALL	C,PC_SPACE		; EXTRA SPACE IF NEEDED
6603   2445 CD 3B 19    	PRTS("     $")			; PAD TO NEXT COLUMN
6603   2448 20 20 20 20 
6603   244C 20 24 
6604   244E             ;
6605   244E             	; DEVICE COLUMN
6606   244E 06 17       	LD	B,BF_DIODEVICE		; FUNC=GET DEVICE INFO, UNIT NUM STILL IN C
6607   2450 CF          	RST	08			; DE:=DEVTYP/NUM, H:=DISK ATTRIBUTES
6608   2451 C5          	PUSH	BC			; SAVE ATTRIBUTES
6609   2452 21 0D 27    	LD	HL,PS_DDMD		; POINT TO DISK DEVICE TYPE NAME TABLE
6610   2455 CD A3 26    	CALL	PS_PRTDEV		; PRINT DISK DEVICE NMEMONIC PADDED TO FIELD WIDTH
6611   2458 D1          	POP	DE			; RECOVER ATTRIBUTES TO DE
6612   2459 D5          	PUSH	DE			; SAVE ATTRIBUTES AGAIN
6613   245A CD 66 24    	CALL	PS_PRTDT		; PRINT DISK TYPE
6614   245D D1          	POP	DE			; RESTORE ATTRIBUTES
6615   245E C1          	POP	BC			; RESTORE UNIT NUM
6616   245F CD 7C 24    	CALL	PS_PRTDC		; PRINT DISK CAPACITY
6617   2462             ;
6618   2462 CD 20 19    	CALL	NEWLINE
6619   2465 C9          	RET
6620   2466             ;
6621   2466             ; PRINT DISK TYPE (DISK ATTRIBUTE IN E)
6622   2466             ;
6623   2466             PS_PRTDT:
6624   2466 7B          	LD	A,E			; ATTRIBUTES TO A
6625   2467 CB 7F       	BIT	7,A			; FLOPPY BIT SET?
6626   2469 21 3A 27    	LD	HL,PS_DTFLOP		; ASSUME FLOPPY
6627   246C C2 D2 26    	JP	NZ,PS_PRT18		; IF FLOPPY, JUMP AHEAD
6628   246F             
6629   246F 4B          	LD	C,E
6630   2470 11 46 27    	LD	DE,PS_DTHARD
6631   2473 3E 38       	LD	A,00111000B
6632   2475 CD EF 19    	CALL	PRTIDXMSK
6633   2478 CD CC 26    	CALL	PS_PAD18		; PAD TO 18 SPACES
6634   247B C9          	RET	
6635   247C             ;
6636   247C             ; PRINT DISK CAPACITY (UNIT IN C, ATTRIBUTE IN E)
6637   247C             ;
6638   247C             PS_PRTDC:
6639   247C             ;
6640   247C 7B          	LD	A,E			; ATTRIBUTE TO ACCUM
6641   247D CB 7F       	BIT	7,A			; TEST FOR FLOPPY
6642   247F 20 53       	JR	NZ,PS_PRTDC2		; HANDLE FLOPPY
6643   2481 0F          	RRCA				; ISOLATE TYPE BITS
6644   2482 0F          	RRCA
6645   2483 0F          	RRCA
6646   2484 E6 07       	AND	$07
6647   2486 FE 04       	CP	4			; ROM DISK?
6648   2488 28 29       	JR	Z,PS_PRTDC1		; PRINT CAPACITY IN KB
6649   248A FE 05       	CP	5			; RAM DISK?
6650   248C 28 25       	JR	Z,PS_PRTDC1		; PRINT CAPACITY IN KB
6651   248E FE 07       	CP	7			; FLASH DISK?
6652   2490 28 21       	JR	Z,PS_PRTDC1		; PRINT CAPACITY IN KB
6653   2492             ;
6654   2492             	; PRINT HARD DISK STORAGE SIZE IN MB
6655   2492 06 1A       	LD	B,BF_DIOCAP		; HBIOS FUNC: GET CAPACTIY
6656   2494 CF          	RST	08			; DE:HL := BLOCKS
6657   2495 C2 BC 26    	JP	NZ,PS_PRTNUL		; MEDIA PROBLEM
6658   2498 CB BA       	RES	7,D			; CLEAR LBA BIT
6659   249A 06 0B       	LD	B,11			; 11 BIT SHIFT TO CONVERT BLOCKS --> MB
6660   249C CD 98 1C    	CALL	SRL32			; RIGHT SHIFT
6661   249F             	;CALL	PRTDEC			; PRINT LOW WORD IN DECIMAL (HIGH WORD DISCARDED)
6662   249F CD CA 1B    	CALL	PRTDEC32		; PRINT DWORD IN DECIMAL
6663   24A2 CD 3B 19    	PRTS("MB$")			; PRINT SUFFIX
6663   24A5 4D 42 24    
6664   24A8 CD E6 18    	CALL	PC_COMMA
6665   24AB CD 3B 19    	PRTS("LBA$")			; FOR NOW, WE ASSUME HARD DISK DOES LBA
6665   24AE 4C 42 41 24 
6666   24B2 C9          	RET				; DONE
6667   24B3             ;
6668   24B3             PS_PRTDC1:
6669   24B3             	; PRINT ROM/RAM DISK CAPACITY IN KB
6670   24B3 06 1A       	LD	B,BF_DIOCAP		; HBIOS FUNC: GET CAPACTIY
6671   24B5 CF          	RST	08			; DE:HL := BLOCKS
6672   24B6 C2 BC 26    	JP	NZ,PS_PRTNUL		; MEDIA PROBLEM
6673   24B9 CB BA       	RES	7,D			; CLEAR LBA BIT
6674   24BB 06 01       	LD	B,1			; 11 BIT SHIFT TO CONVERT BLOCKS --> MB
6675   24BD CD 98 1C    	CALL	SRL32			; RIGHT SHIFT
6676   24C0             	;CALL	PRTDEC			; PRINT LOW WORD IN DECIMAL (HIGH WORD DISCARDED)
6677   24C0 CD CA 1B    	CALL	PRTDEC32		; PRINT DWORD IN DECIMAL
6678   24C3 CD 3B 19    	PRTS("KB$")			; PRINT SUFFIX
6678   24C6 4B 42 24    
6679   24C9 CD E6 18    	CALL	PC_COMMA
6680   24CC CD 3B 19    	PRTS("LBA$")			; FOR NOW, WE ASSUME HARD DISK DOES LBA
6680   24CF 4C 42 41 24 
6681   24D3 C9          	RET				; DONE
6682   24D4             ;
6683   24D4             PS_PRTDC2:
6684   24D4 4B          	LD	C,E			; ATTRIBUTE TO C FOR SAFE KEEPING
6685   24D5             ;
6686   24D5 3E 60       	LD	A,01100000B		; DISPLAY FORM FACTOR
6687   24D7 11 9C 27    	LD	DE,PS_FLP_FSTR		; WHICH IS DEFINED IN
6688   24DA CD EF 19    	CALL	PRTIDXMSK		; BITS 5 AND 6.
6689   24DD             ;
6690   24DD 3E 10       	LD	A,00010000B		; DISPLAY SIDES
6691   24DF 11 B3 27    	LD	DE,PS_FLP_SSTR		; WHICH IS DEFINED
6692   24E2 CD EF 19    	CALL	PRTIDXMSK		; IN BIT 4
6693   24E5             ;
6694   24E5 3E 0C       	LD	A,00001100B		; DISPLAY DENSITY
6695   24E7 11 BB 27    	LD	DE,PS_FLP_DSTR		; WHICH IS DEFINED IN
6696   24EA CD EF 19    	CALL	PRTIDXMSK		; BITS 2 AND 3.
6697   24ED             ;
6698   24ED CD E6 18    	CALL	PC_COMMA
6699   24F0 CD 3B 19    	PRTS("CHS$")			; FOR NOW, WE ASSUME HARD DISK DOES LBA
6699   24F3 43 48 53 24 
6700   24F7             ;
6701   24F7 C9          	RET				; DONE
6702   24F8             ;
6703   24F8             ; PRINT ONE LINE SERIAL UNIT/DEVICE INFO, SERIAL UNIT INDEX IN C
6704   24F8             ;
6705   24F8             PS_SERIAL:
6706   24F8 C5          	PUSH	BC			; SAVE UNIT INDEX FOR LATER
6707   24F9             ;
6708   24F9             	; UNIT COLUMN
6709   24F9 CD 3B 19    	PRTS("Char $")
6709   24FC 43 68 61 72 
6709   2500 20 24 
6710   2502 79          	LD	A,C			; MOVE UNIT NUM TO A
6711   2503 CD B2 1B    	CALL	PRTDECB			; PRINT IT, ASSUME SINGLE DIGIT
6712   2506 CD 3B 19    	PRTS("      $")			; PAD TO NEXT COLUMN
6712   2509 20 20 20 20 
6712   250D 20 20 24 
6713   2510             ;
6714   2510             	; DEVICE COLUMN
6715   2510 06 06       	LD	B,BF_CIODEVICE		; FUNC=GET DEVICE INFO, UNIT NUM STILL IN C
6716   2512 CF          	RST	08			; DE:=DEVTYP/NUM, C:=DEVICE ATTRIBUTES
6717   2513 C5          	PUSH	BC			; SAVE ATTRIBUTES
6718   2514 21 C7 27    	LD	HL,PS_SDUART		; POINT TO SERIAL DEVICE TYPE NAME TABLE
6719   2517 CD A3 26    	CALL	PS_PRTDEV		; PRINT SERIAL DEVICE NMEMONIC PADDED TO FIELD WIDTH
6720   251A C1          	POP	BC			; RECOVER ATTRIBUTES
6721   251B C5          	PUSH	BC			; SAVE ATTRIBUTES AGAIN
6722   251C CD 28 25    	CALL	PS_PRTST		; PRINT SERIAL TYPE
6723   251F C1          	POP	BC			; RESTORE ATTRIBUTES
6724   2520 D1          	POP	DE			; RESTORE UNIT NUM TO E
6725   2521 CD 3E 25    	CALL	PS_PRTSC		; PRINT SERIAL CONFIG
6726   2524             ;
6727   2524 CD 20 19    	CALL	NEWLINE
6728   2527 C9          	RET
6729   2528             ;
6730   2528             ; PRINT CHARACTER TYPE (SERIAL ATTRIBUTE IN E)
6731   2528             ;
6732   2528             PS_PRTST:
6733   2528 21 12 28    	LD	HL,PS_STPPT
6734   252B CB 71       	BIT	6,C
6735   252D C2 D2 26    	JP	NZ,PS_PRT18		; PARALLEL TYPE?
6736   2530 21 02 28    	LD	HL,PS_STRS232		; ASSUME RS-232
6737   2533 CB 79       	BIT	7,C			; 0=RS-232, 1=TERMINAL
6738   2535 CA D2 26    	JP	Z,PS_PRT18		; HANDLE TERMINAL TYPE
6739   2538 21 09 28    	LD	HL,PS_STTERM		; TYPE IS TERMINAL
6740   253B C3 D2 26    	JP	PS_PRT18
6741   253E             ;
6742   253E             ; PRINT SERIAL CONFIG (UNIT IN E, ATTRIBUTE IN C)
6743   253E             ;
6744   253E             PS_PRTSC:
6745   253E CB 71       	BIT	6,C			; PARALLEL TYPE?
6746   2540 20 56       	JR	NZ,PSPRTPC0
6747   2542             
6748   2542 CB 79       	BIT	7,C			; 0=RS-232, 1=TERMINAL
6749   2544 C2 AB 25    	JP	NZ,PS_PRTSC1		; PRINT TERMINAL CONFIG
6750   2547             ;
6751   2547             	; PRINT RS-232 CONFIG
6752   2547 06 05       	LD	B,BF_CIOQUERY		; HBIOS FUNC: GET CIO CONFIG
6753   2549 4B          	LD	C,E			; SET SERIAL UNIT NUM
6754   254A CF          	RST	08			; DE:HL := BAUD RATE
6755   254B 7A          	LD	A,D			; TEST FOR $FF
6756   254C A3          	AND	E
6757   254D 3C          	INC	A			; SET Z IF DE == $FF
6758   254E CA BC 26    	JP	Z,PS_PRTNUL		; $FF == NO CONFIG DEFINED
6759   2551             ;
6760   2551             PS_PRTSC0:
6761   2551             	; PRINT BAUD RATE
6762   2551 D5          	PUSH	DE			; PRESERVE DE
6763   2552 7A          	LD	A,D
6764   2553 E6 1F       	AND	$1F			; ISOLATE ENCODED BAUD RATE
6765   2555 6F          	LD	L,A			; PUT IN L
6766   2556 26 00       	LD	H,0			; H IS ALWAYS ZERO
6767   2558 11 4B 00    	LD	DE,75			; BAUD RATE DECODE CONSTANT
6768   255B CD 43 1E    	CALL	DECODE			; DE:HL := BAUD RATE
6769   255E 01 53 2A    	LD	BC,HB_BCDTMP		; POINT TO TEMP BCD BUF
6770   2561 CD 03 1E    	CALL	BIN2BCD			; CONVERT TO BCD
6771   2564 CD 23 1E    	CALL	PRTBCD			; AND PRINT IN DECIMAL
6772   2567 D1          	POP	DE			; RESTORE DE
6773   2568             ;
6774   2568             	; PRINT DATA BITS
6775   2568 D5          	PUSH	DE			; PRESERVE DE
6776   2569 CD E6 18    	CALL	PC_COMMA		; FORMATTING
6777   256C 7B          	LD	A,E			; GET CONFIG BYTE
6778   256D E6 03       	AND	$03			; ISOLATE DATA BITS VALUE
6779   256F C6 35       	ADD	A,'5'			; CONVERT TO CHARACTER
6780   2571 CD FF 28    	CALL	COUT			; AND PRINT
6781   2574 D1          	POP	DE			; RESTORE DE
6782   2575             ;
6783   2575             	; PRINT PARITY
6784   2575 D5          	PUSH	DE			; PRESERVE DE
6785   2576 CD E6 18    	CALL	PC_COMMA		; FORMATTING
6786   2579 7B          	LD	A,E			; GET CONFIG BYTE
6787   257A 0F          	RRCA				; SHIFT RELEVANT BITS
6788   257B 0F          	RRCA				; ...
6789   257C 0F          	RRCA				; ...
6790   257D E6 07       	AND	$07			; AND ISOLATE DATA BITS VALUE
6791   257F 21 1B 28    	LD	HL,PS_STPARMAP		; CHARACTER LOOKUP TABLE
6792   2582 CD D2 1A    	CALL	ADDHLA			; APPLY OFFSET
6793   2585 7E          	LD	A,(HL)			; GET CHARACTER
6794   2586 CD FF 28    	CALL	COUT			; AND PRINT
6795   2589 D1          	POP	DE			; RESTORE DE
6796   258A             ;
6797   258A             	; PRINT STOP BITS
6798   258A CD E6 18    	CALL	PC_COMMA		; FORMATTING
6799   258D 7B          	LD	A,E			; GET CONFIG BYTE
6800   258E 0F          	RRCA				; SHIFT RELEVANT BITS
6801   258F 0F          	RRCA				; ...
6802   2590 E6 01       	AND	$01			; AND ISOLATE DATA BITS VALUE
6803   2592 C6 31       	ADD	A,'1'			; MAKE IT A CHARACTER
6804   2594 CD FF 28    	CALL	COUT			; AND PRINT
6805   2597             ;
6806   2597 C9          	RET
6807   2598             ;
6808   2598             PSPRTPC0:
6809   2598 06 05       	LD	B,BF_CIOQUERY		; HBIOS FUNC: GET CIO CONFIG
6810   259A 4B          	LD	C,E			; SET PARALLEL UNIT NUM
6811   259B CF          	RST	08			; DE:HL := I/O SETTING
6812   259C 7A          	LD	A,D			; TEST FOR $FF
6813   259D A3          	AND	E
6814   259E 3C          	INC	A			; SET Z IF DE == $FF
6815   259F CA BC 26    	JP	Z,PS_PRTNUL		; $FF == NO CONFIG DEFINED
6816   25A2             ;
6817   25A2             PS_PRTPC0:
6818   25A2 4B          	LD	C,E			; DISPLAY PIO TYPE
6819   25A3 3E C0       	LD	A,11000000B		; WHICH IS DEFINE BY
6820   25A5 11 23 28    	LD	DE,PIO_MODE_STR		; BITS 6 AND 7
6821   25A8 C3 EF 19    	JP	PRTIDXMSK
6822   25AB             ;	RET				; TRICK RETURN
6823   25AB             ;
6824   25AB             PS_PRTSC1:
6825   25AB             	; PRINT TERMINAL CONFIG
6826   25AB 79          	LD	A,C			; GET ATTRIBUTE VALUE
6827   25AC FE BF       	CP	$BF			; NO ATTACHED VDA
6828   25AE 28 1B       	JR	Z,PS_PRTSC2
6829   25B0 CD 3B 19    	PRTS("Video $")			; FORMATTING
6829   25B3 56 69 64 65 
6829   25B7 6F 20 24 
6830   25BA E6 0F       	AND	$0F			; ISOLATE VIDEO UNIT NUM
6831   25BC CD B2 1B    	CALL	PRTDECB			; PRINT IT
6832   25BF CD E6 18    	CALL	PC_COMMA
6833   25C2~            #IF (VDAEMU == EMUTYP_TTY)
6834   25C2~            	PRTS("TTY$")
6834   25C2~            	PRTS("TTY$")
6835   25C2             #ENDIF
6836   25C2             #IF (VDAEMU == EMUTYP_ANSI)
6837   25C2 CD 3B 19    	PRTS("ANSI$")
6837   25C5 41 4E 53 49 
6837   25C9 24 
6838   25CA             #ENDIF
6839   25CA C9          	RET
6840   25CB             ;
6841   25CB             PS_PRTSC2:
6842   25CB CD 3B 19    	PRTS("PropTerm$")		; ASSUME PROPELLER
6842   25CE 50 72 6F 70 
6842   25D2 54 65 72 6D 
6842   25D6 24 
6843   25D7 CD E6 18    	CALL	PC_COMMA
6844   25DA CD 3B 19    	PRTS("ANSI$")
6844   25DD 41 4E 53 49 
6844   25E1 24 
6845   25E2 C9          	RET
6846   25E3             ;
6847   25E3             ; PRINT ONE LINE VIDEO UNIT/DEVICE INFO, VIDEO UNIT INDEX IN C
6848   25E3             ;
6849   25E3             PS_VIDEO:
6850   25E3 C5          	PUSH	BC			; SAVE UNIT INDEX FOR LATER
6851   25E4             ;
6852   25E4             	; UNIT COLUMN
6853   25E4 CD 3B 19    	PRTS("Video $")
6853   25E7 56 69 64 65 
6853   25EB 6F 20 24 
6854   25EE 79          	LD	A,C			; MOVE UNIT NUM TO A
6855   25EF CD B2 1B    	CALL	PRTDECB			; PRINT IT, ASSUME SINGLE DIGIT
6856   25F2 CD 3B 19    	PRTS("     $")			; PAD TO NEXT COLUMN
6856   25F5 20 20 20 20 
6856   25F9 20 24 
6857   25FB             ;
6858   25FB             	; DEVICE COLUMN
6859   25FB 06 43       	LD	B,BF_VDADEV		; FUNC=GET DEVICE INFO, UNIT NUM STILL IN C
6860   25FD CF          	RST	08			; DE:=DEVTYP/NUM, H:=DISK ATTRIBUTES
6861   25FE C5          	PUSH	BC			; SAVE ATTRIBUTES
6862   25FF 21 46 28    	LD	HL,PS_VDVDU		; POINT TO VIDEO DEVICE TYPE NAME TABLE
6863   2602 CD A3 26    	CALL	PS_PRTDEV		; PRINT VIDEO DEVICE NMEMONIC PADDED TO FIELD WIDTH
6864   2605 D1          	POP	DE			; RECOVER ATTRIBUTES
6865   2606 D5          	PUSH	DE			; SAVE ATTRIBUTES AGAIN
6866   2607 CD 13 26    	CALL	PS_PRTVT		; PRINT VIDEO TYPE
6867   260A D1          	POP	DE			; RESTORE ATTRIBUTES
6868   260B C1          	POP	BC			; RESTORE UNIT NUM
6869   260C CD 19 26    	CALL	PS_PRTVC		; PRINT VIDEO CONFIG
6870   260F             ;
6871   260F CD 20 19    	CALL	NEWLINE
6872   2612 C9          	RET
6873   2613             ;
6874   2613             ; PRINT VIDEO TYPE (VIDEO ATTRIBUTE IN E)
6875   2613             ;
6876   2613             PS_PRTVT:
6877   2613 21 5B 28    	LD	HL,PS_VTCRT		; ASSUME CRT
6878   2616 C3 D2 26    	JP	PS_PRT18		; PRINT
6879   2619             ;
6880   2619             ; PRINT VIDEO CONFIG (UNIT IN C, ATTRIBUTE IN E)
6881   2619             ;
6882   2619             PS_PRTVC:
6883   2619 CD 3B 19    	PRTS("Text$")
6883   261C 54 65 78 74 
6883   2620 24 
6884   2621 CD E6 18    	CALL	PC_COMMA
6885   2624 06 41       	LD	B,BF_VDAQRY		; FUNC: QUERY FOR VDA CONFIG
6886   2626 CF          	RST	08			; D:=ROWS, E:=COLS
6887   2627 7B          	LD	A,E
6888   2628 CD B2 1B    	CALL	PRTDECB
6889   262B 3E 78       	LD	A,'x'
6890   262D CD FF 28    	CALL	COUT
6891   2630 7A          	LD	A,D
6892   2631 CD B2 1B    	CALL	PRTDECB
6893   2634 C9          	RET
6894   2635             ;
6895   2635             ; PRINT SOUND CONFIG
6896   2635             ;
6897   2635             PS_SOUND:
6898   2635 C5          	PUSH	BC
6899   2636             
6900   2636             	; UNIT COLUMN
6901   2636 CD 3B 19    	PRTS("Sound $")
6901   2639 53 6F 75 6E 
6901   263D 64 20 24 
6902   2640 79          	LD	A,C			; MOVE UNIT NUM TO A
6903   2641 CD B2 1B    	CALL	PRTDECB			; PRINT IT
6904   2644 FE 0A       	CP	10			; CHECK FOR MULTIPLE DIGITS
6905   2646 DC D7 18    	CALL	C,PC_SPACE		; EXTRA SPACE IF NEEDED
6906   2649 CD 3B 19    	PRTS("    $")			; PAD TO NEXT COLUMN
6906   264C 20 20 20 20 
6906   2650 24 
6907   2651             
6908   2651             	; DEVICE COLUMN
6909   2651             
6910   2651 C5          	PUSH	BC
6911   2652 59          	LD	E,C
6912   2653 AF          	XOR	A
6913   2654 11 5F 28    	LD	DE,PS_SDSND		; POINT TO DEVICE TYPE NAME TABLE
6914   2657 CD FE 19    	CALL	PRTIDXDEA		; PRINT  DEVICE NMEMONIC PADDED TO FIELD WIDTH
6915   265A 79          	LD	A,C			; MOVE UNIT NUM TO A
6916   265B CD B2 1B    	CALL	PRTDECB			; PRINT IT
6917   265E CD E1 18    	CALL	PC_COLON
6918   2661 3A 27 1A    	LD	A,(PRTIDXCNT)
6919   2664 D6 0B       	SUB	12-1			; SUBTRACT FIELD WIDTH (LESS THE COLON)
6920   2666 ED 44       	NEG				; MAKE IT A POSITIVE NUMBER
6921   2668 CD D8 26    	CALL	PS_PAD			; PAD AS NEEDED
6922   266B C1          	POP	BC
6923   266C             
6924   266C             	; DEVICE TYPE
6925   266C             ;
6926   266C 06 55       	LD	B,BF_SNDQUERY		; FUNC=GET DEVICE INFO, UNIT NUM STILL IN C
6927   266E 1E 04       	LD	E,BF_SNDQ_DEV
6928   2670 CF          	RST	08
6929   2671 C5          	PUSH	BC
6930   2672 48          	LD	C,B
6931   2673 3E F0       	LD	A,11110000B		; TYPE IS IN UPPER NIBBLE
6932   2675 11 63 28    	LD	DE,PS_SDSN76489
6933   2678 CD EF 19    	CALL	PRTIDXMSK
6934   267B CD CC 26    	CALL	PS_PAD18
6935   267E C1          	POP	BC
6936   267F             ;
6937   267F             	; DEVICE CHARACTERISTICS
6938   267F             ;
6939   267F 06 55       	LD	B,BF_SNDQUERY		; FUNC=GET DEVICE INFO, UNIT NUM STILL IN C
6940   2681 1E 01       	LD	E,BF_SNDQ_CHCNT
6941   2683 CF          	RST	08
6942   2684 78          	LD	A,B
6943   2685 CD B2 1B    	CALL	PRTDECB
6944   2688 3E 2B       	LD	A,'+'
6945   268A CD FF 28    	CALL	COUT
6946   268D 79          	LD	A,C
6947   268E CD B2 1B    	CALL	PRTDECB
6948   2691 CD 3B 19    	PRTS(" CHANNELS$")
6948   2694 20 43 48 41 
6948   2698 4E 4E 45 4C 
6948   269C 53 24 
6949   269E CD 20 19    	CALL	NEWLINE
6950   26A1             ;
6951   26A1 C1          	POP	BC
6952   26A2 C9          	RET
6953   26A3             ;
6954   26A3             ; PRINT DEVICE NMEMONIC, DEVTYP/NUM SPECIFIED IN DE
6955   26A3             ;
6956   26A3             PS_PRTDEV:
6957   26A3 EB          	EX	DE,HL
6958   26A4 4C          	LD	C,H
6959   26A5 3E F0       	LD	A,11110000B		; TYPE IS IN UPPER NIBBLE
6960   26A7 CD EF 19    	CALL	PRTIDXMSK
6961   26AA 7D          	LD	A,L			; UNIT NUMBER
6962   26AB CD B2 1B    	CALL	PRTDECB			; PRINT NUM, ASSUME 1 CHAR
6963   26AE CD E1 18    	CALL	PC_COLON		; PRINT COLON
6964   26B1 3A 27 1A    	LD 	A,(PRTIDXCNT)
6965   26B4 D6 0B       	SUB	12-2+1			; 12 CHAR FIELD - 1 POS FOR UNIT NUM AND 1 POS FOR COLON
6966   26B6 ED 44       	NEG
6967   26B8 CD D8 26    	CALL	PS_PAD			; PAD N SPACES (SPECIFIED IN A)
6968   26BB C9          	RET
6969   26BC             ;
6970   26BC             ; PRINT DEVICE MNEMONIC, DEVTYP/NUM SPECIFIED IN DE
6971   26BC             ;
6972   26BC             PS_PRTNUL:
6973   26BC 21 0A 27    	LD	HL,PS_STRNUL
6974   26BF             	; FALL THRU TO PS_PRT
6975   26BF             ;
6976   26BF             ; PRINT STRING AT (HL), $ TERM, RETURN CHARS PRINTED IN C
6977   26BF             ;
6978   26BF 0E 00       PS_PRT:	LD	C,0			; INIT CHAR COUNT
6979   26C1             PS_PRT1:
6980   26C1 7E          	LD	A,(HL)			; GET CHAR
6981   26C2 23          	INC	HL			; BUMP INDEX
6982   26C3 FE 24       	CP	'$'			; TERM?
6983   26C5 C8          	RET	Z			; IF SO, DONE
6984   26C6 CD FF 28    	CALL	COUT			; PRINT IT
6985   26C9 0C          	INC	C			; BUMP COUNTER
6986   26CA 18 F5       	JR	PS_PRT1			; AND LOOP
6987   26CC             ;
6988   26CC             ; PAD 18 CHARACTER FIELD
6989   26CC             ;
6990   26CC             PS_PAD18:
6991   26CC 3A 27 1A    	LD	A,(PRTIDXCNT)
6992   26CF 4F          	LD	C,A
6993   26D0 18 03       	JR	PS_PRT18A
6994   26D2             ;
6995   26D2             ; PRINT STRING AT HL IN 18 CHARACTER FIELD
6996   26D2             ;
6997   26D2             PS_PRT18:
6998   26D2 CD BF 26    	CALL	PS_PRT			; PRINT $ TERM STRING AT (HL), C:=CHARS PRINTED
6999   26D5             PS_PRT18A:
7000   26D5 3E 12       	LD	A,18			; 18 CHAR FIELD
7001   26D7 91          	SUB	C
7002   26D8             ;	CALL	PS_PAD			; PAD N SPACES (SPECIFIED IN A)
7003   26D8             ;
7004   26D8             ; PAD N SPACES SPECIFIED IN A
7005   26D8             ;
7006   26D8 47          PS_PAD:	LD	B,A
7007   26D9 3E 20       	LD	A,' '
7008   26DB             PS_PAD1:
7009   26DB CD FF 28    	CALL	COUT
7010   26DE 10 FB       	DJNZ	PS_PAD1
7011   26E0 C9          	RET
7012   26E1             ;
7013   26E1 20 5A 38 30 HB_CPU_STR:	.TEXT	" Z80$"
7013   26E5 24 
7014   26E6 20 5A 38 30 		.TEXT	" Z80180$"
7014   26EA 31 38 30 24 
7015   26EE 20 5A 38 53 		.TEXT	" Z8S180-K$"
7015   26F2 31 38 30 2D 
7015   26F6 4B 24 
7016   26F8 20 5A 38 53 		.TEXT	" Z8S180-N$"
7016   26FC 31 38 30 2D 
7016   2700 4E 24 
7017   2702 20 5A 38 30 		.TEXT	" Z80280$"
7017   2706 32 38 30 24 
7018   270A             ;
7019   270A 2D 2D 24    PS_STRNUL	.TEXT	"--$"		; DISPLAY STRING FOR NUL VALUE
7020   270D             ;
7021   270D             ; DISK DEVICE STRINGS
7022   270D             ;
7023   270D 4D 44 24    PS_DDMD		.TEXT	"MD$"
7024   2710 46 44 24    PS_DDFD		.TEXT	"FD$"
7025   2713 52 46 24    PS_DDRF		.TEXT	"RF$"
7026   2716 49 44 45 24 PS_DDIDE	.TEXT	"IDE$"
7027   271A 41 54 41 50 PS_DDATAPI	.TEXT	"ATAPI$"
7027   271E 49 24 
7028   2720 50 50 49 44 PS_DDPPIDE	.TEXT	"PPIDE$"
7028   2724 45 24 
7029   2726 53 44 24    PS_DDSD		.TEXT	"SD$"
7030   2729 50 52 50 53 PS_DDPRPSD	.TEXT	"PRPSD$"
7030   272D 44 24 
7031   272F 50 50 50 53 PS_DDPPPSD	.TEXT	"PPPSD$"
7031   2733 44 24 
7032   2735 48 44 53 4B PS_DDHDSK	.TEXT	"HDSK$"
7032   2739 24 
7033   273A             ;
7034   273A             ; DISK TYPE STRINGS
7035   273A             ;
7036   273A 46 6C 6F 70 PS_DTFLOP	.TEXT	"Floppy Disk$"
7036   273E 70 79 20 44 
7036   2742 69 73 6B 24 
7037   2746 48 61 72 64 PS_DTHARD	.TEXT	"Hard Disk$"
7037   274A 20 44 69 73 
7037   274E 6B 24 
7038   2750 43 6F 6D 70 PS_DTCF		.TEXT	"CompactFlash$"
7038   2754 61 63 74 46 
7038   2758 6C 61 73 68 
7038   275C 24 
7039   275D 53 44 20 43 PS_DTSD		.TEXT	"SD Card$"
7039   2761 61 72 64 24 
7040   2765 55 53 42 20 PS_DTUSB	.TEXT	"USB Drive$"
7040   2769 44 72 69 76 
7040   276D 65 24 
7041   276F 52 4F 4D 20 PS_DTROM	.TEXT	"ROM Disk$"
7041   2773 44 69 73 6B 
7041   2777 24 
7042   2778 52 41 4D 20 PS_DTRAM	.TEXT	"RAM Disk$"
7042   277C 44 69 73 6B 
7042   2780 24 
7043   2781 52 41 4D 20 PS_DTRF		.TEXT	"RAM Floppy$"
7043   2785 46 6C 6F 70 
7043   2789 70 79 24 
7044   278C 46 6C 61 73 PS_DTFSH	.TEXT	"Flash Drive$"
7044   2790 68 20 44 72 
7044   2794 69 76 65 24 
7045   2798 3F 3F 3F 24 PS_DTOTHER	.TEXT	"???$"
7046   279C             ;
7047   279C             ; FLOPPY ATTRIBUTE STRINGS
7048   279C             ;
7049   279C 38 22 2C 24 PS_FLP_FSTR:	.TEXT	"8\",$"		; PS_FLP8
7050   27A0 35 2E 32 35 		.TEXT	"5.25\",$"	; PS_FLP5
7050   27A4 22 2C 24 
7051   27A7 33 2E 35 22 		.TEXT	"3.5\",$"	; PS_FLP3
7051   27AB 2C 24 
7052   27AD 3F 3F 3F 22 		.TEXT	"???\",$"	; PS_FLPN
7052   27B1 2C 24 
7053   27B3             ;
7054   27B3 53 53 2F 24 PS_FLP_SSTR:	.TEXT	"SS/$"		; PS_FLPSS
7055   27B7 44 53 2F 24 		.TEXT	"DS/$"		; PS_FLPDS
7056   27BB             ;
7057   27BB 53 44 24    PS_FLP_DSTR:	.TEXT	"SD$"		; PS_FLPSD
7058   27BE 44 44 24    		.TEXT	"DD$"		; PS_FLPDD
7059   27C1 48 44 24    		.TEXT	"HD$"		; PS_FLPHD
7060   27C4 45 44 24    		.TEXT	"ED$"		; PS_FLPED
7061   27C7             ;
7062   27C7             ; CHARACTER DEVICE STRINGS
7063   27C7             ;
7064   27C7 55 41 52 54 PS_SDUART	.TEXT	"UART$"
7064   27CB 24 
7065   27CC 41 53 43 49 PS_SDASCI	.TEXT	"ASCI$"
7065   27D0 24 
7066   27D1 54 45 52 4D PS_SDTERM	.TEXT	"TERM$"
7066   27D5 24 
7067   27D6 50 52 50 43 PS_SDPRPCON	.TEXT	"PRPCON$"
7067   27DA 4F 4E 24 
7068   27DD 50 50 50 43 PS_SDPPPCON	.TEXT	"PPPCON$"
7068   27E1 4F 4E 24 
7069   27E4 53 49 4F 24 PS_SDSIO	.TEXT	"SIO$"
7070   27E8 41 43 49 41 PS_SDACIA	.TEXT	"ACIA$"
7070   27EC 24 
7071   27ED 50 49 4F 24 PS_SDPIO	.TEXT	"PIO$"
7072   27F1 55 46 24    PS_SDUF		.TEXT	"UF$"
7073   27F4 44 55 41 52 PS_SDDUART	.TEXT	"DUART$"
7073   27F8 54 24 
7074   27FA 5A 32 55 24 PS_SDZ2U	.TEXT	"Z2U$"
7075   27FE 4C 50 54 24 PS_SDLPT	.TEXT	"LPT$"
7076   2802             ;
7077   2802             ; CHARACTER SUB TYPE STRINGS
7078   2802             ;
7079   2802 52 53 2D 32 PS_STRS232	.TEXT	"RS-232$"
7079   2806 33 32 24 
7080   2809 54 65 72 6D PS_STTERM	.TEXT	"Terminal$"
7080   280D 69 6E 61 6C 
7080   2811 24 
7081   2812 50 61 72 61 PS_STPPT	.TEXT	"Parallel$"
7081   2816 6C 6C 65 6C 
7081   281A 24 
7082   281B             ;
7083   281B 4E 4F 4E 45 PS_STPARMAP	.DB	"NONENMNS"
7083   281F 4E 4D 4E 53 
7084   2823             ;
7085   2823             ; PARALLEL TYPE STRINGS
7086   2823             ;
7087   2823 4F 75 74 70 PIO_MODE_STR:	.TEXT	"Output$"
7087   2827 75 74 24 
7088   282A 49 6E 70 75 		.TEXT	"Input$"
7088   282E 74 24 
7089   2830 42 69 64 69 		.TEXT	"Bidirectional$"
7089   2834 72 65 63 74 
7089   2838 69 6F 6E 61 
7089   283C 6C 24 
7090   283E 42 69 74 43 		.TEXT	"BitCtrl$"
7090   2842 74 72 6C 24 
7091   2846             ;
7092   2846             ; VIDEO DEVICE STRINGS
7093   2846             ;
7094   2846 56 44 55 24 PS_VDVDU	.TEXT	"VDU$"
7095   284A 43 56 44 55 PS_VDCVDU	.TEXT	"CVDU$"
7095   284E 24 
7096   284F 47 44 43 24 PS_VDGDC	.TEXT	"GDC$"
7097   2853 54 4D 53 24 PS_VDTMS	.TEXT	"TMS$"
7098   2857 56 47 41 24 PS_VDVGA	.TEXT	"VGA$"
7099   285B             ;
7100   285B             ; VIDEO TYPE STRINGS
7101   285B             ;
7102   285B 43 52 54 24 PS_VTCRT	.TEXT	"CRT$"
7103   285F             ;
7104   285F             ; SOUND DEVICE STRINGS
7105   285F             ;
7106   285F 53 4E 44 24 PS_SDSND	.TEXT	"SND$"
7107   2863             ;
7108   2863             ; SOUND TYPE STRINGS
7109   2863             ;
7110   2863 53 4E 37 36 PS_SDSN76489	.TEXT	"SN76489$"
7110   2867 34 38 39 24 
7111   286B 41 59 2D 33 PS_SDAY38910	.TEXT	"AY-3-8910$"
7111   286F 2D 38 39 31 
7111   2873 30 24 
7112   2875 49 2F 4F 20 PS_SDBITMODE	.TEXT	"I/O PORT$"
7112   2879 50 4F 52 54 
7112   287D 24 
7113   287E 59 4D 32 36 PS_SDYM2612	.TEXT	"YM2612$"
7113   2882 31 32 24 
7114   2885             ;
7115   2885             ;			 0	   1	     2	       3	 4	   5	     6	       7
7116   2885             ;			 01234567890123456789012345678901234567890123456789012345678901234567890123456789
7117   2885 55 6E 69 74 PS_STRHDR	.TEXT	"Unit        Device      Type              Capacity/Mode\r\n"
7117   2889 20 20 20 20 
7117   288D 20 20 20 20 
7117   2891 44 65 76 69 
7117   2895 63 65 20 20 
7117   2899 20 20 20 20 
7117   289D 54 79 70 65 
7117   28A1 20 20 20 20 
7117   28A5 20 20 20 20 
7117   28A9 20 20 20 20 
7117   28AD 20 20 43 61 
7117   28B1 70 61 63 69 
7117   28B5 74 79 2F 4D 
7117   28B9 6F 64 65 0D 
7117   28BD 0A 
7118   28BE 2D 2D 2D 2D 		.TEXT	"----------  ----------  ----------------  --------------------\r\n$"
7118   28C2 2D 2D 2D 2D 
7118   28C6 2D 2D 20 20 
7118   28CA 2D 2D 2D 2D 
7118   28CE 2D 2D 2D 2D 
7118   28D2 2D 2D 20 20 
7118   28D6 2D 2D 2D 2D 
7118   28DA 2D 2D 2D 2D 
7118   28DE 2D 2D 2D 2D 
7118   28E2 2D 2D 2D 2D 
7118   28E6 20 20 2D 2D 
7118   28EA 2D 2D 2D 2D 
7118   28EE 2D 2D 2D 2D 
7118   28F2 2D 2D 2D 2D 
7118   28F6 2D 2D 2D 2D 
7118   28FA 2D 2D 0D 0A 
7118   28FE 24 
7119   28FF             ;
7120   28FF             ;==================================================================================================
7121   28FF             ; CONSOLE CHARACTER I/O HELPER ROUTINES (REGISTERS PRESERVED)
7122   28FF             ;==================================================================================================
7123   28FF             ;
7124   28FF             ; OUTPUT CHARACTER FROM A
7125   28FF             ;
7126   28FF             COUT:
7127   28FF             	; SAVE ALL INCOMING REGISTERS
7128   28FF F5          	PUSH	AF
7129   2900 C5          	PUSH	BC
7130   2901 D5          	PUSH	DE
7131   2902 E5          	PUSH	HL
7132   2903             ;
7133   2903             	; GET CURRENT CONSOLE UNIT
7134   2903 5F          	LD	E,A			; TEMPORARILY STASH OUTPUT CHAR IN E
7135   2904 3A 12 01    	LD	A,(CB_CONDEV)		; GET CONSOLE UNIT BYTE
7136   2907 FE FF       	CP	$FF			; TEST FOR $FF (HBIOS NOT READY)
7137   2909 28 08       	JR	Z,COUT1			; IF NOT READY, TRY DEBUG OUTPUT
7138   290B             ;
7139   290B             	; USE HBIOS
7140   290B 4F          	LD	C,A			; CONSOLE UNIT TO C
7141   290C 06 01       	LD	B,BF_CIOOUT		; HBIOS FUNC: OUTPUT CHAR
7142   290E CD AF 07    	CALL	CIO_DISPATCH		; CALL CIO DISPATCHER DIRECTLY
7143   2911 18 00       	JR	COUT2			; CONTINUE
7144   2913             ;
7145   2913             COUT1:
7146   2913             ;
7147   2913~            #IF (WBWDEBUG == USEXIO)
7148   2913~            	LD	A,E			; GET OUTPUT CHAR BACK TO ACCUM
7149   2913~            	CALL	XIO_OUTC		; OUTPUT VIA XIO
7150   2913             #ENDIF
7151   2913             ;
7152   2913~            #IF (WBWDEBUG == USEMIO)
7153   2913~            	LD	A,E
7154   2913~            	CALL	MIO_OUTC		; OUTPUT VIA MIO
7155   2913             #ENDIF
7156   2913             ;
7157   2913             COUT2:
7158   2913             	; RESTORE ALL REGISTERS
7159   2913 E1          	POP	HL
7160   2914 D1          	POP	DE
7161   2915 C1          	POP	BC
7162   2916 F1          	POP	AF
7163   2917 C9          	RET
7164   2918             ;
7165   2918             ; INPUT CHARACTER TO A
7166   2918             ;
7167   2918             CIN:
7168   2918             	; SAVE INCOMING REGISTERS (AF IS OUTPUT)
7169   2918 C5          	PUSH	BC
7170   2919 D5          	PUSH	DE
7171   291A E5          	PUSH	HL
7172   291B             ;
7173   291B 3A 12 01    	LD	A,(CB_CONDEV)		; GET CONSOLE UNIT BYTE
7174   291E FE FF       	CP	$FF			; TEST FOR $FF (HBIOS NOT READY)
7175   2920 28 09       	JR	Z,CIN1			; IF NOT READY, TRY DEBUG INPUT
7176   2922             ;
7177   2922             	; USE HBIOS
7178   2922 4F          	LD	C,A			; CONSOLE UNIT TO C
7179   2923 06 00       	LD	B,BF_CIOIN		; HBIOS FUNC: INPUT CHAR
7180   2925 CD AF 07    	CALL	CIO_DISPATCH		; CALL CIO DISPATCHER DIRECTLY
7181   2928 7B          	LD	A,E			; RESULTANT CHAR TO A
7182   2929 18 00       	JR	CIN2			; CONTINUE
7183   292B             ;
7184   292B             CIN1:
7185   292B             ;
7186   292B~            #IF (WBWDEBUG == USEXIO)
7187   292B~            	CALL	XIO_INC			; GET CHAR
7188   292B             #ENDIF
7189   292B             ;
7190   292B~            #IF (WBWDEBUG == USEMIO)
7191   292B~            	CALL	MIO_INC			; GET CHAR
7192   292B             #ENDIF
7193   292B             ;
7194   292B             CIN2:
7195   292B             ;
7196   292B             	; RESTORE REGISTERS (AF IS OUTPUT)
7197   292B E1          	POP	HL
7198   292C D1          	POP	DE
7199   292D C1          	POP	BC
7200   292E C9          	RET
7201   292F             ;
7202   292F             ; RETURN INPUT STATUS IN A (0 = NO CHAR, !=0 CHAR WAITING)
7203   292F             ;
7204   292F             CST:
7205   292F             	; SAVE INCOMING REGISTERS (AF IS OUTPUT)
7206   292F C5          	PUSH	BC
7207   2930 D5          	PUSH	DE
7208   2931 E5          	PUSH	HL
7209   2932             ;
7210   2932 3A 12 01    	LD	A,(CB_CONDEV)		; GET CONSOLE UNIT BYTE
7211   2935 FE FF       	CP	$FF			; TEST FOR $FF (HBIOS NOT READY)
7212   2937 28 08       	JR	Z,CST1			; IIF NOT READY, TRY DEBUG DEBUG STATUS
7213   2939             ;
7214   2939             	; USE HBIOS
7215   2939 4F          	LD	C,A			; CONSOLE UNIT TO C
7216   293A 06 02       	LD	B,BF_CIOIST		; HBIOS FUNC: INPUT STATUS
7217   293C CD AF 07    	CALL	CIO_DISPATCH		; CALL CIO DISPATCHER DIRECTLY
7218   293F 18 00       	JR	CST2			; CONTINUE
7219   2941             ;
7220   2941             CST1:
7221   2941             ;
7222   2941~            #IF (WBWDEBUG == USEXIO)
7223   2941~            	CALL	XIO_IST			; GET STATUS
7224   2941             #ENDIF
7225   2941             ;
7226   2941~            #IF (WBWDEBUG == USEMIO)
7227   2941~            	CALL	MIO_IST			; GET STATUS
7228   2941             #ENDIF
7229   2941             ;
7230   2941             CST2:
7231   2941             	; RESTORE REGISTERS (AF IS OUTPUT)
7232   2941 E1          	POP	HL
7233   2942 D1          	POP	DE
7234   2943 C1          	POP	BC
7235   2944 C9          	RET
7236   2945             ;
7237   2945             ;==================================================================================================
7238   2945             ;   MISCELLANEOUS UTILITY FUNCTIONS
7239   2945             ;==================================================================================================
7240   2945             ;
7241   2945             ; SET HL TO IY+A, A IS TRASHED
7242   2945             ;
7243   2945             LDHLIYA:
7244   2945 FD E5       	PUSH	IY			; COPY INSTANCE DATA PTR
7245   2947 E1          	POP	HL			; ... TO HL
7246   2948             	;JP	ADDHLA			; APPLY OFFSET TO HL AND RETURN
7247   2948 85          	ADD	A,L			; ADD OFFSET TO LSB
7248   2949 6F          	LD	L,A			; ... PUT BACK IN L
7249   294A D0          	RET	NC			; DONE IF CF NOT SET
7250   294B 24          	INC	H			; IF CF SET, BUMP MSB
7251   294C C9          	RET				; ... AND RETURN
7252   294D             ;
7253   294D             ; CONVERT AN HBIOS STANDARD HARD DISK CHS ADDRESS TO
7254   294D             ; AN LBA ADDRESS.  A STANDARD HBIOS HARD DISK IS ASSUMED
7255   294D             ; TO HAVE 16 SECTORS PER TRACK AND 16 HEADS PER CYLINDER.
7256   294D             ;
7257   294D             ; INPUT:  HL=TRACK, D=HEAD, E=SECTOR
7258   294D             ; OUTPUT: DE:HL=32 BIT LBA ADDRESS (D:7 IS NOT SET IN THE RESULT)
7259   294D             ;
7260   294D             HB_CHS2LBA:
7261   294D             ;
7262   294D 7A          	LD	A,D			; HEAD TO A
7263   294E 07          	RLCA				; LEFT SHIFT TO HIGH NIBBLE
7264   294F 07          	RLCA				; ... DEPENDS ON HIGH
7265   2950 07          	RLCA				; ... NIBBLE BEING 0 SINCE
7266   2951 07          	RLCA				; ... IT ROTATES INTO LOW NIBBLE
7267   2952 B3          	OR	E			; COMBINE WITH SECTOR (HIGH NIBBLE MUST BE ZERO)
7268   2953 16 00       	LD	D,0
7269   2955 5C          	LD	E,H
7270   2956 65          	LD	H,L
7271   2957 6F          	LD	L,A
7272   2958 AF          	XOR	A
7273   2959 C9          	RET
7274   295A             ;
7275   295A             ;==================================================================================================
7276   295A             ;   HBIOS GLOBAL DATA
7277   295A             ;==================================================================================================
7278   295A             ;
7279   295A 00          IDLECOUNT	.DB	0
7280   295B             ;
7281   295B 00 00       HEAPCURB	.DW	0		; MARK HEAP ADDRESS AFTER INITIALIZATION
7282   295D             ;
7283   295D 00 00 00 00 HB_TICKS	.FILL	4,0		; 32 BIT TICK COUNTER
7284   2961 32          HB_SECTCK	.DB	TICKFREQ	; TICK COUNTER FOR FRACTIONAL SECONDS
7285   2962 00 00 00 00 HB_SECS		.FILL	4,0		; 32 BIT SECONDS COUNTER
7286   2966             ;
7287   2966 00          HB_CPUTYPE	.DB	0		; 0=Z80, 1=80180, 2=SL1960, 3=ASCI BRG
7288   2967 00 00       HB_CPUOSC	.DW	CPUOSC		; ACTUAL CPU HARDWARE OSC FREQ IN KHZ
7289   2969             ;
7290   2969 00          HB_BATCOND	.DB	0		; BATTERY CONDITION (0=LOW, 1=OK)
7291   296A             ;
7292   296A 00          RTCDEFVAL	.DB	RTCDEF		; STORAGE FOR RTC DEFAULT VALUE
7293   296B             ;
7294   296B~            #IF (BT_REC_TYPE != BT_REC_NONE)
7295   296B~            HB_BOOT_REC	.DB	0		; BOOT MODE (0=NORMAL, 1=RECOVERY MODE)
7296   296B             #ENDIF
7297   296B             ;
7298   296B 52 6F 6D 57 STR_BANNER	.DB	"RomWBW HBIOS v", BIOSVER, ", ", TIMESTAMP, "$"
7298   296F 42 57 20 48 
7298   2973 42 49 4F 53 
7298   2977 20 76 33 2E 
7298   297B 32 2E 31 2C 
7298   297F 20 32 30 32 
7298   2983 33 2D 31 30 
7298   2987 2D 32 33 24 
7299   298B 48 45 41 54 STR_PLATFORM	.DB	PLATFORM_NAME, "$"
7299   298F 48 20 5B 48 
7299   2993 45 41 54 48 
7299   2997 5F 46 50 5D 
7299   299B 24 
7300   299C 2A 2A 2A 20 STR_SWITCH	.DB	"*** Activating CRT Console ***$"
7300   29A0 41 63 74 69 
7300   29A4 76 61 74 69 
7300   29A8 6E 67 20 43 
7300   29AC 52 54 20 43 
7300   29B0 6F 6E 73 6F 
7300   29B4 6C 65 20 2A 
7300   29B8 2A 2A 24 
7301   29BB 0D 0A 2A 2A STR_BADINT	.DB	"\r\n*** BAD INT ***\r\n$"
7301   29BF 2A 20 42 41 
7301   29C3 44 20 49 4E 
7301   29C7 54 20 2A 2A 
7301   29CB 2A 0D 0A 24 
7302   29CF 0D 0A 0D 0A STR_LOWBAT	.DB	"\r\n\r\n+++ LOW BATTERY +++$"
7302   29D3 2B 2B 2B 20 
7302   29D7 4C 4F 57 20 
7302   29DB 42 41 54 54 
7302   29DF 45 52 59 20 
7302   29E3 2B 2B 2B 24 
7303   29E7             ;
7304   29E7 0D 0A 3E 3E STR_PANIC	.TEXT	"\r\n>>> PANIC: $"
7304   29EB 3E 20 50 41 
7304   29EF 4E 49 43 3A 
7304   29F3 20 24 
7305   29F5 0D 0A 3E 3E STR_SYSCHK	.TEXT	"\r\n>>> SYSCHK: $"
7305   29F9 3E 20 53 59 
7305   29FD 53 43 48 4B 
7305   2A01 3A 20 24 
7306   2A04 0D 0A 43 6F STR_CONTINUE	.TEXT	"\r\nContinue (Y/N)? $"
7306   2A08 6E 74 69 6E 
7306   2A0C 75 65 20 28 
7306   2A10 59 2F 4E 29 
7306   2A14 3F 20 24 
7307   2A17 0D 0A 0D 0A STR_RESTART	.TEXT	"\r\n\r\n>>> Press hardware reset button to restart system\r\n\r\n$"
7307   2A1B 3E 3E 3E 20 
7307   2A1F 50 72 65 73 
7307   2A23 73 20 68 61 
7307   2A27 72 64 77 61 
7307   2A2B 72 65 20 72 
7307   2A2F 65 73 65 74 
7307   2A33 20 62 75 74 
7307   2A37 74 6F 6E 20 
7307   2A3B 74 6F 20 72 
7307   2A3F 65 73 74 61 
7307   2A43 72 74 20 73 
7307   2A47 79 73 74 65 
7307   2A4B 6D 0D 0A 0D 
7307   2A4F 0A 24 
7308   2A51             ;
7309   2A51~            #IF (DSKYENABLE)	;	'H','B','I','O',' ',' ',' ',' '
7310   2A51~              #IF (DSKYMODE == DSKYMODE_V1)
7311   2A51~            MSG_HBVER		.DB	$3E,$7F,$0A,$7B,$00,$00,$00,$00	; "HBIO    "
7312   2A51~              #ENDIF
7313   2A51~              #IF (DSKYMODE == DSKYMODE_NG)
7314   2A51~            MSG_HBVER		.DB	$76,$7F,$30,$3F,$00,$00,$00,$00	; "HBIO    "
7315   2A51~              #ENDIF
7316   2A51             #ENDIF
7317   2A51             ;
7318   2A51 00          HB_APPBNK	.DB	0		; START BANK WHEN RUN IN APP MODE
7319   2A52             ;
7320   2A52 00          HB_CURSEC	.DB	0		; CURRENT SECOND (TEMP)
7321   2A53             ;
7322   2A53 00 00 00 00 HB_BCDTMP	.FILL	5,0		; BCD NUMBER STORAGE (TEMP)
7322   2A57 00 
7323   2A58             ;
7324   2A58 00          HB_BOOTCONSAV	.DB	0		; INITIAL BOOT CONSOLE SAVE AREA
7325   2A59 00 00       HB_CONCFGSAV	.DW	0		; CONSOLE CONFIG SAVE AREA
7326   2A5B             ;
7327   2A5B 00 00 00 00 HB_WRKBUF	.FILL	512,0		; INTERNAL DISK BUFFER
7327   2A5F 00 00 00 00 
7327   2A63 00 00 00 00 
7327   2A67 00 00 00 00 
7327   2A6B 00 00 00 00 
7327   2A6F 00 00 00 00 
7327   2A73 00 00 00 00 
7327   2A77 00 00 00 00 
7327   2A7B 00 00 00 00 
7327   2A7F 00 00 00 00 
7327   2A83 00 00 00 00 
7327   2A87 00 00 00 00 
7327   2A8B 00 00 00 00 
7327   2A8F 00 00 00 00 
7327   2A93 00 00 00 00 
7327   2A97 00 00 00 00 
7327   2A9B 00 00 00 00 
7327   2A9F 00 00 00 00 
7327   2AA3 00 00 00 00 
7327   2AA7 00 00 00 00 
7327   2AAB 00 00 00 00 
7327   2AAF 00 00 00 00 
7327   2AB3 00 00 00 00 
7327   2AB7 00 00 00 00 
7327   2ABB 00 00 00 00 
7327   2ABF 00 00 00 00 
7327   2AC3 00 00 00 00 
7327   2AC7 00 00 00 00 
7327   2ACB 00 00 00 00 
7327   2ACF 00 00 00 00 
7327   2AD3 00 00 00 00 
7327   2AD7 00 00 00 00 
7327   2ADB 00 00 00 00 
7327   2ADF 00 00 00 00 
7327   2AE3 00 00 00 00 
7327   2AE7 00 00 00 00 
7327   2AEB 00 00 00 00 
7327   2AEF 00 00 00 00 
7327   2AF3 00 00 00 00 
7327   2AF7 00 00 00 00 
7327   2AFB 00 00 00 00 
7327   2AFF 00 00 00 00 
7327   2B03 00 00 00 00 
7327   2B07 00 00 00 00 
7327   2B0B 00 00 00 00 
7327   2B0F 00 00 00 00 
7327   2B13 00 00 00 00 
7327   2B17 00 00 00 00 
7327   2B1B 00 00 00 00 
7327   2B1F 00 00 00 00 
7327   2B23 00 00 00 00 
7327   2B27 00 00 00 00 
7327   2B2B 00 00 00 00 
7327   2B2F 00 00 00 00 
7327   2B33 00 00 00 00 
7327   2B37 00 00 00 00 
7327   2B3B 00 00 00 00 
7327   2B3F 00 00 00 00 
7327   2B43 00 00 00 00 
7327   2B47 00 00 00 00 
7327   2B4B 00 00 00 00 
7327   2B4F 00 00 00 00 
7327   2B53 00 00 00 00 
7327   2B57 00 00 00 00 
7327   2B5B 00 00 00 00 
7327   2B5F 00 00 00 00 
7327   2B63 00 00 00 00 
7327   2B67 00 00 00 00 
7327   2B6B 00 00 00 00 
7327   2B6F 00 00 00 00 
7327   2B73 00 00 00 00 
7327   2B77 00 00 00 00 
7327   2B7B 00 00 00 00 
7327   2B7F 00 00 00 00 
7327   2B83 00 00 00 00 
7327   2B87 00 00 00 00 
7327   2B8B 00 00 00 00 
7327   2B8F 00 00 00 00 
7327   2B93 00 00 00 00 
7327   2B97 00 00 00 00 
7327   2B9B 00 00 00 00 
7327   2B9F 00 00 00 00 
7327   2BA3 00 00 00 00 
7327   2BA7 00 00 00 00 
7327   2BAB 00 00 00 00 
7327   2BAF 00 00 00 00 
7327   2BB3 00 00 00 00 
7327   2BB7 00 00 00 00 
7327   2BBB 00 00 00 00 
7327   2BBF 00 00 00 00 
7327   2BC3 00 00 00 00 
7327   2BC7 00 00 00 00 
7327   2BCB 00 00 00 00 
7327   2BCF 00 00 00 00 
7327   2BD3 00 00 00 00 
7327   2BD7 00 00 00 00 
7327   2BDB 00 00 00 00 
7327   2BDF 00 00 00 00 
7327   2BE3 00 00 00 00 
7327   2BE7 00 00 00 00 
7327   2BEB 00 00 00 00 
7327   2BEF 00 00 00 00 
7327   2BF3 00 00 00 00 
7327   2BF7 00 00 00 00 
7327   2BFB 00 00 00 00 
7327   2BFF 00 00 00 00 
7327   2C03 00 00 00 00 
7327   2C07 00 00 00 00 
7327   2C0B 00 00 00 00 
7327   2C0F 00 00 00 00 
7327   2C13 00 00 00 00 
7327   2C17 00 00 00 00 
7327   2C1B 00 00 00 00 
7327   2C1F 00 00 00 00 
7327   2C23 00 00 00 00 
7327   2C27 00 00 00 00 
7327   2C2B 00 00 00 00 
7327   2C2F 00 00 00 00 
7327   2C33 00 00 00 00 
7327   2C37 00 00 00 00 
7327   2C3B 00 00 00 00 
7327   2C3F 00 00 00 00 
7327   2C43 00 00 00 00 
7327   2C47 00 00 00 00 
7327   2C4B 00 00 00 00 
7327   2C4F 00 00 00 00 
7327   2C53 00 00 00 00 
7327   2C57 00 00 00 00 
7328   2C5B             ;
7329   2C5B             HB_END		.EQU	$
7330   2C5B             ;
7331   2C5B             SLACK		.EQU	BNKTOP - $
7332   2C5B             		.ECHO	"HBIOS space remaining: "
7333   2C5B             		.ECHO	SLACK
7334   2C5B             		.ECHO	" bytes.\n"
7335   2C5B             
7336   2C5B~            #IF (SLACK<0)
7337   2C5B~            		.ECHO	"*** ERROR: HBIOS too big.\n"
7338   2C5B~            		!!!	; FORCE AN ASSEMBLY ERROR
7339   2C5B             #ENDIF
7340   2C5B             ;
7341   2C5B~            #IF (CCP_SIZ > SLACK)
7342   2C5B~            		.ECHO	"*** ERROR: Insufficient space for CCP cache.\n"
7343   2C5B~            		!!!	; FORCE AN ASSEMBLY ERROR
7344   2C5B             #ENDIF
7345   2C5B             ;
7346   2C5B             #IFDEF ROMBOOT
7347   2C5B               #IF (ROMSIZE > 0)
7348   2C5B FF FF FF FF 		.FILL	SLACK
7348   2C5F FF FF FF FF 
7348   2C63 FF FF FF FF 
7348   2C67 FF FF FF FF 
7348   2C6B FF FF FF FF 
7348   2C6F FF FF FF FF 
7348   2C73 FF FF FF FF 
7348   2C77 FF FF FF FF 
7348   2C7B FF FF FF FF 
7348   2C7F FF FF FF FF 
7348   2C83 FF FF FF FF 
7348   2C87 FF FF FF FF 
7348   2C8B FF FF FF FF 
7348   2C8F FF FF FF FF 
7348   2C93 FF FF FF FF 
7348   2C97 FF FF FF FF 
7348   2C9B FF FF FF FF 
7348   2C9F FF FF FF FF 
7348   2CA3 FF FF FF FF 
7348   2CA7 FF FF FF FF 
7348   2CAB FF FF FF FF 
7348   2CAF FF FF FF FF 
7348   2CB3 FF FF FF FF 
7348   2CB7 FF FF FF FF 
7348   2CBB FF FF FF FF 
7348   2CBF FF FF FF FF 
7348   2CC3 FF FF FF FF 
7348   2CC7 FF FF FF FF 
7348   2CCB FF FF FF FF 
7348   2CCF FF FF FF FF 
7348   2CD3 FF FF FF FF 
7348   2CD7 FF FF FF FF 
7348   2CDB FF FF FF FF 
7348   2CDF FF FF FF FF 
7348   2CE3 FF FF FF FF 
7348   2CE7 FF FF FF FF 
7348   2CEB FF FF FF FF 
7348   2CEF FF FF FF FF 
7348   2CF3 FF FF FF FF 
7348   2CF7 FF FF FF FF 
7348   2CFB FF FF FF FF 
7348   2CFF FF FF FF FF 
7348   2D03 FF FF FF FF 
7348   2D07 FF FF FF FF 
7348   2D0B FF FF FF FF 
7348   2D0F FF FF FF FF 
7348   2D13 FF FF FF FF 
7348   2D17 FF FF FF FF 
7348   2D1B FF FF FF FF 
7348   2D1F FF FF FF FF 
7348   2D23 FF FF FF FF 
7348   2D27 FF FF FF FF 
7348   2D2B FF FF FF FF 
7348   2D2F FF FF FF FF 
7348   2D33 FF FF FF FF 
7348   2D37 FF FF FF FF 
7348   2D3B FF FF FF FF 
7348   2D3F FF FF FF FF 
7348   2D43 FF FF FF FF 
7348   2D47 FF FF FF FF 
7348   2D4B FF FF FF FF 
7348   2D4F FF FF FF FF 
7348   2D53 FF FF FF FF 
7348   2D57 FF FF FF FF 
7348   2D5B FF FF FF FF 
7348   2D5F FF FF FF FF 
7348   2D63 FF FF FF FF 
7348   2D67 FF FF FF FF 
7348   2D6B FF FF FF FF 
7348   2D6F FF FF FF FF 
7348   2D73 FF FF FF FF 
7348   2D77 FF FF FF FF 
7348   2D7B FF FF FF FF 
7348   2D7F FF FF FF FF 
7348   2D83 FF FF FF FF 
7348   2D87 FF FF FF FF 
7348   2D8B FF FF FF FF 
7348   2D8F FF FF FF FF 
7348   2D93 FF FF FF FF 
7348   2D97 FF FF FF FF 
7348   2D9B FF FF FF FF 
7348   2D9F FF FF FF FF 
7348   2DA3 FF FF FF FF 
7348   2DA7 FF FF FF FF 
7348   2DAB FF FF FF FF 
7348   2DAF FF FF FF FF 
7348   2DB3 FF FF FF FF 
7348   2DB7 FF FF FF FF 
7348   2DBB FF FF FF FF 
7348   2DBF FF FF FF FF 
7348   2DC3 FF FF FF FF 
7348   2DC7 FF FF FF FF 
7348   2DCB FF FF FF FF 
7348   2DCF FF FF FF FF 
7348   2DD3 FF FF FF FF 
7348   2DD7 FF FF FF FF 
7348   2DDB FF FF FF FF 
7348   2DDF FF FF FF FF 
7348   2DE3 FF FF FF FF 
7348   2DE7 FF FF FF FF 
7348   2DEB FF FF FF FF 
7348   2DEF FF FF FF FF 
7348   2DF3 FF FF FF FF 
7348   2DF7 FF FF FF FF 
7348   2DFB FF FF FF FF 
7348   2DFF FF FF FF FF 
7348   2E03 FF FF FF FF 
7348   2E07 FF FF FF FF 
7348   2E0B FF FF FF FF 
7348   2E0F FF FF FF FF 
7348   2E13 FF FF FF FF 
7348   2E17 FF FF FF FF 
7348   2E1B FF FF FF FF 
7348   2E1F FF FF FF FF 
7348   2E23 FF FF FF FF 
7348   2E27 FF FF FF FF 
7348   2E2B FF FF FF FF 
7348   2E2F FF FF FF FF 
7348   2E33 FF FF FF FF 
7348   2E37 FF FF FF FF 
7348   2E3B FF FF FF FF 
7348   2E3F FF FF FF FF 
7348   2E43 FF FF FF FF 
7348   2E47 FF FF FF FF 
7348   2E4B FF FF FF FF 
7348   2E4F FF FF FF FF 
7348   2E53 FF FF FF FF 
7348   2E57 FF FF FF FF 
7348   2E5B FF FF FF FF 
7348   2E5F FF FF FF FF 
7348   2E63 FF FF FF FF 
7348   2E67 FF FF FF FF 
7348   2E6B FF FF FF FF 
7348   2E6F FF FF FF FF 
7348   2E73 FF FF FF FF 
7348   2E77 FF FF FF FF 
7348   2E7B FF FF FF FF 
7348   2E7F FF FF FF FF 
7348   2E83 FF FF FF FF 
7348   2E87 FF FF FF FF 
7348   2E8B FF FF FF FF 
7348   2E8F FF FF FF FF 
7348   2E93 FF FF FF FF 
7348   2E97 FF FF FF FF 
7348   2E9B FF FF FF FF 
7348   2E9F FF FF FF FF 
7348   2EA3 FF FF FF FF 
7348   2EA7 FF FF FF FF 
7348   2EAB FF FF FF FF 
7348   2EAF FF FF FF FF 
7348   2EB3 FF FF FF FF 
7348   2EB7 FF FF FF FF 
7348   2EBB FF FF FF FF 
7348   2EBF FF FF FF FF 
7348   2EC3 FF FF FF FF 
7348   2EC7 FF FF FF FF 
7348   2ECB FF FF FF FF 
7348   2ECF FF FF FF FF 
7348   2ED3 FF FF FF FF 
7348   2ED7 FF FF FF FF 
7348   2EDB FF FF FF FF 
7348   2EDF FF FF FF FF 
7348   2EE3 FF FF FF FF 
7348   2EE7 FF FF FF FF 
7348   2EEB FF FF FF FF 
7348   2EEF FF FF FF FF 
7348   2EF3 FF FF FF FF 
7348   2EF7 FF FF FF FF 
7348   2EFB FF FF FF FF 
7348   2EFF FF FF FF FF 
7348   2F03 FF FF FF FF 
7348   2F07 FF FF FF FF 
7348   2F0B FF FF FF FF 
7348   2F0F FF FF FF FF 
7348   2F13 FF FF FF FF 
7348   2F17 FF FF FF FF 
7348   2F1B FF FF FF FF 
7348   2F1F FF FF FF FF 
7348   2F23 FF FF FF FF 
7348   2F27 FF FF FF FF 
7348   2F2B FF FF FF FF 
7348   2F2F FF FF FF FF 
7348   2F33 FF FF FF FF 
7348   2F37 FF FF FF FF 
7348   2F3B FF FF FF FF 
7348   2F3F FF FF FF FF 
7348   2F43 FF FF FF FF 
7348   2F47 FF FF FF FF 
7348   2F4B FF FF FF FF 
7348   2F4F FF FF FF FF 
7348   2F53 FF FF FF FF 
7348   2F57 FF FF FF FF 
7348   2F5B FF FF FF FF 
7348   2F5F FF FF FF FF 
7348   2F63 FF FF FF FF 
7348   2F67 FF FF FF FF 
7348   2F6B FF FF FF FF 
7348   2F6F FF FF FF FF 
7348   2F73 FF FF FF FF 
7348   2F77 FF FF FF FF 
7348   2F7B FF FF FF FF 
7348   2F7F FF FF FF FF 
7348   2F83 FF FF FF FF 
7348   2F87 FF FF FF FF 
7348   2F8B FF FF FF FF 
7348   2F8F FF FF FF FF 
7348   2F93 FF FF FF FF 
7348   2F97 FF FF FF FF 
7348   2F9B FF FF FF FF 
7348   2F9F FF FF FF FF 
7348   2FA3 FF FF FF FF 
7348   2FA7 FF FF FF FF 
7348   2FAB FF FF FF FF 
7348   2FAF FF FF FF FF 
7348   2FB3 FF FF FF FF 
7348   2FB7 FF FF FF FF 
7348   2FBB FF FF FF FF 
7348   2FBF FF FF FF FF 
7348   2FC3 FF FF FF FF 
7348   2FC7 FF FF FF FF 
7348   2FCB FF FF FF FF 
7348   2FCF FF FF FF FF 
7348   2FD3 FF FF FF FF 
7348   2FD7 FF FF FF FF 
7348   2FDB FF FF FF FF 
7348   2FDF FF FF FF FF 
7348   2FE3 FF FF FF FF 
7348   2FE7 FF FF FF FF 
7348   2FEB FF FF FF FF 
7348   2FEF FF FF FF FF 
7348   2FF3 FF FF FF FF 
7348   2FF7 FF FF FF FF 
7348   2FFB FF FF FF FF 
7348   2FFF FF FF FF FF 
7348   3003 FF FF FF FF 
7348   3007 FF FF FF FF 
7348   300B FF FF FF FF 
7348   300F FF FF FF FF 
7348   3013 FF FF FF FF 
7348   3017 FF FF FF FF 
7348   301B FF FF FF FF 
7348   301F FF FF FF FF 
7348   3023 FF FF FF FF 
7348   3027 FF FF FF FF 
7348   302B FF FF FF FF 
7348   302F FF FF FF FF 
7348   3033 FF FF FF FF 
7348   3037 FF FF FF FF 
7348   303B FF FF FF FF 
7348   303F FF FF FF FF 
7348   3043 FF FF FF FF 
7348   3047 FF FF FF FF 
7348   304B FF FF FF FF 
7348   304F FF FF FF FF 
7348   3053 FF FF FF FF 
7348   3057 FF FF FF FF 
7348   305B FF FF FF FF 
7348   305F FF FF FF FF 
7348   3063 FF FF FF FF 
7348   3067 FF FF FF FF 
7348   306B FF FF FF FF 
7348   306F FF FF FF FF 
7348   3073 FF FF FF FF 
7348   3077 FF FF FF FF 
7348   307B FF FF FF FF 
7348   307F FF FF FF FF 
7348   3083 FF FF FF FF 
7348   3087 FF FF FF FF 
7348   308B FF FF FF FF 
7348   308F FF FF FF FF 
7348   3093 FF FF FF FF 
7348   3097 FF FF FF FF 
7348   309B FF FF FF FF 
7348   309F FF FF FF FF 
7348   30A3 FF FF FF FF 
7348   30A7 FF FF FF FF 
7348   30AB FF FF FF FF 
7348   30AF FF FF FF FF 
7348   30B3 FF FF FF FF 
7348   30B7 FF FF FF FF 
7348   30BB FF FF FF FF 
7348   30BF FF FF FF FF 
7348   30C3 FF FF FF FF 
7348   30C7 FF FF FF FF 
7348   30CB FF FF FF FF 
7348   30CF FF FF FF FF 
7348   30D3 FF FF FF FF 
7348   30D7 FF FF FF FF 
7348   30DB FF FF FF FF 
7348   30DF FF FF FF FF 
7348   30E3 FF FF FF FF 
7348   30E7 FF FF FF FF 
7348   30EB FF FF FF FF 
7348   30EF FF FF FF FF 
7348   30F3 FF FF FF FF 
7348   30F7 FF FF FF FF 
7348   30FB FF FF FF FF 
7348   30FF FF FF FF FF 
7348   3103 FF FF FF FF 
7348   3107 FF FF FF FF 
7348   310B FF FF FF FF 
7348   310F FF FF FF FF 
7348   3113 FF FF FF FF 
7348   3117 FF FF FF FF 
7348   311B FF FF FF FF 
7348   311F FF FF FF FF 
7348   3123 FF FF FF FF 
7348   3127 FF FF FF FF 
7348   312B FF FF FF FF 
7348   312F FF FF FF FF 
7348   3133 FF FF FF FF 
7348   3137 FF FF FF FF 
7348   313B FF FF FF FF 
7348   313F FF FF FF FF 
7348   3143 FF FF FF FF 
7348   3147 FF FF FF FF 
7348   314B FF FF FF FF 
7348   314F FF FF FF FF 
7348   3153 FF FF FF FF 
7348   3157 FF FF FF FF 
7348   315B FF FF FF FF 
7348   315F FF FF FF FF 
7348   3163 FF FF FF FF 
7348   3167 FF FF FF FF 
7348   316B FF FF FF FF 
7348   316F FF FF FF FF 
7348   3173 FF FF FF FF 
7348   3177 FF FF FF FF 
7348   317B FF FF FF FF 
7348   317F FF FF FF FF 
7348   3183 FF FF FF FF 
7348   3187 FF FF FF FF 
7348   318B FF FF FF FF 
7348   318F FF FF FF FF 
7348   3193 FF FF FF FF 
7348   3197 FF FF FF FF 
7348   319B FF FF FF FF 
7348   319F FF FF FF FF 
7348   31A3 FF FF FF FF 
7348   31A7 FF FF FF FF 
7348   31AB FF FF FF FF 
7348   31AF FF FF FF FF 
7348   31B3 FF FF FF FF 
7348   31B7 FF FF FF FF 
7348   31BB FF FF FF FF 
7348   31BF FF FF FF FF 
7348   31C3 FF FF FF FF 
7348   31C7 FF FF FF FF 
7348   31CB FF FF FF FF 
7348   31CF FF FF FF FF 
7348   31D3 FF FF FF FF 
7348   31D7 FF FF FF FF 
7348   31DB FF FF FF FF 
7348   31DF FF FF FF FF 
7348   31E3 FF FF FF FF 
7348   31E7 FF FF FF FF 
7348   31EB FF FF FF FF 
7348   31EF FF FF FF FF 
7348   31F3 FF FF FF FF 
7348   31F7 FF FF FF FF 
7348   31FB FF FF FF FF 
7348   31FF FF FF FF FF 
7348   3203 FF FF FF FF 
7348   3207 FF FF FF FF 
7348   320B FF FF FF FF 
7348   320F FF FF FF FF 
7348   3213 FF FF FF FF 
7348   3217 FF FF FF FF 
7348   321B FF FF FF FF 
7348   321F FF FF FF FF 
7348   3223 FF FF FF FF 
7348   3227 FF FF FF FF 
7348   322B FF FF FF FF 
7348   322F FF FF FF FF 
7348   3233 FF FF FF FF 
7348   3237 FF FF FF FF 
7348   323B FF FF FF FF 
7348   323F FF FF FF FF 
7348   3243 FF FF FF FF 
7348   3247 FF FF FF FF 
7348   324B FF FF FF FF 
7348   324F FF FF FF FF 
7348   3253 FF FF FF FF 
7348   3257 FF FF FF FF 
7348   325B FF FF FF FF 
7348   325F FF FF FF FF 
7348   3263 FF FF FF FF 
7348   3267 FF FF FF FF 
7348   326B FF FF FF FF 
7348   326F FF FF FF FF 
7348   3273 FF FF FF FF 
7348   3277 FF FF FF FF 
7348   327B FF FF FF FF 
7348   327F FF FF FF FF 
7348   3283 FF FF FF FF 
7348   3287 FF FF FF FF 
7348   328B FF FF FF FF 
7348   328F FF FF FF FF 
7348   3293 FF FF FF FF 
7348   3297 FF FF FF FF 
7348   329B FF FF FF FF 
7348   329F FF FF FF FF 
7348   32A3 FF FF FF FF 
7348   32A7 FF FF FF FF 
7348   32AB FF FF FF FF 
7348   32AF FF FF FF FF 
7348   32B3 FF FF FF FF 
7348   32B7 FF FF FF FF 
7348   32BB FF FF FF FF 
7348   32BF FF FF FF FF 
7348   32C3 FF FF FF FF 
7348   32C7 FF FF FF FF 
7348   32CB FF FF FF FF 
7348   32CF FF FF FF FF 
7348   32D3 FF FF FF FF 
7348   32D7 FF FF FF FF 
7348   32DB FF FF FF FF 
7348   32DF FF FF FF FF 
7348   32E3 FF FF FF FF 
7348   32E7 FF FF FF FF 
7348   32EB FF FF FF FF 
7348   32EF FF FF FF FF 
7348   32F3 FF FF FF FF 
7348   32F7 FF FF FF FF 
7348   32FB FF FF FF FF 
7348   32FF FF FF FF FF 
7348   3303 FF FF FF FF 
7348   3307 FF FF FF FF 
7348   330B FF FF FF FF 
7348   330F FF FF FF FF 
7348   3313 FF FF FF FF 
7348   3317 FF FF FF FF 
7348   331B FF FF FF FF 
7348   331F FF FF FF FF 
7348   3323 FF FF FF FF 
7348   3327 FF FF FF FF 
7348   332B FF FF FF FF 
7348   332F FF FF FF FF 
7348   3333 FF FF FF FF 
7348   3337 FF FF FF FF 
7348   333B FF FF FF FF 
7348   333F FF FF FF FF 
7348   3343 FF FF FF FF 
7348   3347 FF FF FF FF 
7348   334B FF FF FF FF 
7348   334F FF FF FF FF 
7348   3353 FF FF FF FF 
7348   3357 FF FF FF FF 
7348   335B FF FF FF FF 
7348   335F FF FF FF FF 
7348   3363 FF FF FF FF 
7348   3367 FF FF FF FF 
7348   336B FF FF FF FF 
7348   336F FF FF FF FF 
7348   3373 FF FF FF FF 
7348   3377 FF FF FF FF 
7348   337B FF FF FF FF 
7348   337F FF FF FF FF 
7348   3383 FF FF FF FF 
7348   3387 FF FF FF FF 
7348   338B FF FF FF FF 
7348   338F FF FF FF FF 
7348   3393 FF FF FF FF 
7348   3397 FF FF FF FF 
7348   339B FF FF FF FF 
7348   339F FF FF FF FF 
7348   33A3 FF FF FF FF 
7348   33A7 FF FF FF FF 
7348   33AB FF FF FF FF 
7348   33AF FF FF FF FF 
7348   33B3 FF FF FF FF 
7348   33B7 FF FF FF FF 
7348   33BB FF FF FF FF 
7348   33BF FF FF FF FF 
7348   33C3 FF FF FF FF 
7348   33C7 FF FF FF FF 
7348   33CB FF FF FF FF 
7348   33CF FF FF FF FF 
7348   33D3 FF FF FF FF 
7348   33D7 FF FF FF FF 
7348   33DB FF FF FF FF 
7348   33DF FF FF FF FF 
7348   33E3 FF FF FF FF 
7348   33E7 FF FF FF FF 
7348   33EB FF FF FF FF 
7348   33EF FF FF FF FF 
7348   33F3 FF FF FF FF 
7348   33F7 FF FF FF FF 
7348   33FB FF FF FF FF 
7348   33FF FF FF FF FF 
7348   3403 FF FF FF FF 
7348   3407 FF FF FF FF 
7348   340B FF FF FF FF 
7348   340F FF FF FF FF 
7348   3413 FF FF FF FF 
7348   3417 FF FF FF FF 
7348   341B FF FF FF FF 
7348   341F FF FF FF FF 
7348   3423 FF FF FF FF 
7348   3427 FF FF FF FF 
7348   342B FF FF FF FF 
7348   342F FF FF FF FF 
7348   3433 FF FF FF FF 
7348   3437 FF FF FF FF 
7348   343B FF FF FF FF 
7348   343F FF FF FF FF 
7348   3443 FF FF FF FF 
7348   3447 FF FF FF FF 
7348   344B FF FF FF FF 
7348   344F FF FF FF FF 
7348   3453 FF FF FF FF 
7348   3457 FF FF FF FF 
7348   345B FF FF FF FF 
7348   345F FF FF FF FF 
7348   3463 FF FF FF FF 
7348   3467 FF FF FF FF 
7348   346B FF FF FF FF 
7348   346F FF FF FF FF 
7348   3473 FF FF FF FF 
7348   3477 FF FF FF FF 
7348   347B FF FF FF FF 
7348   347F FF FF FF FF 
7348   3483 FF FF FF FF 
7348   3487 FF FF FF FF 
7348   348B FF FF FF FF 
7348   348F FF FF FF FF 
7348   3493 FF FF FF FF 
7348   3497 FF FF FF FF 
7348   349B FF FF FF FF 
7348   349F FF FF FF FF 
7348   34A3 FF FF FF FF 
7348   34A7 FF FF FF FF 
7348   34AB FF FF FF FF 
7348   34AF FF FF FF FF 
7348   34B3 FF FF FF FF 
7348   34B7 FF FF FF FF 
7348   34BB FF FF FF FF 
7348   34BF FF FF FF FF 
7348   34C3 FF FF FF FF 
7348   34C7 FF FF FF FF 
7348   34CB FF FF FF FF 
7348   34CF FF FF FF FF 
7348   34D3 FF FF FF FF 
7348   34D7 FF FF FF FF 
7348   34DB FF FF FF FF 
7348   34DF FF FF FF FF 
7348   34E3 FF FF FF FF 
7348   34E7 FF FF FF FF 
7348   34EB FF FF FF FF 
7348   34EF FF FF FF FF 
7348   34F3 FF FF FF FF 
7348   34F7 FF FF FF FF 
7348   34FB FF FF FF FF 
7348   34FF FF FF FF FF 
7348   3503 FF FF FF FF 
7348   3507 FF FF FF FF 
7348   350B FF FF FF FF 
7348   350F FF FF FF FF 
7348   3513 FF FF FF FF 
7348   3517 FF FF FF FF 
7348   351B FF FF FF FF 
7348   351F FF FF FF FF 
7348   3523 FF FF FF FF 
7348   3527 FF FF FF FF 
7348   352B FF FF FF FF 
7348   352F FF FF FF FF 
7348   3533 FF FF FF FF 
7348   3537 FF FF FF FF 
7348   353B FF FF FF FF 
7348   353F FF FF FF FF 
7348   3543 FF FF FF FF 
7348   3547 FF FF FF FF 
7348   354B FF FF FF FF 
7348   354F FF FF FF FF 
7348   3553 FF FF FF FF 
7348   3557 FF FF FF FF 
7348   355B FF FF FF FF 
7348   355F FF FF FF FF 
7348   3563 FF FF FF FF 
7348   3567 FF FF FF FF 
7348   356B FF FF FF FF 
7348   356F FF FF FF FF 
7348   3573 FF FF FF FF 
7348   3577 FF FF FF FF 
7348   357B FF FF FF FF 
7348   357F FF FF FF FF 
7348   3583 FF FF FF FF 
7348   3587 FF FF FF FF 
7348   358B FF FF FF FF 
7348   358F FF FF FF FF 
7348   3593 FF FF FF FF 
7348   3597 FF FF FF FF 
7348   359B FF FF FF FF 
7348   359F FF FF FF FF 
7348   35A3 FF FF FF FF 
7348   35A7 FF FF FF FF 
7348   35AB FF FF FF FF 
7348   35AF FF FF FF FF 
7348   35B3 FF FF FF FF 
7348   35B7 FF FF FF FF 
7348   35BB FF FF FF FF 
7348   35BF FF FF FF FF 
7348   35C3 FF FF FF FF 
7348   35C7 FF FF FF FF 
7348   35CB FF FF FF FF 
7348   35CF FF FF FF FF 
7348   35D3 FF FF FF FF 
7348   35D7 FF FF FF FF 
7348   35DB FF FF FF FF 
7348   35DF FF FF FF FF 
7348   35E3 FF FF FF FF 
7348   35E7 FF FF FF FF 
7348   35EB FF FF FF FF 
7348   35EF FF FF FF FF 
7348   35F3 FF FF FF FF 
7348   35F7 FF FF FF FF 
7348   35FB FF FF FF FF 
7348   35FF FF FF FF FF 
7348   3603 FF FF FF FF 
7348   3607 FF FF FF FF 
7348   360B FF FF FF FF 
7348   360F FF FF FF FF 
7348   3613 FF FF FF FF 
7348   3617 FF FF FF FF 
7348   361B FF FF FF FF 
7348   361F FF FF FF FF 
7348   3623 FF FF FF FF 
7348   3627 FF FF FF FF 
7348   362B FF FF FF FF 
7348   362F FF FF FF FF 
7348   3633 FF FF FF FF 
7348   3637 FF FF FF FF 
7348   363B FF FF FF FF 
7348   363F FF FF FF FF 
7348   3643 FF FF FF FF 
7348   3647 FF FF FF FF 
7348   364B FF FF FF FF 
7348   364F FF FF FF FF 
7348   3653 FF FF FF FF 
7348   3657 FF FF FF FF 
7348   365B FF FF FF FF 
7348   365F FF FF FF FF 
7348   3663 FF FF FF FF 
7348   3667 FF FF FF FF 
7348   366B FF FF FF FF 
7348   366F FF FF FF FF 
7348   3673 FF FF FF FF 
7348   3677 FF FF FF FF 
7348   367B FF FF FF FF 
7348   367F FF FF FF FF 
7348   3683 FF FF FF FF 
7348   3687 FF FF FF FF 
7348   368B FF FF FF FF 
7348   368F FF FF FF FF 
7348   3693 FF FF FF FF 
7348   3697 FF FF FF FF 
7348   369B FF FF FF FF 
7348   369F FF FF FF FF 
7348   36A3 FF FF FF FF 
7348   36A7 FF FF FF FF 
7348   36AB FF FF FF FF 
7348   36AF FF FF FF FF 
7348   36B3 FF FF FF FF 
7348   36B7 FF FF FF FF 
7348   36BB FF FF FF FF 
7348   36BF FF FF FF FF 
7348   36C3 FF FF FF FF 
7348   36C7 FF FF FF FF 
7348   36CB FF FF FF FF 
7348   36CF FF FF FF FF 
7348   36D3 FF FF FF FF 
7348   36D7 FF FF FF FF 
7348   36DB FF FF FF FF 
7348   36DF FF FF FF FF 
7348   36E3 FF FF FF FF 
7348   36E7 FF FF FF FF 
7348   36EB FF FF FF FF 
7348   36EF FF FF FF FF 
7348   36F3 FF FF FF FF 
7348   36F7 FF FF FF FF 
7348   36FB FF FF FF FF 
7348   36FF FF FF FF FF 
7348   3703 FF FF FF FF 
7348   3707 FF FF FF FF 
7348   370B FF FF FF FF 
7348   370F FF FF FF FF 
7348   3713 FF FF FF FF 
7348   3717 FF FF FF FF 
7348   371B FF FF FF FF 
7348   371F FF FF FF FF 
7348   3723 FF FF FF FF 
7348   3727 FF FF FF FF 
7348   372B FF FF FF FF 
7348   372F FF FF FF FF 
7348   3733 FF FF FF FF 
7348   3737 FF FF FF FF 
7348   373B FF FF FF FF 
7348   373F FF FF FF FF 
7348   3743 FF FF FF FF 
7348   3747 FF FF FF FF 
7348   374B FF FF FF FF 
7348   374F FF FF FF FF 
7348   3753 FF FF FF FF 
7348   3757 FF FF FF FF 
7348   375B FF FF FF FF 
7348   375F FF FF FF FF 
7348   3763 FF FF FF FF 
7348   3767 FF FF FF FF 
7348   376B FF FF FF FF 
7348   376F FF FF FF FF 
7348   3773 FF FF FF FF 
7348   3777 FF FF FF FF 
7348   377B FF FF FF FF 
7348   377F FF FF FF FF 
7348   3783 FF FF FF FF 
7348   3787 FF FF FF FF 
7348   378B FF FF FF FF 
7348   378F FF FF FF FF 
7348   3793 FF FF FF FF 
7348   3797 FF FF FF FF 
7348   379B FF FF FF FF 
7348   379F FF FF FF FF 
7348   37A3 FF FF FF FF 
7348   37A7 FF FF FF FF 
7348   37AB FF FF FF FF 
7348   37AF FF FF FF FF 
7348   37B3 FF FF FF FF 
7348   37B7 FF FF FF FF 
7348   37BB FF FF FF FF 
7348   37BF FF FF FF FF 
7348   37C3 FF FF FF FF 
7348   37C7 FF FF FF FF 
7348   37CB FF FF FF FF 
7348   37CF FF FF FF FF 
7348   37D3 FF FF FF FF 
7348   37D7 FF FF FF FF 
7348   37DB FF FF FF FF 
7348   37DF FF FF FF FF 
7348   37E3 FF FF FF FF 
7348   37E7 FF FF FF FF 
7348   37EB FF FF FF FF 
7348   37EF FF FF FF FF 
7348   37F3 FF FF FF FF 
7348   37F7 FF FF FF FF 
7348   37FB FF FF FF FF 
7348   37FF FF FF FF FF 
7348   3803 FF FF FF FF 
7348   3807 FF FF FF FF 
7348   380B FF FF FF FF 
7348   380F FF FF FF FF 
7348   3813 FF FF FF FF 
7348   3817 FF FF FF FF 
7348   381B FF FF FF FF 
7348   381F FF FF FF FF 
7348   3823 FF FF FF FF 
7348   3827 FF FF FF FF 
7348   382B FF FF FF FF 
7348   382F FF FF FF FF 
7348   3833 FF FF FF FF 
7348   3837 FF FF FF FF 
7348   383B FF FF FF FF 
7348   383F FF FF FF FF 
7348   3843 FF FF FF FF 
7348   3847 FF FF FF FF 
7348   384B FF FF FF FF 
7348   384F FF FF FF FF 
7348   3853 FF FF FF FF 
7348   3857 FF FF FF FF 
7348   385B FF FF FF FF 
7348   385F FF FF FF FF 
7348   3863 FF FF FF FF 
7348   3867 FF FF FF FF 
7348   386B FF FF FF FF 
7348   386F FF FF FF FF 
7348   3873 FF FF FF FF 
7348   3877 FF FF FF FF 
7348   387B FF FF FF FF 
7348   387F FF FF FF FF 
7348   3883 FF FF FF FF 
7348   3887 FF FF FF FF 
7348   388B FF FF FF FF 
7348   388F FF FF FF FF 
7348   3893 FF FF FF FF 
7348   3897 FF FF FF FF 
7348   389B FF FF FF FF 
7348   389F FF FF FF FF 
7348   38A3 FF FF FF FF 
7348   38A7 FF FF FF FF 
7348   38AB FF FF FF FF 
7348   38AF FF FF FF FF 
7348   38B3 FF FF FF FF 
7348   38B7 FF FF FF FF 
7348   38BB FF FF FF FF 
7348   38BF FF FF FF FF 
7348   38C3 FF FF FF FF 
7348   38C7 FF FF FF FF 
7348   38CB FF FF FF FF 
7348   38CF FF FF FF FF 
7348   38D3 FF FF FF FF 
7348   38D7 FF FF FF FF 
7348   38DB FF FF FF FF 
7348   38DF FF FF FF FF 
7348   38E3 FF FF FF FF 
7348   38E7 FF FF FF FF 
7348   38EB FF FF FF FF 
7348   38EF FF FF FF FF 
7348   38F3 FF FF FF FF 
7348   38F7 FF FF FF FF 
7348   38FB FF FF FF FF 
7348   38FF FF FF FF FF 
7348   3903 FF FF FF FF 
7348   3907 FF FF FF FF 
7348   390B FF FF FF FF 
7348   390F FF FF FF FF 
7348   3913 FF FF FF FF 
7348   3917 FF FF FF FF 
7348   391B FF FF FF FF 
7348   391F FF FF FF FF 
7348   3923 FF FF FF FF 
7348   3927 FF FF FF FF 
7348   392B FF FF FF FF 
7348   392F FF FF FF FF 
7348   3933 FF FF FF FF 
7348   3937 FF FF FF FF 
7348   393B FF FF FF FF 
7348   393F FF FF FF FF 
7348   3943 FF FF FF FF 
7348   3947 FF FF FF FF 
7348   394B FF FF FF FF 
7348   394F FF FF FF FF 
7348   3953 FF FF FF FF 
7348   3957 FF FF FF FF 
7348   395B FF FF FF FF 
7348   395F FF FF FF FF 
7348   3963 FF FF FF FF 
7348   3967 FF FF FF FF 
7348   396B FF FF FF FF 
7348   396F FF FF FF FF 
7348   3973 FF FF FF FF 
7348   3977 FF FF FF FF 
7348   397B FF FF FF FF 
7348   397F FF FF FF FF 
7348   3983 FF FF FF FF 
7348   3987 FF FF FF FF 
7348   398B FF FF FF FF 
7348   398F FF FF FF FF 
7348   3993 FF FF FF FF 
7348   3997 FF FF FF FF 
7348   399B FF FF FF FF 
7348   399F FF FF FF FF 
7348   39A3 FF FF FF FF 
7348   39A7 FF FF FF FF 
7348   39AB FF FF FF FF 
7348   39AF FF FF FF FF 
7348   39B3 FF FF FF FF 
7348   39B7 FF FF FF FF 
7348   39BB FF FF FF FF 
7348   39BF FF FF FF FF 
7348   39C3 FF FF FF FF 
7348   39C7 FF FF FF FF 
7348   39CB FF FF FF FF 
7348   39CF FF FF FF FF 
7348   39D3 FF FF FF FF 
7348   39D7 FF FF FF FF 
7348   39DB FF FF FF FF 
7348   39DF FF FF FF FF 
7348   39E3 FF FF FF FF 
7348   39E7 FF FF FF FF 
7348   39EB FF FF FF FF 
7348   39EF FF FF FF FF 
7348   39F3 FF FF FF FF 
7348   39F7 FF FF FF FF 
7348   39FB FF FF FF FF 
7348   39FF FF FF FF FF 
7348   3A03 FF FF FF FF 
7348   3A07 FF FF FF FF 
7348   3A0B FF FF FF FF 
7348   3A0F FF FF FF FF 
7348   3A13 FF FF FF FF 
7348   3A17 FF FF FF FF 
7348   3A1B FF FF FF FF 
7348   3A1F FF FF FF FF 
7348   3A23 FF FF FF FF 
7348   3A27 FF FF FF FF 
7348   3A2B FF FF FF FF 
7348   3A2F FF FF FF FF 
7348   3A33 FF FF FF FF 
7348   3A37 FF FF FF FF 
7348   3A3B FF FF FF FF 
7348   3A3F FF FF FF FF 
7348   3A43 FF FF FF FF 
7348   3A47 FF FF FF FF 
7348   3A4B FF FF FF FF 
7348   3A4F FF FF FF FF 
7348   3A53 FF FF FF FF 
7348   3A57 FF FF FF FF 
7348   3A5B FF FF FF FF 
7348   3A5F FF FF FF FF 
7348   3A63 FF FF FF FF 
7348   3A67 FF FF FF FF 
7348   3A6B FF FF FF FF 
7348   3A6F FF FF FF FF 
7348   3A73 FF FF FF FF 
7348   3A77 FF FF FF FF 
7348   3A7B FF FF FF FF 
7348   3A7F FF FF FF FF 
7348   3A83 FF FF FF FF 
7348   3A87 FF FF FF FF 
7348   3A8B FF FF FF FF 
7348   3A8F FF FF FF FF 
7348   3A93 FF FF FF FF 
7348   3A97 FF FF FF FF 
7348   3A9B FF FF FF FF 
7348   3A9F FF FF FF FF 
7348   3AA3 FF FF FF FF 
7348   3AA7 FF FF FF FF 
7348   3AAB FF FF FF FF 
7348   3AAF FF FF FF FF 
7348   3AB3 FF FF FF FF 
7348   3AB7 FF FF FF FF 
7348   3ABB FF FF FF FF 
7348   3ABF FF FF FF FF 
7348   3AC3 FF FF FF FF 
7348   3AC7 FF FF FF FF 
7348   3ACB FF FF FF FF 
7348   3ACF FF FF FF FF 
7348   3AD3 FF FF FF FF 
7348   3AD7 FF FF FF FF 
7348   3ADB FF FF FF FF 
7348   3ADF FF FF FF FF 
7348   3AE3 FF FF FF FF 
7348   3AE7 FF FF FF FF 
7348   3AEB FF FF FF FF 
7348   3AEF FF FF FF FF 
7348   3AF3 FF FF FF FF 
7348   3AF7 FF FF FF FF 
7348   3AFB FF FF FF FF 
7348   3AFF FF FF FF FF 
7348   3B03 FF FF FF FF 
7348   3B07 FF FF FF FF 
7348   3B0B FF FF FF FF 
7348   3B0F FF FF FF FF 
7348   3B13 FF FF FF FF 
7348   3B17 FF FF FF FF 
7348   3B1B FF FF FF FF 
7348   3B1F FF FF FF FF 
7348   3B23 FF FF FF FF 
7348   3B27 FF FF FF FF 
7348   3B2B FF FF FF FF 
7348   3B2F FF FF FF FF 
7348   3B33 FF FF FF FF 
7348   3B37 FF FF FF FF 
7348   3B3B FF FF FF FF 
7348   3B3F FF FF FF FF 
7348   3B43 FF FF FF FF 
7348   3B47 FF FF FF FF 
7348   3B4B FF FF FF FF 
7348   3B4F FF FF FF FF 
7348   3B53 FF FF FF FF 
7348   3B57 FF FF FF FF 
7348   3B5B FF FF FF FF 
7348   3B5F FF FF FF FF 
7348   3B63 FF FF FF FF 
7348   3B67 FF FF FF FF 
7348   3B6B FF FF FF FF 
7348   3B6F FF FF FF FF 
7348   3B73 FF FF FF FF 
7348   3B77 FF FF FF FF 
7348   3B7B FF FF FF FF 
7348   3B7F FF FF FF FF 
7348   3B83 FF FF FF FF 
7348   3B87 FF FF FF FF 
7348   3B8B FF FF FF FF 
7348   3B8F FF FF FF FF 
7348   3B93 FF FF FF FF 
7348   3B97 FF FF FF FF 
7348   3B9B FF FF FF FF 
7348   3B9F FF FF FF FF 
7348   3BA3 FF FF FF FF 
7348   3BA7 FF FF FF FF 
7348   3BAB FF FF FF FF 
7348   3BAF FF FF FF FF 
7348   3BB3 FF FF FF FF 
7348   3BB7 FF FF FF FF 
7348   3BBB FF FF FF FF 
7348   3BBF FF FF FF FF 
7348   3BC3 FF FF FF FF 
7348   3BC7 FF FF FF FF 
7348   3BCB FF FF FF FF 
7348   3BCF FF FF FF FF 
7348   3BD3 FF FF FF FF 
7348   3BD7 FF FF FF FF 
7348   3BDB FF FF FF FF 
7348   3BDF FF FF FF FF 
7348   3BE3 FF FF FF FF 
7348   3BE7 FF FF FF FF 
7348   3BEB FF FF FF FF 
7348   3BEF FF FF FF FF 
7348   3BF3 FF FF FF FF 
7348   3BF7 FF FF FF FF 
7348   3BFB FF FF FF FF 
7348   3BFF FF FF FF FF 
7348   3C03 FF FF FF FF 
7348   3C07 FF FF FF FF 
7348   3C0B FF FF FF FF 
7348   3C0F FF FF FF FF 
7348   3C13 FF FF FF FF 
7348   3C17 FF FF FF FF 
7348   3C1B FF FF FF FF 
7348   3C1F FF FF FF FF 
7348   3C23 FF FF FF FF 
7348   3C27 FF FF FF FF 
7348   3C2B FF FF FF FF 
7348   3C2F FF FF FF FF 
7348   3C33 FF FF FF FF 
7348   3C37 FF FF FF FF 
7348   3C3B FF FF FF FF 
7348   3C3F FF FF FF FF 
7348   3C43 FF FF FF FF 
7348   3C47 FF FF FF FF 
7348   3C4B FF FF FF FF 
7348   3C4F FF FF FF FF 
7348   3C53 FF FF FF FF 
7348   3C57 FF FF FF FF 
7348   3C5B FF FF FF FF 
7348   3C5F FF FF FF FF 
7348   3C63 FF FF FF FF 
7348   3C67 FF FF FF FF 
7348   3C6B FF FF FF FF 
7348   3C6F FF FF FF FF 
7348   3C73 FF FF FF FF 
7348   3C77 FF FF FF FF 
7348   3C7B FF FF FF FF 
7348   3C7F FF FF FF FF 
7348   3C83 FF FF FF FF 
7348   3C87 FF FF FF FF 
7348   3C8B FF FF FF FF 
7348   3C8F FF FF FF FF 
7348   3C93 FF FF FF FF 
7348   3C97 FF FF FF FF 
7348   3C9B FF FF FF FF 
7348   3C9F FF FF FF FF 
7348   3CA3 FF FF FF FF 
7348   3CA7 FF FF FF FF 
7348   3CAB FF FF FF FF 
7348   3CAF FF FF FF FF 
7348   3CB3 FF FF FF FF 
7348   3CB7 FF FF FF FF 
7348   3CBB FF FF FF FF 
7348   3CBF FF FF FF FF 
7348   3CC3 FF FF FF FF 
7348   3CC7 FF FF FF FF 
7348   3CCB FF FF FF FF 
7348   3CCF FF FF FF FF 
7348   3CD3 FF FF FF FF 
7348   3CD7 FF FF FF FF 
7348   3CDB FF FF FF FF 
7348   3CDF FF FF FF FF 
7348   3CE3 FF FF FF FF 
7348   3CE7 FF FF FF FF 
7348   3CEB FF FF FF FF 
7348   3CEF FF FF FF FF 
7348   3CF3 FF FF FF FF 
7348   3CF7 FF FF FF FF 
7348   3CFB FF FF FF FF 
7348   3CFF FF FF FF FF 
7348   3D03 FF FF FF FF 
7348   3D07 FF FF FF FF 
7348   3D0B FF FF FF FF 
7348   3D0F FF FF FF FF 
7348   3D13 FF FF FF FF 
7348   3D17 FF FF FF FF 
7348   3D1B FF FF FF FF 
7348   3D1F FF FF FF FF 
7348   3D23 FF FF FF FF 
7348   3D27 FF FF FF FF 
7348   3D2B FF FF FF FF 
7348   3D2F FF FF FF FF 
7348   3D33 FF FF FF FF 
7348   3D37 FF FF FF FF 
7348   3D3B FF FF FF FF 
7348   3D3F FF FF FF FF 
7348   3D43 FF FF FF FF 
7348   3D47 FF FF FF FF 
7348   3D4B FF FF FF FF 
7348   3D4F FF FF FF FF 
7348   3D53 FF FF FF FF 
7348   3D57 FF FF FF FF 
7348   3D5B FF FF FF FF 
7348   3D5F FF FF FF FF 
7348   3D63 FF FF FF FF 
7348   3D67 FF FF FF FF 
7348   3D6B FF FF FF FF 
7348   3D6F FF FF FF FF 
7348   3D73 FF FF FF FF 
7348   3D77 FF FF FF FF 
7348   3D7B FF FF FF FF 
7348   3D7F FF FF FF FF 
7348   3D83 FF FF FF FF 
7348   3D87 FF FF FF FF 
7348   3D8B FF FF FF FF 
7348   3D8F FF FF FF FF 
7348   3D93 FF FF FF FF 
7348   3D97 FF FF FF FF 
7348   3D9B FF FF FF FF 
7348   3D9F FF FF FF FF 
7348   3DA3 FF FF FF FF 
7348   3DA7 FF FF FF FF 
7348   3DAB FF FF FF FF 
7348   3DAF FF FF FF FF 
7348   3DB3 FF FF FF FF 
7348   3DB7 FF FF FF FF 
7348   3DBB FF FF FF FF 
7348   3DBF FF FF FF FF 
7348   3DC3 FF FF FF FF 
7348   3DC7 FF FF FF FF 
7348   3DCB FF FF FF FF 
7348   3DCF FF FF FF FF 
7348   3DD3 FF FF FF FF 
7348   3DD7 FF FF FF FF 
7348   3DDB FF FF FF FF 
7348   3DDF FF FF FF FF 
7348   3DE3 FF FF FF FF 
7348   3DE7 FF FF FF FF 
7348   3DEB FF FF FF FF 
7348   3DEF FF FF FF FF 
7348   3DF3 FF FF FF FF 
7348   3DF7 FF FF FF FF 
7348   3DFB FF FF FF FF 
7348   3DFF FF FF FF FF 
7348   3E03 FF FF FF FF 
7348   3E07 FF FF FF FF 
7348   3E0B FF FF FF FF 
7348   3E0F FF FF FF FF 
7348   3E13 FF FF FF FF 
7348   3E17 FF FF FF FF 
7348   3E1B FF FF FF FF 
7348   3E1F FF FF FF FF 
7348   3E23 FF FF FF FF 
7348   3E27 FF FF FF FF 
7348   3E2B FF FF FF FF 
7348   3E2F FF FF FF FF 
7348   3E33 FF FF FF FF 
7348   3E37 FF FF FF FF 
7348   3E3B FF FF FF FF 
7348   3E3F FF FF FF FF 
7348   3E43 FF FF FF FF 
7348   3E47 FF FF FF FF 
7348   3E4B FF FF FF FF 
7348   3E4F FF FF FF FF 
7348   3E53 FF FF FF FF 
7348   3E57 FF FF FF FF 
7348   3E5B FF FF FF FF 
7348   3E5F FF FF FF FF 
7348   3E63 FF FF FF FF 
7348   3E67 FF FF FF FF 
7348   3E6B FF FF FF FF 
7348   3E6F FF FF FF FF 
7348   3E73 FF FF FF FF 
7348   3E77 FF FF FF FF 
7348   3E7B FF FF FF FF 
7348   3E7F FF FF FF FF 
7348   3E83 FF FF FF FF 
7348   3E87 FF FF FF FF 
7348   3E8B FF FF FF FF 
7348   3E8F FF FF FF FF 
7348   3E93 FF FF FF FF 
7348   3E97 FF FF FF FF 
7348   3E9B FF FF FF FF 
7348   3E9F FF FF FF FF 
7348   3EA3 FF FF FF FF 
7348   3EA7 FF FF FF FF 
7348   3EAB FF FF FF FF 
7348   3EAF FF FF FF FF 
7348   3EB3 FF FF FF FF 
7348   3EB7 FF FF FF FF 
7348   3EBB FF FF FF FF 
7348   3EBF FF FF FF FF 
7348   3EC3 FF FF FF FF 
7348   3EC7 FF FF FF FF 
7348   3ECB FF FF FF FF 
7348   3ECF FF FF FF FF 
7348   3ED3 FF FF FF FF 
7348   3ED7 FF FF FF FF 
7348   3EDB FF FF FF FF 
7348   3EDF FF FF FF FF 
7348   3EE3 FF FF FF FF 
7348   3EE7 FF FF FF FF 
7348   3EEB FF FF FF FF 
7348   3EEF FF FF FF FF 
7348   3EF3 FF FF FF FF 
7348   3EF7 FF FF FF FF 
7348   3EFB FF FF FF FF 
7348   3EFF FF FF FF FF 
7348   3F03 FF FF FF FF 
7348   3F07 FF FF FF FF 
7348   3F0B FF FF FF FF 
7348   3F0F FF FF FF FF 
7348   3F13 FF FF FF FF 
7348   3F17 FF FF FF FF 
7348   3F1B FF FF FF FF 
7348   3F1F FF FF FF FF 
7348   3F23 FF FF FF FF 
7348   3F27 FF FF FF FF 
7348   3F2B FF FF FF FF 
7348   3F2F FF FF FF FF 
7348   3F33 FF FF FF FF 
7348   3F37 FF FF FF FF 
7348   3F3B FF FF FF FF 
7348   3F3F FF FF FF FF 
7348   3F43 FF FF FF FF 
7348   3F47 FF FF FF FF 
7348   3F4B FF FF FF FF 
7348   3F4F FF FF FF FF 
7348   3F53 FF FF FF FF 
7348   3F57 FF FF FF FF 
7348   3F5B FF FF FF FF 
7348   3F5F FF FF FF FF 
7348   3F63 FF FF FF FF 
7348   3F67 FF FF FF FF 
7348   3F6B FF FF FF FF 
7348   3F6F FF FF FF FF 
7348   3F73 FF FF FF FF 
7348   3F77 FF FF FF FF 
7348   3F7B FF FF FF FF 
7348   3F7F FF FF FF FF 
7348   3F83 FF FF FF FF 
7348   3F87 FF FF FF FF 
7348   3F8B FF FF FF FF 
7348   3F8F FF FF FF FF 
7348   3F93 FF FF FF FF 
7348   3F97 FF FF FF FF 
7348   3F9B FF FF FF FF 
7348   3F9F FF FF FF FF 
7348   3FA3 FF FF FF FF 
7348   3FA7 FF FF FF FF 
7348   3FAB FF FF FF FF 
7348   3FAF FF FF FF FF 
7348   3FB3 FF FF FF FF 
7348   3FB7 FF FF FF FF 
7348   3FBB FF FF FF FF 
7348   3FBF FF FF FF FF 
7348   3FC3 FF FF FF FF 
7348   3FC7 FF FF FF FF 
7348   3FCB FF FF FF FF 
7348   3FCF FF FF FF FF 
7348   3FD3 FF FF FF FF 
7348   3FD7 FF FF FF FF 
7348   3FDB FF FF FF FF 
7348   3FDF FF FF FF FF 
7348   3FE3 FF FF FF FF 
7348   3FE7 FF FF FF FF 
7348   3FEB FF FF FF FF 
7348   3FEF FF FF FF FF 
7348   3FF3 FF FF FF FF 
7348   3FF7 FF FF FF FF 
7348   3FFB FF FF FF FF 
7348   3FFF FF FF FF FF 
7348   4003 FF FF FF FF 
7348   4007 FF FF FF FF 
7348   400B FF FF FF FF 
7348   400F FF FF FF FF 
7348   4013 FF FF FF FF 
7348   4017 FF FF FF FF 
7348   401B FF FF FF FF 
7348   401F FF FF FF FF 
7348   4023 FF FF FF FF 
7348   4027 FF FF FF FF 
7348   402B FF FF FF FF 
7348   402F FF FF FF FF 
7348   4033 FF FF FF FF 
7348   4037 FF FF FF FF 
7348   403B FF FF FF FF 
7348   403F FF FF FF FF 
7348   4043 FF FF FF FF 
7348   4047 FF FF FF FF 
7348   404B FF FF FF FF 
7348   404F FF FF FF FF 
7348   4053 FF FF FF FF 
7348   4057 FF FF FF FF 
7348   405B FF FF FF FF 
7348   405F FF FF FF FF 
7348   4063 FF FF FF FF 
7348   4067 FF FF FF FF 
7348   406B FF FF FF FF 
7348   406F FF FF FF FF 
7348   4073 FF FF FF FF 
7348   4077 FF FF FF FF 
7348   407B FF FF FF FF 
7348   407F FF FF FF FF 
7348   4083 FF FF FF FF 
7348   4087 FF FF FF FF 
7348   408B FF FF FF FF 
7348   408F FF FF FF FF 
7348   4093 FF FF FF FF 
7348   4097 FF FF FF FF 
7348   409B FF FF FF FF 
7348   409F FF FF FF FF 
7348   40A3 FF FF FF FF 
7348   40A7 FF FF FF FF 
7348   40AB FF FF FF FF 
7348   40AF FF FF FF FF 
7348   40B3 FF FF FF FF 
7348   40B7 FF FF FF FF 
7348   40BB FF FF FF FF 
7348   40BF FF FF FF FF 
7348   40C3 FF FF FF FF 
7348   40C7 FF FF FF FF 
7348   40CB FF FF FF FF 
7348   40CF FF FF FF FF 
7348   40D3 FF FF FF FF 
7348   40D7 FF FF FF FF 
7348   40DB FF FF FF FF 
7348   40DF FF FF FF FF 
7348   40E3 FF FF FF FF 
7348   40E7 FF FF FF FF 
7348   40EB FF FF FF FF 
7348   40EF FF FF FF FF 
7348   40F3 FF FF FF FF 
7348   40F7 FF FF FF FF 
7348   40FB FF FF FF FF 
7348   40FF FF FF FF FF 
7348   4103 FF FF FF FF 
7348   4107 FF FF FF FF 
7348   410B FF FF FF FF 
7348   410F FF FF FF FF 
7348   4113 FF FF FF FF 
7348   4117 FF FF FF FF 
7348   411B FF FF FF FF 
7348   411F FF FF FF FF 
7348   4123 FF FF FF FF 
7348   4127 FF FF FF FF 
7348   412B FF FF FF FF 
7348   412F FF FF FF FF 
7348   4133 FF FF FF FF 
7348   4137 FF FF FF FF 
7348   413B FF FF FF FF 
7348   413F FF FF FF FF 
7348   4143 FF FF FF FF 
7348   4147 FF FF FF FF 
7348   414B FF FF FF FF 
7348   414F FF FF FF FF 
7348   4153 FF FF FF FF 
7348   4157 FF FF FF FF 
7348   415B FF FF FF FF 
7348   415F FF FF FF FF 
7348   4163 FF FF FF FF 
7348   4167 FF FF FF FF 
7348   416B FF FF FF FF 
7348   416F FF FF FF FF 
7348   4173 FF FF FF FF 
7348   4177 FF FF FF FF 
7348   417B FF FF FF FF 
7348   417F FF FF FF FF 
7348   4183 FF FF FF FF 
7348   4187 FF FF FF FF 
7348   418B FF FF FF FF 
7348   418F FF FF FF FF 
7348   4193 FF FF FF FF 
7348   4197 FF FF FF FF 
7348   419B FF FF FF FF 
7348   419F FF FF FF FF 
7348   41A3 FF FF FF FF 
7348   41A7 FF FF FF FF 
7348   41AB FF FF FF FF 
7348   41AF FF FF FF FF 
7348   41B3 FF FF FF FF 
7348   41B7 FF FF FF FF 
7348   41BB FF FF FF FF 
7348   41BF FF FF FF FF 
7348   41C3 FF FF FF FF 
7348   41C7 FF FF FF FF 
7348   41CB FF FF FF FF 
7348   41CF FF FF FF FF 
7348   41D3 FF FF FF FF 
7348   41D7 FF FF FF FF 
7348   41DB FF FF FF FF 
7348   41DF FF FF FF FF 
7348   41E3 FF FF FF FF 
7348   41E7 FF FF FF FF 
7348   41EB FF FF FF FF 
7348   41EF FF FF FF FF 
7348   41F3 FF FF FF FF 
7348   41F7 FF FF FF FF 
7348   41FB FF FF FF FF 
7348   41FF FF FF FF FF 
7348   4203 FF FF FF FF 
7348   4207 FF FF FF FF 
7348   420B FF FF FF FF 
7348   420F FF FF FF FF 
7348   4213 FF FF FF FF 
7348   4217 FF FF FF FF 
7348   421B FF FF FF FF 
7348   421F FF FF FF FF 
7348   4223 FF FF FF FF 
7348   4227 FF FF FF FF 
7348   422B FF FF FF FF 
7348   422F FF FF FF FF 
7348   4233 FF FF FF FF 
7348   4237 FF FF FF FF 
7348   423B FF FF FF FF 
7348   423F FF FF FF FF 
7348   4243 FF FF FF FF 
7348   4247 FF FF FF FF 
7348   424B FF FF FF FF 
7348   424F FF FF FF FF 
7348   4253 FF FF FF FF 
7348   4257 FF FF FF FF 
7348   425B FF FF FF FF 
7348   425F FF FF FF FF 
7348   4263 FF FF FF FF 
7348   4267 FF FF FF FF 
7348   426B FF FF FF FF 
7348   426F FF FF FF FF 
7348   4273 FF FF FF FF 
7348   4277 FF FF FF FF 
7348   427B FF FF FF FF 
7348   427F FF FF FF FF 
7348   4283 FF FF FF FF 
7348   4287 FF FF FF FF 
7348   428B FF FF FF FF 
7348   428F FF FF FF FF 
7348   4293 FF FF FF FF 
7348   4297 FF FF FF FF 
7348   429B FF FF FF FF 
7348   429F FF FF FF FF 
7348   42A3 FF FF FF FF 
7348   42A7 FF FF FF FF 
7348   42AB FF FF FF FF 
7348   42AF FF FF FF FF 
7348   42B3 FF FF FF FF 
7348   42B7 FF FF FF FF 
7348   42BB FF FF FF FF 
7348   42BF FF FF FF FF 
7348   42C3 FF FF FF FF 
7348   42C7 FF FF FF FF 
7348   42CB FF FF FF FF 
7348   42CF FF FF FF FF 
7348   42D3 FF FF FF FF 
7348   42D7 FF FF FF FF 
7348   42DB FF FF FF FF 
7348   42DF FF FF FF FF 
7348   42E3 FF FF FF FF 
7348   42E7 FF FF FF FF 
7348   42EB FF FF FF FF 
7348   42EF FF FF FF FF 
7348   42F3 FF FF FF FF 
7348   42F7 FF FF FF FF 
7348   42FB FF FF FF FF 
7348   42FF FF FF FF FF 
7348   4303 FF FF FF FF 
7348   4307 FF FF FF FF 
7348   430B FF FF FF FF 
7348   430F FF FF FF FF 
7348   4313 FF FF FF FF 
7348   4317 FF FF FF FF 
7348   431B FF FF FF FF 
7348   431F FF FF FF FF 
7348   4323 FF FF FF FF 
7348   4327 FF FF FF FF 
7348   432B FF FF FF FF 
7348   432F FF FF FF FF 
7348   4333 FF FF FF FF 
7348   4337 FF FF FF FF 
7348   433B FF FF FF FF 
7348   433F FF FF FF FF 
7348   4343 FF FF FF FF 
7348   4347 FF FF FF FF 
7348   434B FF FF FF FF 
7348   434F FF FF FF FF 
7348   4353 FF FF FF FF 
7348   4357 FF FF FF FF 
7348   435B FF FF FF FF 
7348   435F FF FF FF FF 
7348   4363 FF FF FF FF 
7348   4367 FF FF FF FF 
7348   436B FF FF FF FF 
7348   436F FF FF FF FF 
7348   4373 FF FF FF FF 
7348   4377 FF FF FF FF 
7348   437B FF FF FF FF 
7348   437F FF FF FF FF 
7348   4383 FF FF FF FF 
7348   4387 FF FF FF FF 
7348   438B FF FF FF FF 
7348   438F FF FF FF FF 
7348   4393 FF FF FF FF 
7348   4397 FF FF FF FF 
7348   439B FF FF FF FF 
7348   439F FF FF FF FF 
7348   43A3 FF FF FF FF 
7348   43A7 FF FF FF FF 
7348   43AB FF FF FF FF 
7348   43AF FF FF FF FF 
7348   43B3 FF FF FF FF 
7348   43B7 FF FF FF FF 
7348   43BB FF FF FF FF 
7348   43BF FF FF FF FF 
7348   43C3 FF FF FF FF 
7348   43C7 FF FF FF FF 
7348   43CB FF FF FF FF 
7348   43CF FF FF FF FF 
7348   43D3 FF FF FF FF 
7348   43D7 FF FF FF FF 
7348   43DB FF FF FF FF 
7348   43DF FF FF FF FF 
7348   43E3 FF FF FF FF 
7348   43E7 FF FF FF FF 
7348   43EB FF FF FF FF 
7348   43EF FF FF FF FF 
7348   43F3 FF FF FF FF 
7348   43F7 FF FF FF FF 
7348   43FB FF FF FF FF 
7348   43FF FF FF FF FF 
7348   4403 FF FF FF FF 
7348   4407 FF FF FF FF 
7348   440B FF FF FF FF 
7348   440F FF FF FF FF 
7348   4413 FF FF FF FF 
7348   4417 FF FF FF FF 
7348   441B FF FF FF FF 
7348   441F FF FF FF FF 
7348   4423 FF FF FF FF 
7348   4427 FF FF FF FF 
7348   442B FF FF FF FF 
7348   442F FF FF FF FF 
7348   4433 FF FF FF FF 
7348   4437 FF FF FF FF 
7348   443B FF FF FF FF 
7348   443F FF FF FF FF 
7348   4443 FF FF FF FF 
7348   4447 FF FF FF FF 
7348   444B FF FF FF FF 
7348   444F FF FF FF FF 
7348   4453 FF FF FF FF 
7348   4457 FF FF FF FF 
7348   445B FF FF FF FF 
7348   445F FF FF FF FF 
7348   4463 FF FF FF FF 
7348   4467 FF FF FF FF 
7348   446B FF FF FF FF 
7348   446F FF FF FF FF 
7348   4473 FF FF FF FF 
7348   4477 FF FF FF FF 
7348   447B FF FF FF FF 
7348   447F FF FF FF FF 
7348   4483 FF FF FF FF 
7348   4487 FF FF FF FF 
7348   448B FF FF FF FF 
7348   448F FF FF FF FF 
7348   4493 FF FF FF FF 
7348   4497 FF FF FF FF 
7348   449B FF FF FF FF 
7348   449F FF FF FF FF 
7348   44A3 FF FF FF FF 
7348   44A7 FF FF FF FF 
7348   44AB FF FF FF FF 
7348   44AF FF FF FF FF 
7348   44B3 FF FF FF FF 
7348   44B7 FF FF FF FF 
7348   44BB FF FF FF FF 
7348   44BF FF FF FF FF 
7348   44C3 FF FF FF FF 
7348   44C7 FF FF FF FF 
7348   44CB FF FF FF FF 
7348   44CF FF FF FF FF 
7348   44D3 FF FF FF FF 
7348   44D7 FF FF FF FF 
7348   44DB FF FF FF FF 
7348   44DF FF FF FF FF 
7348   44E3 FF FF FF FF 
7348   44E7 FF FF FF FF 
7348   44EB FF FF FF FF 
7348   44EF FF FF FF FF 
7348   44F3 FF FF FF FF 
7348   44F7 FF FF FF FF 
7348   44FB FF FF FF FF 
7348   44FF FF FF FF FF 
7348   4503 FF FF FF FF 
7348   4507 FF FF FF FF 
7348   450B FF FF FF FF 
7348   450F FF FF FF FF 
7348   4513 FF FF FF FF 
7348   4517 FF FF FF FF 
7348   451B FF FF FF FF 
7348   451F FF FF FF FF 
7348   4523 FF FF FF FF 
7348   4527 FF FF FF FF 
7348   452B FF FF FF FF 
7348   452F FF FF FF FF 
7348   4533 FF FF FF FF 
7348   4537 FF FF FF FF 
7348   453B FF FF FF FF 
7348   453F FF FF FF FF 
7348   4543 FF FF FF FF 
7348   4547 FF FF FF FF 
7348   454B FF FF FF FF 
7348   454F FF FF FF FF 
7348   4553 FF FF FF FF 
7348   4557 FF FF FF FF 
7348   455B FF FF FF FF 
7348   455F FF FF FF FF 
7348   4563 FF FF FF FF 
7348   4567 FF FF FF FF 
7348   456B FF FF FF FF 
7348   456F FF FF FF FF 
7348   4573 FF FF FF FF 
7348   4577 FF FF FF FF 
7348   457B FF FF FF FF 
7348   457F FF FF FF FF 
7348   4583 FF FF FF FF 
7348   4587 FF FF FF FF 
7348   458B FF FF FF FF 
7348   458F FF FF FF FF 
7348   4593 FF FF FF FF 
7348   4597 FF FF FF FF 
7348   459B FF FF FF FF 
7348   459F FF FF FF FF 
7348   45A3 FF FF FF FF 
7348   45A7 FF FF FF FF 
7348   45AB FF FF FF FF 
7348   45AF FF FF FF FF 
7348   45B3 FF FF FF FF 
7348   45B7 FF FF FF FF 
7348   45BB FF FF FF FF 
7348   45BF FF FF FF FF 
7348   45C3 FF FF FF FF 
7348   45C7 FF FF FF FF 
7348   45CB FF FF FF FF 
7348   45CF FF FF FF FF 
7348   45D3 FF FF FF FF 
7348   45D7 FF FF FF FF 
7348   45DB FF FF FF FF 
7348   45DF FF FF FF FF 
7348   45E3 FF FF FF FF 
7348   45E7 FF FF FF FF 
7348   45EB FF FF FF FF 
7348   45EF FF FF FF FF 
7348   45F3 FF FF FF FF 
7348   45F7 FF FF FF FF 
7348   45FB FF FF FF FF 
7348   45FF FF FF FF FF 
7348   4603 FF FF FF FF 
7348   4607 FF FF FF FF 
7348   460B FF FF FF FF 
7348   460F FF FF FF FF 
7348   4613 FF FF FF FF 
7348   4617 FF FF FF FF 
7348   461B FF FF FF FF 
7348   461F FF FF FF FF 
7348   4623 FF FF FF FF 
7348   4627 FF FF FF FF 
7348   462B FF FF FF FF 
7348   462F FF FF FF FF 
7348   4633 FF FF FF FF 
7348   4637 FF FF FF FF 
7348   463B FF FF FF FF 
7348   463F FF FF FF FF 
7348   4643 FF FF FF FF 
7348   4647 FF FF FF FF 
7348   464B FF FF FF FF 
7348   464F FF FF FF FF 
7348   4653 FF FF FF FF 
7348   4657 FF FF FF FF 
7348   465B FF FF FF FF 
7348   465F FF FF FF FF 
7348   4663 FF FF FF FF 
7348   4667 FF FF FF FF 
7348   466B FF FF FF FF 
7348   466F FF FF FF FF 
7348   4673 FF FF FF FF 
7348   4677 FF FF FF FF 
7348   467B FF FF FF FF 
7348   467F FF FF FF FF 
7348   4683 FF FF FF FF 
7348   4687 FF FF FF FF 
7348   468B FF FF FF FF 
7348   468F FF FF FF FF 
7348   4693 FF FF FF FF 
7348   4697 FF FF FF FF 
7348   469B FF FF FF FF 
7348   469F FF FF FF FF 
7348   46A3 FF FF FF FF 
7348   46A7 FF FF FF FF 
7348   46AB FF FF FF FF 
7348   46AF FF FF FF FF 
7348   46B3 FF FF FF FF 
7348   46B7 FF FF FF FF 
7348   46BB FF FF FF FF 
7348   46BF FF FF FF FF 
7348   46C3 FF FF FF FF 
7348   46C7 FF FF FF FF 
7348   46CB FF FF FF FF 
7348   46CF FF FF FF FF 
7348   46D3 FF FF FF FF 
7348   46D7 FF FF FF FF 
7348   46DB FF FF FF FF 
7348   46DF FF FF FF FF 
7348   46E3 FF FF FF FF 
7348   46E7 FF FF FF FF 
7348   46EB FF FF FF FF 
7348   46EF FF FF FF FF 
7348   46F3 FF FF FF FF 
7348   46F7 FF FF FF FF 
7348   46FB FF FF FF FF 
7348   46FF FF FF FF FF 
7348   4703 FF FF FF FF 
7348   4707 FF FF FF FF 
7348   470B FF FF FF FF 
7348   470F FF FF FF FF 
7348   4713 FF FF FF FF 
7348   4717 FF FF FF FF 
7348   471B FF FF FF FF 
7348   471F FF FF FF FF 
7348   4723 FF FF FF FF 
7348   4727 FF FF FF FF 
7348   472B FF FF FF FF 
7348   472F FF FF FF FF 
7348   4733 FF FF FF FF 
7348   4737 FF FF FF FF 
7348   473B FF FF FF FF 
7348   473F FF FF FF FF 
7348   4743 FF FF FF FF 
7348   4747 FF FF FF FF 
7348   474B FF FF FF FF 
7348   474F FF FF FF FF 
7348   4753 FF FF FF FF 
7348   4757 FF FF FF FF 
7348   475B FF FF FF FF 
7348   475F FF FF FF FF 
7348   4763 FF FF FF FF 
7348   4767 FF FF FF FF 
7348   476B FF FF FF FF 
7348   476F FF FF FF FF 
7348   4773 FF FF FF FF 
7348   4777 FF FF FF FF 
7348   477B FF FF FF FF 
7348   477F FF FF FF FF 
7348   4783 FF FF FF FF 
7348   4787 FF FF FF FF 
7348   478B FF FF FF FF 
7348   478F FF FF FF FF 
7348   4793 FF FF FF FF 
7348   4797 FF FF FF FF 
7348   479B FF FF FF FF 
7348   479F FF FF FF FF 
7348   47A3 FF FF FF FF 
7348   47A7 FF FF FF FF 
7348   47AB FF FF FF FF 
7348   47AF FF FF FF FF 
7348   47B3 FF FF FF FF 
7348   47B7 FF FF FF FF 
7348   47BB FF FF FF FF 
7348   47BF FF FF FF FF 
7348   47C3 FF FF FF FF 
7348   47C7 FF FF FF FF 
7348   47CB FF FF FF FF 
7348   47CF FF FF FF FF 
7348   47D3 FF FF FF FF 
7348   47D7 FF FF FF FF 
7348   47DB FF FF FF FF 
7348   47DF FF FF FF FF 
7348   47E3 FF FF FF FF 
7348   47E7 FF FF FF FF 
7348   47EB FF FF FF FF 
7348   47EF FF FF FF FF 
7348   47F3 FF FF FF FF 
7348   47F7 FF FF FF FF 
7348   47FB FF FF FF FF 
7348   47FF FF FF FF FF 
7348   4803 FF FF FF FF 
7348   4807 FF FF FF FF 
7348   480B FF FF FF FF 
7348   480F FF FF FF FF 
7348   4813 FF FF FF FF 
7348   4817 FF FF FF FF 
7348   481B FF FF FF FF 
7348   481F FF FF FF FF 
7348   4823 FF FF FF FF 
7348   4827 FF FF FF FF 
7348   482B FF FF FF FF 
7348   482F FF FF FF FF 
7348   4833 FF FF FF FF 
7348   4837 FF FF FF FF 
7348   483B FF FF FF FF 
7348   483F FF FF FF FF 
7348   4843 FF FF FF FF 
7348   4847 FF FF FF FF 
7348   484B FF FF FF FF 
7348   484F FF FF FF FF 
7348   4853 FF FF FF FF 
7348   4857 FF FF FF FF 
7348   485B FF FF FF FF 
7348   485F FF FF FF FF 
7348   4863 FF FF FF FF 
7348   4867 FF FF FF FF 
7348   486B FF FF FF FF 
7348   486F FF FF FF FF 
7348   4873 FF FF FF FF 
7348   4877 FF FF FF FF 
7348   487B FF FF FF FF 
7348   487F FF FF FF FF 
7348   4883 FF FF FF FF 
7348   4887 FF FF FF FF 
7348   488B FF FF FF FF 
7348   488F FF FF FF FF 
7348   4893 FF FF FF FF 
7348   4897 FF FF FF FF 
7348   489B FF FF FF FF 
7348   489F FF FF FF FF 
7348   48A3 FF FF FF FF 
7348   48A7 FF FF FF FF 
7348   48AB FF FF FF FF 
7348   48AF FF FF FF FF 
7348   48B3 FF FF FF FF 
7348   48B7 FF FF FF FF 
7348   48BB FF FF FF FF 
7348   48BF FF FF FF FF 
7348   48C3 FF FF FF FF 
7348   48C7 FF FF FF FF 
7348   48CB FF FF FF FF 
7348   48CF FF FF FF FF 
7348   48D3 FF FF FF FF 
7348   48D7 FF FF FF FF 
7348   48DB FF FF FF FF 
7348   48DF FF FF FF FF 
7348   48E3 FF FF FF FF 
7348   48E7 FF FF FF FF 
7348   48EB FF FF FF FF 
7348   48EF FF FF FF FF 
7348   48F3 FF FF FF FF 
7348   48F7 FF FF FF FF 
7348   48FB FF FF FF FF 
7348   48FF FF FF FF FF 
7348   4903 FF FF FF FF 
7348   4907 FF FF FF FF 
7348   490B FF FF FF FF 
7348   490F FF FF FF FF 
7348   4913 FF FF FF FF 
7348   4917 FF FF FF FF 
7348   491B FF FF FF FF 
7348   491F FF FF FF FF 
7348   4923 FF FF FF FF 
7348   4927 FF FF FF FF 
7348   492B FF FF FF FF 
7348   492F FF FF FF FF 
7348   4933 FF FF FF FF 
7348   4937 FF FF FF FF 
7348   493B FF FF FF FF 
7348   493F FF FF FF FF 
7348   4943 FF FF FF FF 
7348   4947 FF FF FF FF 
7348   494B FF FF FF FF 
7348   494F FF FF FF FF 
7348   4953 FF FF FF FF 
7348   4957 FF FF FF FF 
7348   495B FF FF FF FF 
7348   495F FF FF FF FF 
7348   4963 FF FF FF FF 
7348   4967 FF FF FF FF 
7348   496B FF FF FF FF 
7348   496F FF FF FF FF 
7348   4973 FF FF FF FF 
7348   4977 FF FF FF FF 
7348   497B FF FF FF FF 
7348   497F FF FF FF FF 
7348   4983 FF FF FF FF 
7348   4987 FF FF FF FF 
7348   498B FF FF FF FF 
7348   498F FF FF FF FF 
7348   4993 FF FF FF FF 
7348   4997 FF FF FF FF 
7348   499B FF FF FF FF 
7348   499F FF FF FF FF 
7348   49A3 FF FF FF FF 
7348   49A7 FF FF FF FF 
7348   49AB FF FF FF FF 
7348   49AF FF FF FF FF 
7348   49B3 FF FF FF FF 
7348   49B7 FF FF FF FF 
7348   49BB FF FF FF FF 
7348   49BF FF FF FF FF 
7348   49C3 FF FF FF FF 
7348   49C7 FF FF FF FF 
7348   49CB FF FF FF FF 
7348   49CF FF FF FF FF 
7348   49D3 FF FF FF FF 
7348   49D7 FF FF FF FF 
7348   49DB FF FF FF FF 
7348   49DF FF FF FF FF 
7348   49E3 FF FF FF FF 
7348   49E7 FF FF FF FF 
7348   49EB FF FF FF FF 
7348   49EF FF FF FF FF 
7348   49F3 FF FF FF FF 
7348   49F7 FF FF FF FF 
7348   49FB FF FF FF FF 
7348   49FF FF FF FF FF 
7348   4A03 FF FF FF FF 
7348   4A07 FF FF FF FF 
7348   4A0B FF FF FF FF 
7348   4A0F FF FF FF FF 
7348   4A13 FF FF FF FF 
7348   4A17 FF FF FF FF 
7348   4A1B FF FF FF FF 
7348   4A1F FF FF FF FF 
7348   4A23 FF FF FF FF 
7348   4A27 FF FF FF FF 
7348   4A2B FF FF FF FF 
7348   4A2F FF FF FF FF 
7348   4A33 FF FF FF FF 
7348   4A37 FF FF FF FF 
7348   4A3B FF FF FF FF 
7348   4A3F FF FF FF FF 
7348   4A43 FF FF FF FF 
7348   4A47 FF FF FF FF 
7348   4A4B FF FF FF FF 
7348   4A4F FF FF FF FF 
7348   4A53 FF FF FF FF 
7348   4A57 FF FF FF FF 
7348   4A5B FF FF FF FF 
7348   4A5F FF FF FF FF 
7348   4A63 FF FF FF FF 
7348   4A67 FF FF FF FF 
7348   4A6B FF FF FF FF 
7348   4A6F FF FF FF FF 
7348   4A73 FF FF FF FF 
7348   4A77 FF FF FF FF 
7348   4A7B FF FF FF FF 
7348   4A7F FF FF FF FF 
7348   4A83 FF FF FF FF 
7348   4A87 FF FF FF FF 
7348   4A8B FF FF FF FF 
7348   4A8F FF FF FF FF 
7348   4A93 FF FF FF FF 
7348   4A97 FF FF FF FF 
7348   4A9B FF FF FF FF 
7348   4A9F FF FF FF FF 
7348   4AA3 FF FF FF FF 
7348   4AA7 FF FF FF FF 
7348   4AAB FF FF FF FF 
7348   4AAF FF FF FF FF 
7348   4AB3 FF FF FF FF 
7348   4AB7 FF FF FF FF 
7348   4ABB FF FF FF FF 
7348   4ABF FF FF FF FF 
7348   4AC3 FF FF FF FF 
7348   4AC7 FF FF FF FF 
7348   4ACB FF FF FF FF 
7348   4ACF FF FF FF FF 
7348   4AD3 FF FF FF FF 
7348   4AD7 FF FF FF FF 
7348   4ADB FF FF FF FF 
7348   4ADF FF FF FF FF 
7348   4AE3 FF FF FF FF 
7348   4AE7 FF FF FF FF 
7348   4AEB FF FF FF FF 
7348   4AEF FF FF FF FF 
7348   4AF3 FF FF FF FF 
7348   4AF7 FF FF FF FF 
7348   4AFB FF FF FF FF 
7348   4AFF FF FF FF FF 
7348   4B03 FF FF FF FF 
7348   4B07 FF FF FF FF 
7348   4B0B FF FF FF FF 
7348   4B0F FF FF FF FF 
7348   4B13 FF FF FF FF 
7348   4B17 FF FF FF FF 
7348   4B1B FF FF FF FF 
7348   4B1F FF FF FF FF 
7348   4B23 FF FF FF FF 
7348   4B27 FF FF FF FF 
7348   4B2B FF FF FF FF 
7348   4B2F FF FF FF FF 
7348   4B33 FF FF FF FF 
7348   4B37 FF FF FF FF 
7348   4B3B FF FF FF FF 
7348   4B3F FF FF FF FF 
7348   4B43 FF FF FF FF 
7348   4B47 FF FF FF FF 
7348   4B4B FF FF FF FF 
7348   4B4F FF FF FF FF 
7348   4B53 FF FF FF FF 
7348   4B57 FF FF FF FF 
7348   4B5B FF FF FF FF 
7348   4B5F FF FF FF FF 
7348   4B63 FF FF FF FF 
7348   4B67 FF FF FF FF 
7348   4B6B FF FF FF FF 
7348   4B6F FF FF FF FF 
7348   4B73 FF FF FF FF 
7348   4B77 FF FF FF FF 
7348   4B7B FF FF FF FF 
7348   4B7F FF FF FF FF 
7348   4B83 FF FF FF FF 
7348   4B87 FF FF FF FF 
7348   4B8B FF FF FF FF 
7348   4B8F FF FF FF FF 
7348   4B93 FF FF FF FF 
7348   4B97 FF FF FF FF 
7348   4B9B FF FF FF FF 
7348   4B9F FF FF FF FF 
7348   4BA3 FF FF FF FF 
7348   4BA7 FF FF FF FF 
7348   4BAB FF FF FF FF 
7348   4BAF FF FF FF FF 
7348   4BB3 FF FF FF FF 
7348   4BB7 FF FF FF FF 
7348   4BBB FF FF FF FF 
7348   4BBF FF FF FF FF 
7348   4BC3 FF FF FF FF 
7348   4BC7 FF FF FF FF 
7348   4BCB FF FF FF FF 
7348   4BCF FF FF FF FF 
7348   4BD3 FF FF FF FF 
7348   4BD7 FF FF FF FF 
7348   4BDB FF FF FF FF 
7348   4BDF FF FF FF FF 
7348   4BE3 FF FF FF FF 
7348   4BE7 FF FF FF FF 
7348   4BEB FF FF FF FF 
7348   4BEF FF FF FF FF 
7348   4BF3 FF FF FF FF 
7348   4BF7 FF FF FF FF 
7348   4BFB FF FF FF FF 
7348   4BFF FF FF FF FF 
7348   4C03 FF FF FF FF 
7348   4C07 FF FF FF FF 
7348   4C0B FF FF FF FF 
7348   4C0F FF FF FF FF 
7348   4C13 FF FF FF FF 
7348   4C17 FF FF FF FF 
7348   4C1B FF FF FF FF 
7348   4C1F FF FF FF FF 
7348   4C23 FF FF FF FF 
7348   4C27 FF FF FF FF 
7348   4C2B FF FF FF FF 
7348   4C2F FF FF FF FF 
7348   4C33 FF FF FF FF 
7348   4C37 FF FF FF FF 
7348   4C3B FF FF FF FF 
7348   4C3F FF FF FF FF 
7348   4C43 FF FF FF FF 
7348   4C47 FF FF FF FF 
7348   4C4B FF FF FF FF 
7348   4C4F FF FF FF FF 
7348   4C53 FF FF FF FF 
7348   4C57 FF FF FF FF 
7348   4C5B FF FF FF FF 
7348   4C5F FF FF FF FF 
7348   4C63 FF FF FF FF 
7348   4C67 FF FF FF FF 
7348   4C6B FF FF FF FF 
7348   4C6F FF FF FF FF 
7348   4C73 FF FF FF FF 
7348   4C77 FF FF FF FF 
7348   4C7B FF FF FF FF 
7348   4C7F FF FF FF FF 
7348   4C83 FF FF FF FF 
7348   4C87 FF FF FF FF 
7348   4C8B FF FF FF FF 
7348   4C8F FF FF FF FF 
7348   4C93 FF FF FF FF 
7348   4C97 FF FF FF FF 
7348   4C9B FF FF FF FF 
7348   4C9F FF FF FF FF 
7348   4CA3 FF FF FF FF 
7348   4CA7 FF FF FF FF 
7348   4CAB FF FF FF FF 
7348   4CAF FF FF FF FF 
7348   4CB3 FF FF FF FF 
7348   4CB7 FF FF FF FF 
7348   4CBB FF FF FF FF 
7348   4CBF FF FF FF FF 
7348   4CC3 FF FF FF FF 
7348   4CC7 FF FF FF FF 
7348   4CCB FF FF FF FF 
7348   4CCF FF FF FF FF 
7348   4CD3 FF FF FF FF 
7348   4CD7 FF FF FF FF 
7348   4CDB FF FF FF FF 
7348   4CDF FF FF FF FF 
7348   4CE3 FF FF FF FF 
7348   4CE7 FF FF FF FF 
7348   4CEB FF FF FF FF 
7348   4CEF FF FF FF FF 
7348   4CF3 FF FF FF FF 
7348   4CF7 FF FF FF FF 
7348   4CFB FF FF FF FF 
7348   4CFF FF FF FF FF 
7348   4D03 FF FF FF FF 
7348   4D07 FF FF FF FF 
7348   4D0B FF FF FF FF 
7348   4D0F FF FF FF FF 
7348   4D13 FF FF FF FF 
7348   4D17 FF FF FF FF 
7348   4D1B FF FF FF FF 
7348   4D1F FF FF FF FF 
7348   4D23 FF FF FF FF 
7348   4D27 FF FF FF FF 
7348   4D2B FF FF FF FF 
7348   4D2F FF FF FF FF 
7348   4D33 FF FF FF FF 
7348   4D37 FF FF FF FF 
7348   4D3B FF FF FF FF 
7348   4D3F FF FF FF FF 
7348   4D43 FF FF FF FF 
7348   4D47 FF FF FF FF 
7348   4D4B FF FF FF FF 
7348   4D4F FF FF FF FF 
7348   4D53 FF FF FF FF 
7348   4D57 FF FF FF FF 
7348   4D5B FF FF FF FF 
7348   4D5F FF FF FF FF 
7348   4D63 FF FF FF FF 
7348   4D67 FF FF FF FF 
7348   4D6B FF FF FF FF 
7348   4D6F FF FF FF FF 
7348   4D73 FF FF FF FF 
7348   4D77 FF FF FF FF 
7348   4D7B FF FF FF FF 
7348   4D7F FF FF FF FF 
7348   4D83 FF FF FF FF 
7348   4D87 FF FF FF FF 
7348   4D8B FF FF FF FF 
7348   4D8F FF FF FF FF 
7348   4D93 FF FF FF FF 
7348   4D97 FF FF FF FF 
7348   4D9B FF FF FF FF 
7348   4D9F FF FF FF FF 
7348   4DA3 FF FF FF FF 
7348   4DA7 FF FF FF FF 
7348   4DAB FF FF FF FF 
7348   4DAF FF FF FF FF 
7348   4DB3 FF FF FF FF 
7348   4DB7 FF FF FF FF 
7348   4DBB FF FF FF FF 
7348   4DBF FF FF FF FF 
7348   4DC3 FF FF FF FF 
7348   4DC7 FF FF FF FF 
7348   4DCB FF FF FF FF 
7348   4DCF FF FF FF FF 
7348   4DD3 FF FF FF FF 
7348   4DD7 FF FF FF FF 
7348   4DDB FF FF FF FF 
7348   4DDF FF FF FF FF 
7348   4DE3 FF FF FF FF 
7348   4DE7 FF FF FF FF 
7348   4DEB FF FF FF FF 
7348   4DEF FF FF FF FF 
7348   4DF3 FF FF FF FF 
7348   4DF7 FF FF FF FF 
7348   4DFB FF FF FF FF 
7348   4DFF FF FF FF FF 
7348   4E03 FF FF FF FF 
7348   4E07 FF FF FF FF 
7348   4E0B FF FF FF FF 
7348   4E0F FF FF FF FF 
7348   4E13 FF FF FF FF 
7348   4E17 FF FF FF FF 
7348   4E1B FF FF FF FF 
7348   4E1F FF FF FF FF 
7348   4E23 FF FF FF FF 
7348   4E27 FF FF FF FF 
7348   4E2B FF FF FF FF 
7348   4E2F FF FF FF FF 
7348   4E33 FF FF FF FF 
7348   4E37 FF FF FF FF 
7348   4E3B FF FF FF FF 
7348   4E3F FF FF FF FF 
7348   4E43 FF FF FF FF 
7348   4E47 FF FF FF FF 
7348   4E4B FF FF FF FF 
7348   4E4F FF FF FF FF 
7348   4E53 FF FF FF FF 
7348   4E57 FF FF FF FF 
7348   4E5B FF FF FF FF 
7348   4E5F FF FF FF FF 
7348   4E63 FF FF FF FF 
7348   4E67 FF FF FF FF 
7348   4E6B FF FF FF FF 
7348   4E6F FF FF FF FF 
7348   4E73 FF FF FF FF 
7348   4E77 FF FF FF FF 
7348   4E7B FF FF FF FF 
7348   4E7F FF FF FF FF 
7348   4E83 FF FF FF FF 
7348   4E87 FF FF FF FF 
7348   4E8B FF FF FF FF 
7348   4E8F FF FF FF FF 
7348   4E93 FF FF FF FF 
7348   4E97 FF FF FF FF 
7348   4E9B FF FF FF FF 
7348   4E9F FF FF FF FF 
7348   4EA3 FF FF FF FF 
7348   4EA7 FF FF FF FF 
7348   4EAB FF FF FF FF 
7348   4EAF FF FF FF FF 
7348   4EB3 FF FF FF FF 
7348   4EB7 FF FF FF FF 
7348   4EBB FF FF FF FF 
7348   4EBF FF FF FF FF 
7348   4EC3 FF FF FF FF 
7348   4EC7 FF FF FF FF 
7348   4ECB FF FF FF FF 
7348   4ECF FF FF FF FF 
7348   4ED3 FF FF FF FF 
7348   4ED7 FF FF FF FF 
7348   4EDB FF FF FF FF 
7348   4EDF FF FF FF FF 
7348   4EE3 FF FF FF FF 
7348   4EE7 FF FF FF FF 
7348   4EEB FF FF FF FF 
7348   4EEF FF FF FF FF 
7348   4EF3 FF FF FF FF 
7348   4EF7 FF FF FF FF 
7348   4EFB FF FF FF FF 
7348   4EFF FF FF FF FF 
7348   4F03 FF FF FF FF 
7348   4F07 FF FF FF FF 
7348   4F0B FF FF FF FF 
7348   4F0F FF FF FF FF 
7348   4F13 FF FF FF FF 
7348   4F17 FF FF FF FF 
7348   4F1B FF FF FF FF 
7348   4F1F FF FF FF FF 
7348   4F23 FF FF FF FF 
7348   4F27 FF FF FF FF 
7348   4F2B FF FF FF FF 
7348   4F2F FF FF FF FF 
7348   4F33 FF FF FF FF 
7348   4F37 FF FF FF FF 
7348   4F3B FF FF FF FF 
7348   4F3F FF FF FF FF 
7348   4F43 FF FF FF FF 
7348   4F47 FF FF FF FF 
7348   4F4B FF FF FF FF 
7348   4F4F FF FF FF FF 
7348   4F53 FF FF FF FF 
7348   4F57 FF FF FF FF 
7348   4F5B FF FF FF FF 
7348   4F5F FF FF FF FF 
7348   4F63 FF FF FF FF 
7348   4F67 FF FF FF FF 
7348   4F6B FF FF FF FF 
7348   4F6F FF FF FF FF 
7348   4F73 FF FF FF FF 
7348   4F77 FF FF FF FF 
7348   4F7B FF FF FF FF 
7348   4F7F FF FF FF FF 
7348   4F83 FF FF FF FF 
7348   4F87 FF FF FF FF 
7348   4F8B FF FF FF FF 
7348   4F8F FF FF FF FF 
7348   4F93 FF FF FF FF 
7348   4F97 FF FF FF FF 
7348   4F9B FF FF FF FF 
7348   4F9F FF FF FF FF 
7348   4FA3 FF FF FF FF 
7348   4FA7 FF FF FF FF 
7348   4FAB FF FF FF FF 
7348   4FAF FF FF FF FF 
7348   4FB3 FF FF FF FF 
7348   4FB7 FF FF FF FF 
7348   4FBB FF FF FF FF 
7348   4FBF FF FF FF FF 
7348   4FC3 FF FF FF FF 
7348   4FC7 FF FF FF FF 
7348   4FCB FF FF FF FF 
7348   4FCF FF FF FF FF 
7348   4FD3 FF FF FF FF 
7348   4FD7 FF FF FF FF 
7348   4FDB FF FF FF FF 
7348   4FDF FF FF FF FF 
7348   4FE3 FF FF FF FF 
7348   4FE7 FF FF FF FF 
7348   4FEB FF FF FF FF 
7348   4FEF FF FF FF FF 
7348   4FF3 FF FF FF FF 
7348   4FF7 FF FF FF FF 
7348   4FFB FF FF FF FF 
7348   4FFF FF FF FF FF 
7348   5003 FF FF FF FF 
7348   5007 FF FF FF FF 
7348   500B FF FF FF FF 
7348   500F FF FF FF FF 
7348   5013 FF FF FF FF 
7348   5017 FF FF FF FF 
7348   501B FF FF FF FF 
7348   501F FF FF FF FF 
7348   5023 FF FF FF FF 
7348   5027 FF FF FF FF 
7348   502B FF FF FF FF 
7348   502F FF FF FF FF 
7348   5033 FF FF FF FF 
7348   5037 FF FF FF FF 
7348   503B FF FF FF FF 
7348   503F FF FF FF FF 
7348   5043 FF FF FF FF 
7348   5047 FF FF FF FF 
7348   504B FF FF FF FF 
7348   504F FF FF FF FF 
7348   5053 FF FF FF FF 
7348   5057 FF FF FF FF 
7348   505B FF FF FF FF 
7348   505F FF FF FF FF 
7348   5063 FF FF FF FF 
7348   5067 FF FF FF FF 
7348   506B FF FF FF FF 
7348   506F FF FF FF FF 
7348   5073 FF FF FF FF 
7348   5077 FF FF FF FF 
7348   507B FF FF FF FF 
7348   507F FF FF FF FF 
7348   5083 FF FF FF FF 
7348   5087 FF FF FF FF 
7348   508B FF FF FF FF 
7348   508F FF FF FF FF 
7348   5093 FF FF FF FF 
7348   5097 FF FF FF FF 
7348   509B FF FF FF FF 
7348   509F FF FF FF FF 
7348   50A3 FF FF FF FF 
7348   50A7 FF FF FF FF 
7348   50AB FF FF FF FF 
7348   50AF FF FF FF FF 
7348   50B3 FF FF FF FF 
7348   50B7 FF FF FF FF 
7348   50BB FF FF FF FF 
7348   50BF FF FF FF FF 
7348   50C3 FF FF FF FF 
7348   50C7 FF FF FF FF 
7348   50CB FF FF FF FF 
7348   50CF FF FF FF FF 
7348   50D3 FF FF FF FF 
7348   50D7 FF FF FF FF 
7348   50DB FF FF FF FF 
7348   50DF FF FF FF FF 
7348   50E3 FF FF FF FF 
7348   50E7 FF FF FF FF 
7348   50EB FF FF FF FF 
7348   50EF FF FF FF FF 
7348   50F3 FF FF FF FF 
7348   50F7 FF FF FF FF 
7348   50FB FF FF FF FF 
7348   50FF FF FF FF FF 
7348   5103 FF FF FF FF 
7348   5107 FF FF FF FF 
7348   510B FF FF FF FF 
7348   510F FF FF FF FF 
7348   5113 FF FF FF FF 
7348   5117 FF FF FF FF 
7348   511B FF FF FF FF 
7348   511F FF FF FF FF 
7348   5123 FF FF FF FF 
7348   5127 FF FF FF FF 
7348   512B FF FF FF FF 
7348   512F FF FF FF FF 
7348   5133 FF FF FF FF 
7348   5137 FF FF FF FF 
7348   513B FF FF FF FF 
7348   513F FF FF FF FF 
7348   5143 FF FF FF FF 
7348   5147 FF FF FF FF 
7348   514B FF FF FF FF 
7348   514F FF FF FF FF 
7348   5153 FF FF FF FF 
7348   5157 FF FF FF FF 
7348   515B FF FF FF FF 
7348   515F FF FF FF FF 
7348   5163 FF FF FF FF 
7348   5167 FF FF FF FF 
7348   516B FF FF FF FF 
7348   516F FF FF FF FF 
7348   5173 FF FF FF FF 
7348   5177 FF FF FF FF 
7348   517B FF FF FF FF 
7348   517F FF FF FF FF 
7348   5183 FF FF FF FF 
7348   5187 FF FF FF FF 
7348   518B FF FF FF FF 
7348   518F FF FF FF FF 
7348   5193 FF FF FF FF 
7348   5197 FF FF FF FF 
7348   519B FF FF FF FF 
7348   519F FF FF FF FF 
7348   51A3 FF FF FF FF 
7348   51A7 FF FF FF FF 
7348   51AB FF FF FF FF 
7348   51AF FF FF FF FF 
7348   51B3 FF FF FF FF 
7348   51B7 FF FF FF FF 
7348   51BB FF FF FF FF 
7348   51BF FF FF FF FF 
7348   51C3 FF FF FF FF 
7348   51C7 FF FF FF FF 
7348   51CB FF FF FF FF 
7348   51CF FF FF FF FF 
7348   51D3 FF FF FF FF 
7348   51D7 FF FF FF FF 
7348   51DB FF FF FF FF 
7348   51DF FF FF FF FF 
7348   51E3 FF FF FF FF 
7348   51E7 FF FF FF FF 
7348   51EB FF FF FF FF 
7348   51EF FF FF FF FF 
7348   51F3 FF FF FF FF 
7348   51F7 FF FF FF FF 
7348   51FB FF FF FF FF 
7348   51FF FF FF FF FF 
7348   5203 FF FF FF FF 
7348   5207 FF FF FF FF 
7348   520B FF FF FF FF 
7348   520F FF FF FF FF 
7348   5213 FF FF FF FF 
7348   5217 FF FF FF FF 
7348   521B FF FF FF FF 
7348   521F FF FF FF FF 
7348   5223 FF FF FF FF 
7348   5227 FF FF FF FF 
7348   522B FF FF FF FF 
7348   522F FF FF FF FF 
7348   5233 FF FF FF FF 
7348   5237 FF FF FF FF 
7348   523B FF FF FF FF 
7348   523F FF FF FF FF 
7348   5243 FF FF FF FF 
7348   5247 FF FF FF FF 
7348   524B FF FF FF FF 
7348   524F FF FF FF FF 
7348   5253 FF FF FF FF 
7348   5257 FF FF FF FF 
7348   525B FF FF FF FF 
7348   525F FF FF FF FF 
7348   5263 FF FF FF FF 
7348   5267 FF FF FF FF 
7348   526B FF FF FF FF 
7348   526F FF FF FF FF 
7348   5273 FF FF FF FF 
7348   5277 FF FF FF FF 
7348   527B FF FF FF FF 
7348   527F FF FF FF FF 
7348   5283 FF FF FF FF 
7348   5287 FF FF FF FF 
7348   528B FF FF FF FF 
7348   528F FF FF FF FF 
7348   5293 FF FF FF FF 
7348   5297 FF FF FF FF 
7348   529B FF FF FF FF 
7348   529F FF FF FF FF 
7348   52A3 FF FF FF FF 
7348   52A7 FF FF FF FF 
7348   52AB FF FF FF FF 
7348   52AF FF FF FF FF 
7348   52B3 FF FF FF FF 
7348   52B7 FF FF FF FF 
7348   52BB FF FF FF FF 
7348   52BF FF FF FF FF 
7348   52C3 FF FF FF FF 
7348   52C7 FF FF FF FF 
7348   52CB FF FF FF FF 
7348   52CF FF FF FF FF 
7348   52D3 FF FF FF FF 
7348   52D7 FF FF FF FF 
7348   52DB FF FF FF FF 
7348   52DF FF FF FF FF 
7348   52E3 FF FF FF FF 
7348   52E7 FF FF FF FF 
7348   52EB FF FF FF FF 
7348   52EF FF FF FF FF 
7348   52F3 FF FF FF FF 
7348   52F7 FF FF FF FF 
7348   52FB FF FF FF FF 
7348   52FF FF FF FF FF 
7348   5303 FF FF FF FF 
7348   5307 FF FF FF FF 
7348   530B FF FF FF FF 
7348   530F FF FF FF FF 
7348   5313 FF FF FF FF 
7348   5317 FF FF FF FF 
7348   531B FF FF FF FF 
7348   531F FF FF FF FF 
7348   5323 FF FF FF FF 
7348   5327 FF FF FF FF 
7348   532B FF FF FF FF 
7348   532F FF FF FF FF 
7348   5333 FF FF FF FF 
7348   5337 FF FF FF FF 
7348   533B FF FF FF FF 
7348   533F FF FF FF FF 
7348   5343 FF FF FF FF 
7348   5347 FF FF FF FF 
7348   534B FF FF FF FF 
7348   534F FF FF FF FF 
7348   5353 FF FF FF FF 
7348   5357 FF FF FF FF 
7348   535B FF FF FF FF 
7348   535F FF FF FF FF 
7348   5363 FF FF FF FF 
7348   5367 FF FF FF FF 
7348   536B FF FF FF FF 
7348   536F FF FF FF FF 
7348   5373 FF FF FF FF 
7348   5377 FF FF FF FF 
7348   537B FF FF FF FF 
7348   537F FF FF FF FF 
7348   5383 FF FF FF FF 
7348   5387 FF FF FF FF 
7348   538B FF FF FF FF 
7348   538F FF FF FF FF 
7348   5393 FF FF FF FF 
7348   5397 FF FF FF FF 
7348   539B FF FF FF FF 
7348   539F FF FF FF FF 
7348   53A3 FF FF FF FF 
7348   53A7 FF FF FF FF 
7348   53AB FF FF FF FF 
7348   53AF FF FF FF FF 
7348   53B3 FF FF FF FF 
7348   53B7 FF FF FF FF 
7348   53BB FF FF FF FF 
7348   53BF FF FF FF FF 
7348   53C3 FF FF FF FF 
7348   53C7 FF FF FF FF 
7348   53CB FF FF FF FF 
7348   53CF FF FF FF FF 
7348   53D3 FF FF FF FF 
7348   53D7 FF FF FF FF 
7348   53DB FF FF FF FF 
7348   53DF FF FF FF FF 
7348   53E3 FF FF FF FF 
7348   53E7 FF FF FF FF 
7348   53EB FF FF FF FF 
7348   53EF FF FF FF FF 
7348   53F3 FF FF FF FF 
7348   53F7 FF FF FF FF 
7348   53FB FF FF FF FF 
7348   53FF FF FF FF FF 
7348   5403 FF FF FF FF 
7348   5407 FF FF FF FF 
7348   540B FF FF FF FF 
7348   540F FF FF FF FF 
7348   5413 FF FF FF FF 
7348   5417 FF FF FF FF 
7348   541B FF FF FF FF 
7348   541F FF FF FF FF 
7348   5423 FF FF FF FF 
7348   5427 FF FF FF FF 
7348   542B FF FF FF FF 
7348   542F FF FF FF FF 
7348   5433 FF FF FF FF 
7348   5437 FF FF FF FF 
7348   543B FF FF FF FF 
7348   543F FF FF FF FF 
7348   5443 FF FF FF FF 
7348   5447 FF FF FF FF 
7348   544B FF FF FF FF 
7348   544F FF FF FF FF 
7348   5453 FF FF FF FF 
7348   5457 FF FF FF FF 
7348   545B FF FF FF FF 
7348   545F FF FF FF FF 
7348   5463 FF FF FF FF 
7348   5467 FF FF FF FF 
7348   546B FF FF FF FF 
7348   546F FF FF FF FF 
7348   5473 FF FF FF FF 
7348   5477 FF FF FF FF 
7348   547B FF FF FF FF 
7348   547F FF FF FF FF 
7348   5483 FF FF FF FF 
7348   5487 FF FF FF FF 
7348   548B FF FF FF FF 
7348   548F FF FF FF FF 
7348   5493 FF FF FF FF 
7348   5497 FF FF FF FF 
7348   549B FF FF FF FF 
7348   549F FF FF FF FF 
7348   54A3 FF FF FF FF 
7348   54A7 FF FF FF FF 
7348   54AB FF FF FF FF 
7348   54AF FF FF FF FF 
7348   54B3 FF FF FF FF 
7348   54B7 FF FF FF FF 
7348   54BB FF FF FF FF 
7348   54BF FF FF FF FF 
7348   54C3 FF FF FF FF 
7348   54C7 FF FF FF FF 
7348   54CB FF FF FF FF 
7348   54CF FF FF FF FF 
7348   54D3 FF FF FF FF 
7348   54D7 FF FF FF FF 
7348   54DB FF FF FF FF 
7348   54DF FF FF FF FF 
7348   54E3 FF FF FF FF 
7348   54E7 FF FF FF FF 
7348   54EB FF FF FF FF 
7348   54EF FF FF FF FF 
7348   54F3 FF FF FF FF 
7348   54F7 FF FF FF FF 
7348   54FB FF FF FF FF 
7348   54FF FF FF FF FF 
7348   5503 FF FF FF FF 
7348   5507 FF FF FF FF 
7348   550B FF FF FF FF 
7348   550F FF FF FF FF 
7348   5513 FF FF FF FF 
7348   5517 FF FF FF FF 
7348   551B FF FF FF FF 
7348   551F FF FF FF FF 
7348   5523 FF FF FF FF 
7348   5527 FF FF FF FF 
7348   552B FF FF FF FF 
7348   552F FF FF FF FF 
7348   5533 FF FF FF FF 
7348   5537 FF FF FF FF 
7348   553B FF FF FF FF 
7348   553F FF FF FF FF 
7348   5543 FF FF FF FF 
7348   5547 FF FF FF FF 
7348   554B FF FF FF FF 
7348   554F FF FF FF FF 
7348   5553 FF FF FF FF 
7348   5557 FF FF FF FF 
7348   555B FF FF FF FF 
7348   555F FF FF FF FF 
7348   5563 FF FF FF FF 
7348   5567 FF FF FF FF 
7348   556B FF FF FF FF 
7348   556F FF FF FF FF 
7348   5573 FF FF FF FF 
7348   5577 FF FF FF FF 
7348   557B FF FF FF FF 
7348   557F FF FF FF FF 
7348   5583 FF FF FF FF 
7348   5587 FF FF FF FF 
7348   558B FF FF FF FF 
7348   558F FF FF FF FF 
7348   5593 FF FF FF FF 
7348   5597 FF FF FF FF 
7348   559B FF FF FF FF 
7348   559F FF FF FF FF 
7348   55A3 FF FF FF FF 
7348   55A7 FF FF FF FF 
7348   55AB FF FF FF FF 
7348   55AF FF FF FF FF 
7348   55B3 FF FF FF FF 
7348   55B7 FF FF FF FF 
7348   55BB FF FF FF FF 
7348   55BF FF FF FF FF 
7348   55C3 FF FF FF FF 
7348   55C7 FF FF FF FF 
7348   55CB FF FF FF FF 
7348   55CF FF FF FF FF 
7348   55D3 FF FF FF FF 
7348   55D7 FF FF FF FF 
7348   55DB FF FF FF FF 
7348   55DF FF FF FF FF 
7348   55E3 FF FF FF FF 
7348   55E7 FF FF FF FF 
7348   55EB FF FF FF FF 
7348   55EF FF FF FF FF 
7348   55F3 FF FF FF FF 
7348   55F7 FF FF FF FF 
7348   55FB FF FF FF FF 
7348   55FF FF FF FF FF 
7348   5603 FF FF FF FF 
7348   5607 FF FF FF FF 
7348   560B FF FF FF FF 
7348   560F FF FF FF FF 
7348   5613 FF FF FF FF 
7348   5617 FF FF FF FF 
7348   561B FF FF FF FF 
7348   561F FF FF FF FF 
7348   5623 FF FF FF FF 
7348   5627 FF FF FF FF 
7348   562B FF FF FF FF 
7348   562F FF FF FF FF 
7348   5633 FF FF FF FF 
7348   5637 FF FF FF FF 
7348   563B FF FF FF FF 
7348   563F FF FF FF FF 
7348   5643 FF FF FF FF 
7348   5647 FF FF FF FF 
7348   564B FF FF FF FF 
7348   564F FF FF FF FF 
7348   5653 FF FF FF FF 
7348   5657 FF FF FF FF 
7348   565B FF FF FF FF 
7348   565F FF FF FF FF 
7348   5663 FF FF FF FF 
7348   5667 FF FF FF FF 
7348   566B FF FF FF FF 
7348   566F FF FF FF FF 
7348   5673 FF FF FF FF 
7348   5677 FF FF FF FF 
7348   567B FF FF FF FF 
7348   567F FF FF FF FF 
7348   5683 FF FF FF FF 
7348   5687 FF FF FF FF 
7348   568B FF FF FF FF 
7348   568F FF FF FF FF 
7348   5693 FF FF FF FF 
7348   5697 FF FF FF FF 
7348   569B FF FF FF FF 
7348   569F FF FF FF FF 
7348   56A3 FF FF FF FF 
7348   56A7 FF FF FF FF 
7348   56AB FF FF FF FF 
7348   56AF FF FF FF FF 
7348   56B3 FF FF FF FF 
7348   56B7 FF FF FF FF 
7348   56BB FF FF FF FF 
7348   56BF FF FF FF FF 
7348   56C3 FF FF FF FF 
7348   56C7 FF FF FF FF 
7348   56CB FF FF FF FF 
7348   56CF FF FF FF FF 
7348   56D3 FF FF FF FF 
7348   56D7 FF FF FF FF 
7348   56DB FF FF FF FF 
7348   56DF FF FF FF FF 
7348   56E3 FF FF FF FF 
7348   56E7 FF FF FF FF 
7348   56EB FF FF FF FF 
7348   56EF FF FF FF FF 
7348   56F3 FF FF FF FF 
7348   56F7 FF FF FF FF 
7348   56FB FF FF FF FF 
7348   56FF FF FF FF FF 
7348   5703 FF FF FF FF 
7348   5707 FF FF FF FF 
7348   570B FF FF FF FF 
7348   570F FF FF FF FF 
7348   5713 FF FF FF FF 
7348   5717 FF FF FF FF 
7348   571B FF FF FF FF 
7348   571F FF FF FF FF 
7348   5723 FF FF FF FF 
7348   5727 FF FF FF FF 
7348   572B FF FF FF FF 
7348   572F FF FF FF FF 
7348   5733 FF FF FF FF 
7348   5737 FF FF FF FF 
7348   573B FF FF FF FF 
7348   573F FF FF FF FF 
7348   5743 FF FF FF FF 
7348   5747 FF FF FF FF 
7348   574B FF FF FF FF 
7348   574F FF FF FF FF 
7348   5753 FF FF FF FF 
7348   5757 FF FF FF FF 
7348   575B FF FF FF FF 
7348   575F FF FF FF FF 
7348   5763 FF FF FF FF 
7348   5767 FF FF FF FF 
7348   576B FF FF FF FF 
7348   576F FF FF FF FF 
7348   5773 FF FF FF FF 
7348   5777 FF FF FF FF 
7348   577B FF FF FF FF 
7348   577F FF FF FF FF 
7348   5783 FF FF FF FF 
7348   5787 FF FF FF FF 
7348   578B FF FF FF FF 
7348   578F FF FF FF FF 
7348   5793 FF FF FF FF 
7348   5797 FF FF FF FF 
7348   579B FF FF FF FF 
7348   579F FF FF FF FF 
7348   57A3 FF FF FF FF 
7348   57A7 FF FF FF FF 
7348   57AB FF FF FF FF 
7348   57AF FF FF FF FF 
7348   57B3 FF FF FF FF 
7348   57B7 FF FF FF FF 
7348   57BB FF FF FF FF 
7348   57BF FF FF FF FF 
7348   57C3 FF FF FF FF 
7348   57C7 FF FF FF FF 
7348   57CB FF FF FF FF 
7348   57CF FF FF FF FF 
7348   57D3 FF FF FF FF 
7348   57D7 FF FF FF FF 
7348   57DB FF FF FF FF 
7348   57DF FF FF FF FF 
7348   57E3 FF FF FF FF 
7348   57E7 FF FF FF FF 
7348   57EB FF FF FF FF 
7348   57EF FF FF FF FF 
7348   57F3 FF FF FF FF 
7348   57F7 FF FF FF FF 
7348   57FB FF FF FF FF 
7348   57FF FF FF FF FF 
7348   5803 FF FF FF FF 
7348   5807 FF FF FF FF 
7348   580B FF FF FF FF 
7348   580F FF FF FF FF 
7348   5813 FF FF FF FF 
7348   5817 FF FF FF FF 
7348   581B FF FF FF FF 
7348   581F FF FF FF FF 
7348   5823 FF FF FF FF 
7348   5827 FF FF FF FF 
7348   582B FF FF FF FF 
7348   582F FF FF FF FF 
7348   5833 FF FF FF FF 
7348   5837 FF FF FF FF 
7348   583B FF FF FF FF 
7348   583F FF FF FF FF 
7348   5843 FF FF FF FF 
7348   5847 FF FF FF FF 
7348   584B FF FF FF FF 
7348   584F FF FF FF FF 
7348   5853 FF FF FF FF 
7348   5857 FF FF FF FF 
7348   585B FF FF FF FF 
7348   585F FF FF FF FF 
7348   5863 FF FF FF FF 
7348   5867 FF FF FF FF 
7348   586B FF FF FF FF 
7348   586F FF FF FF FF 
7348   5873 FF FF FF FF 
7348   5877 FF FF FF FF 
7348   587B FF FF FF FF 
7348   587F FF FF FF FF 
7348   5883 FF FF FF FF 
7348   5887 FF FF FF FF 
7348   588B FF FF FF FF 
7348   588F FF FF FF FF 
7348   5893 FF FF FF FF 
7348   5897 FF FF FF FF 
7348   589B FF FF FF FF 
7348   589F FF FF FF FF 
7348   58A3 FF FF FF FF 
7348   58A7 FF FF FF FF 
7348   58AB FF FF FF FF 
7348   58AF FF FF FF FF 
7348   58B3 FF FF FF FF 
7348   58B7 FF FF FF FF 
7348   58BB FF FF FF FF 
7348   58BF FF FF FF FF 
7348   58C3 FF FF FF FF 
7348   58C7 FF FF FF FF 
7348   58CB FF FF FF FF 
7348   58CF FF FF FF FF 
7348   58D3 FF FF FF FF 
7348   58D7 FF FF FF FF 
7348   58DB FF FF FF FF 
7348   58DF FF FF FF FF 
7348   58E3 FF FF FF FF 
7348   58E7 FF FF FF FF 
7348   58EB FF FF FF FF 
7348   58EF FF FF FF FF 
7348   58F3 FF FF FF FF 
7348   58F7 FF FF FF FF 
7348   58FB FF FF FF FF 
7348   58FF FF FF FF FF 
7348   5903 FF FF FF FF 
7348   5907 FF FF FF FF 
7348   590B FF FF FF FF 
7348   590F FF FF FF FF 
7348   5913 FF FF FF FF 
7348   5917 FF FF FF FF 
7348   591B FF FF FF FF 
7348   591F FF FF FF FF 
7348   5923 FF FF FF FF 
7348   5927 FF FF FF FF 
7348   592B FF FF FF FF 
7348   592F FF FF FF FF 
7348   5933 FF FF FF FF 
7348   5937 FF FF FF FF 
7348   593B FF FF FF FF 
7348   593F FF FF FF FF 
7348   5943 FF FF FF FF 
7348   5947 FF FF FF FF 
7348   594B FF FF FF FF 
7348   594F FF FF FF FF 
7348   5953 FF FF FF FF 
7348   5957 FF FF FF FF 
7348   595B FF FF FF FF 
7348   595F FF FF FF FF 
7348   5963 FF FF FF FF 
7348   5967 FF FF FF FF 
7348   596B FF FF FF FF 
7348   596F FF FF FF FF 
7348   5973 FF FF FF FF 
7348   5977 FF FF FF FF 
7348   597B FF FF FF FF 
7348   597F FF FF FF FF 
7348   5983 FF FF FF FF 
7348   5987 FF FF FF FF 
7348   598B FF FF FF FF 
7348   598F FF FF FF FF 
7348   5993 FF FF FF FF 
7348   5997 FF FF FF FF 
7348   599B FF FF FF FF 
7348   599F FF FF FF FF 
7348   59A3 FF FF FF FF 
7348   59A7 FF FF FF FF 
7348   59AB FF FF FF FF 
7348   59AF FF FF FF FF 
7348   59B3 FF FF FF FF 
7348   59B7 FF FF FF FF 
7348   59BB FF FF FF FF 
7348   59BF FF FF FF FF 
7348   59C3 FF FF FF FF 
7348   59C7 FF FF FF FF 
7348   59CB FF FF FF FF 
7348   59CF FF FF FF FF 
7348   59D3 FF FF FF FF 
7348   59D7 FF FF FF FF 
7348   59DB FF FF FF FF 
7348   59DF FF FF FF FF 
7348   59E3 FF FF FF FF 
7348   59E7 FF FF FF FF 
7348   59EB FF FF FF FF 
7348   59EF FF FF FF FF 
7348   59F3 FF FF FF FF 
7348   59F7 FF FF FF FF 
7348   59FB FF FF FF FF 
7348   59FF FF FF FF FF 
7348   5A03 FF FF FF FF 
7348   5A07 FF FF FF FF 
7348   5A0B FF FF FF FF 
7348   5A0F FF FF FF FF 
7348   5A13 FF FF FF FF 
7348   5A17 FF FF FF FF 
7348   5A1B FF FF FF FF 
7348   5A1F FF FF FF FF 
7348   5A23 FF FF FF FF 
7348   5A27 FF FF FF FF 
7348   5A2B FF FF FF FF 
7348   5A2F FF FF FF FF 
7348   5A33 FF FF FF FF 
7348   5A37 FF FF FF FF 
7348   5A3B FF FF FF FF 
7348   5A3F FF FF FF FF 
7348   5A43 FF FF FF FF 
7348   5A47 FF FF FF FF 
7348   5A4B FF FF FF FF 
7348   5A4F FF FF FF FF 
7348   5A53 FF FF FF FF 
7348   5A57 FF FF FF FF 
7348   5A5B FF FF FF FF 
7348   5A5F FF FF FF FF 
7348   5A63 FF FF FF FF 
7348   5A67 FF FF FF FF 
7348   5A6B FF FF FF FF 
7348   5A6F FF FF FF FF 
7348   5A73 FF FF FF FF 
7348   5A77 FF FF FF FF 
7348   5A7B FF FF FF FF 
7348   5A7F FF FF FF FF 
7348   5A83 FF FF FF FF 
7348   5A87 FF FF FF FF 
7348   5A8B FF FF FF FF 
7348   5A8F FF FF FF FF 
7348   5A93 FF FF FF FF 
7348   5A97 FF FF FF FF 
7348   5A9B FF FF FF FF 
7348   5A9F FF FF FF FF 
7348   5AA3 FF FF FF FF 
7348   5AA7 FF FF FF FF 
7348   5AAB FF FF FF FF 
7348   5AAF FF FF FF FF 
7348   5AB3 FF FF FF FF 
7348   5AB7 FF FF FF FF 
7348   5ABB FF FF FF FF 
7348   5ABF FF FF FF FF 
7348   5AC3 FF FF FF FF 
7348   5AC7 FF FF FF FF 
7348   5ACB FF FF FF FF 
7348   5ACF FF FF FF FF 
7348   5AD3 FF FF FF FF 
7348   5AD7 FF FF FF FF 
7348   5ADB FF FF FF FF 
7348   5ADF FF FF FF FF 
7348   5AE3 FF FF FF FF 
7348   5AE7 FF FF FF FF 
7348   5AEB FF FF FF FF 
7348   5AEF FF FF FF FF 
7348   5AF3 FF FF FF FF 
7348   5AF7 FF FF FF FF 
7348   5AFB FF FF FF FF 
7348   5AFF FF FF FF FF 
7348   5B03 FF FF FF FF 
7348   5B07 FF FF FF FF 
7348   5B0B FF FF FF FF 
7348   5B0F FF FF FF FF 
7348   5B13 FF FF FF FF 
7348   5B17 FF FF FF FF 
7348   5B1B FF FF FF FF 
7348   5B1F FF FF FF FF 
7348   5B23 FF FF FF FF 
7348   5B27 FF FF FF FF 
7348   5B2B FF FF FF FF 
7348   5B2F FF FF FF FF 
7348   5B33 FF FF FF FF 
7348   5B37 FF FF FF FF 
7348   5B3B FF FF FF FF 
7348   5B3F FF FF FF FF 
7348   5B43 FF FF FF FF 
7348   5B47 FF FF FF FF 
7348   5B4B FF FF FF FF 
7348   5B4F FF FF FF FF 
7348   5B53 FF FF FF FF 
7348   5B57 FF FF FF FF 
7348   5B5B FF FF FF FF 
7348   5B5F FF FF FF FF 
7348   5B63 FF FF FF FF 
7348   5B67 FF FF FF FF 
7348   5B6B FF FF FF FF 
7348   5B6F FF FF FF FF 
7348   5B73 FF FF FF FF 
7348   5B77 FF FF FF FF 
7348   5B7B FF FF FF FF 
7348   5B7F FF FF FF FF 
7348   5B83 FF FF FF FF 
7348   5B87 FF FF FF FF 
7348   5B8B FF FF FF FF 
7348   5B8F FF FF FF FF 
7348   5B93 FF FF FF FF 
7348   5B97 FF FF FF FF 
7348   5B9B FF FF FF FF 
7348   5B9F FF FF FF FF 
7348   5BA3 FF FF FF FF 
7348   5BA7 FF FF FF FF 
7348   5BAB FF FF FF FF 
7348   5BAF FF FF FF FF 
7348   5BB3 FF FF FF FF 
7348   5BB7 FF FF FF FF 
7348   5BBB FF FF FF FF 
7348   5BBF FF FF FF FF 
7348   5BC3 FF FF FF FF 
7348   5BC7 FF FF FF FF 
7348   5BCB FF FF FF FF 
7348   5BCF FF FF FF FF 
7348   5BD3 FF FF FF FF 
7348   5BD7 FF FF FF FF 
7348   5BDB FF FF FF FF 
7348   5BDF FF FF FF FF 
7348   5BE3 FF FF FF FF 
7348   5BE7 FF FF FF FF 
7348   5BEB FF FF FF FF 
7348   5BEF FF FF FF FF 
7348   5BF3 FF FF FF FF 
7348   5BF7 FF FF FF FF 
7348   5BFB FF FF FF FF 
7348   5BFF FF FF FF FF 
7348   5C03 FF FF FF FF 
7348   5C07 FF FF FF FF 
7348   5C0B FF FF FF FF 
7348   5C0F FF FF FF FF 
7348   5C13 FF FF FF FF 
7348   5C17 FF FF FF FF 
7348   5C1B FF FF FF FF 
7348   5C1F FF FF FF FF 
7348   5C23 FF FF FF FF 
7348   5C27 FF FF FF FF 
7348   5C2B FF FF FF FF 
7348   5C2F FF FF FF FF 
7348   5C33 FF FF FF FF 
7348   5C37 FF FF FF FF 
7348   5C3B FF FF FF FF 
7348   5C3F FF FF FF FF 
7348   5C43 FF FF FF FF 
7348   5C47 FF FF FF FF 
7348   5C4B FF FF FF FF 
7348   5C4F FF FF FF FF 
7348   5C53 FF FF FF FF 
7348   5C57 FF FF FF FF 
7348   5C5B FF FF FF FF 
7348   5C5F FF FF FF FF 
7348   5C63 FF FF FF FF 
7348   5C67 FF FF FF FF 
7348   5C6B FF FF FF FF 
7348   5C6F FF FF FF FF 
7348   5C73 FF FF FF FF 
7348   5C77 FF FF FF FF 
7348   5C7B FF FF FF FF 
7348   5C7F FF FF FF FF 
7348   5C83 FF FF FF FF 
7348   5C87 FF FF FF FF 
7348   5C8B FF FF FF FF 
7348   5C8F FF FF FF FF 
7348   5C93 FF FF FF FF 
7348   5C97 FF FF FF FF 
7348   5C9B FF FF FF FF 
7348   5C9F FF FF FF FF 
7348   5CA3 FF FF FF FF 
7348   5CA7 FF FF FF FF 
7348   5CAB FF FF FF FF 
7348   5CAF FF FF FF FF 
7348   5CB3 FF FF FF FF 
7348   5CB7 FF FF FF FF 
7348   5CBB FF FF FF FF 
7348   5CBF FF FF FF FF 
7348   5CC3 FF FF FF FF 
7348   5CC7 FF FF FF FF 
7348   5CCB FF FF FF FF 
7348   5CCF FF FF FF FF 
7348   5CD3 FF FF FF FF 
7348   5CD7 FF FF FF FF 
7348   5CDB FF FF FF FF 
7348   5CDF FF FF FF FF 
7348   5CE3 FF FF FF FF 
7348   5CE7 FF FF FF FF 
7348   5CEB FF FF FF FF 
7348   5CEF FF FF FF FF 
7348   5CF3 FF FF FF FF 
7348   5CF7 FF FF FF FF 
7348   5CFB FF FF FF FF 
7348   5CFF FF FF FF FF 
7348   5D03 FF FF FF FF 
7348   5D07 FF FF FF FF 
7348   5D0B FF FF FF FF 
7348   5D0F FF FF FF FF 
7348   5D13 FF FF FF FF 
7348   5D17 FF FF FF FF 
7348   5D1B FF FF FF FF 
7348   5D1F FF FF FF FF 
7348   5D23 FF FF FF FF 
7348   5D27 FF FF FF FF 
7348   5D2B FF FF FF FF 
7348   5D2F FF FF FF FF 
7348   5D33 FF FF FF FF 
7348   5D37 FF FF FF FF 
7348   5D3B FF FF FF FF 
7348   5D3F FF FF FF FF 
7348   5D43 FF FF FF FF 
7348   5D47 FF FF FF FF 
7348   5D4B FF FF FF FF 
7348   5D4F FF FF FF FF 
7348   5D53 FF FF FF FF 
7348   5D57 FF FF FF FF 
7348   5D5B FF FF FF FF 
7348   5D5F FF FF FF FF 
7348   5D63 FF FF FF FF 
7348   5D67 FF FF FF FF 
7348   5D6B FF FF FF FF 
7348   5D6F FF FF FF FF 
7348   5D73 FF FF FF FF 
7348   5D77 FF FF FF FF 
7348   5D7B FF FF FF FF 
7348   5D7F FF FF FF FF 
7348   5D83 FF FF FF FF 
7348   5D87 FF FF FF FF 
7348   5D8B FF FF FF FF 
7348   5D8F FF FF FF FF 
7348   5D93 FF FF FF FF 
7348   5D97 FF FF FF FF 
7348   5D9B FF FF FF FF 
7348   5D9F FF FF FF FF 
7348   5DA3 FF FF FF FF 
7348   5DA7 FF FF FF FF 
7348   5DAB FF FF FF FF 
7348   5DAF FF FF FF FF 
7348   5DB3 FF FF FF FF 
7348   5DB7 FF FF FF FF 
7348   5DBB FF FF FF FF 
7348   5DBF FF FF FF FF 
7348   5DC3 FF FF FF FF 
7348   5DC7 FF FF FF FF 
7348   5DCB FF FF FF FF 
7348   5DCF FF FF FF FF 
7348   5DD3 FF FF FF FF 
7348   5DD7 FF FF FF FF 
7348   5DDB FF FF FF FF 
7348   5DDF FF FF FF FF 
7348   5DE3 FF FF FF FF 
7348   5DE7 FF FF FF FF 
7348   5DEB FF FF FF FF 
7348   5DEF FF FF FF FF 
7348   5DF3 FF FF FF FF 
7348   5DF7 FF FF FF FF 
7348   5DFB FF FF FF FF 
7348   5DFF FF FF FF FF 
7348   5E03 FF FF FF FF 
7348   5E07 FF FF FF FF 
7348   5E0B FF FF FF FF 
7348   5E0F FF FF FF FF 
7348   5E13 FF FF FF FF 
7348   5E17 FF FF FF FF 
7348   5E1B FF FF FF FF 
7348   5E1F FF FF FF FF 
7348   5E23 FF FF FF FF 
7348   5E27 FF FF FF FF 
7348   5E2B FF FF FF FF 
7348   5E2F FF FF FF FF 
7348   5E33 FF FF FF FF 
7348   5E37 FF FF FF FF 
7348   5E3B FF FF FF FF 
7348   5E3F FF FF FF FF 
7348   5E43 FF FF FF FF 
7348   5E47 FF FF FF FF 
7348   5E4B FF FF FF FF 
7348   5E4F FF FF FF FF 
7348   5E53 FF FF FF FF 
7348   5E57 FF FF FF FF 
7348   5E5B FF FF FF FF 
7348   5E5F FF FF FF FF 
7348   5E63 FF FF FF FF 
7348   5E67 FF FF FF FF 
7348   5E6B FF FF FF FF 
7348   5E6F FF FF FF FF 
7348   5E73 FF FF FF FF 
7348   5E77 FF FF FF FF 
7348   5E7B FF FF FF FF 
7348   5E7F FF FF FF FF 
7348   5E83 FF FF FF FF 
7348   5E87 FF FF FF FF 
7348   5E8B FF FF FF FF 
7348   5E8F FF FF FF FF 
7348   5E93 FF FF FF FF 
7348   5E97 FF FF FF FF 
7348   5E9B FF FF FF FF 
7348   5E9F FF FF FF FF 
7348   5EA3 FF FF FF FF 
7348   5EA7 FF FF FF FF 
7348   5EAB FF FF FF FF 
7348   5EAF FF FF FF FF 
7348   5EB3 FF FF FF FF 
7348   5EB7 FF FF FF FF 
7348   5EBB FF FF FF FF 
7348   5EBF FF FF FF FF 
7348   5EC3 FF FF FF FF 
7348   5EC7 FF FF FF FF 
7348   5ECB FF FF FF FF 
7348   5ECF FF FF FF FF 
7348   5ED3 FF FF FF FF 
7348   5ED7 FF FF FF FF 
7348   5EDB FF FF FF FF 
7348   5EDF FF FF FF FF 
7348   5EE3 FF FF FF FF 
7348   5EE7 FF FF FF FF 
7348   5EEB FF FF FF FF 
7348   5EEF FF FF FF FF 
7348   5EF3 FF FF FF FF 
7348   5EF7 FF FF FF FF 
7348   5EFB FF FF FF FF 
7348   5EFF FF FF FF FF 
7348   5F03 FF FF FF FF 
7348   5F07 FF FF FF FF 
7348   5F0B FF FF FF FF 
7348   5F0F FF FF FF FF 
7348   5F13 FF FF FF FF 
7348   5F17 FF FF FF FF 
7348   5F1B FF FF FF FF 
7348   5F1F FF FF FF FF 
7348   5F23 FF FF FF FF 
7348   5F27 FF FF FF FF 
7348   5F2B FF FF FF FF 
7348   5F2F FF FF FF FF 
7348   5F33 FF FF FF FF 
7348   5F37 FF FF FF FF 
7348   5F3B FF FF FF FF 
7348   5F3F FF FF FF FF 
7348   5F43 FF FF FF FF 
7348   5F47 FF FF FF FF 
7348   5F4B FF FF FF FF 
7348   5F4F FF FF FF FF 
7348   5F53 FF FF FF FF 
7348   5F57 FF FF FF FF 
7348   5F5B FF FF FF FF 
7348   5F5F FF FF FF FF 
7348   5F63 FF FF FF FF 
7348   5F67 FF FF FF FF 
7348   5F6B FF FF FF FF 
7348   5F6F FF FF FF FF 
7348   5F73 FF FF FF FF 
7348   5F77 FF FF FF FF 
7348   5F7B FF FF FF FF 
7348   5F7F FF FF FF FF 
7348   5F83 FF FF FF FF 
7348   5F87 FF FF FF FF 
7348   5F8B FF FF FF FF 
7348   5F8F FF FF FF FF 
7348   5F93 FF FF FF FF 
7348   5F97 FF FF FF FF 
7348   5F9B FF FF FF FF 
7348   5F9F FF FF FF FF 
7348   5FA3 FF FF FF FF 
7348   5FA7 FF FF FF FF 
7348   5FAB FF FF FF FF 
7348   5FAF FF FF FF FF 
7348   5FB3 FF FF FF FF 
7348   5FB7 FF FF FF FF 
7348   5FBB FF FF FF FF 
7348   5FBF FF FF FF FF 
7348   5FC3 FF FF FF FF 
7348   5FC7 FF FF FF FF 
7348   5FCB FF FF FF FF 
7348   5FCF FF FF FF FF 
7348   5FD3 FF FF FF FF 
7348   5FD7 FF FF FF FF 
7348   5FDB FF FF FF FF 
7348   5FDF FF FF FF FF 
7348   5FE3 FF FF FF FF 
7348   5FE7 FF FF FF FF 
7348   5FEB FF FF FF FF 
7348   5FEF FF FF FF FF 
7348   5FF3 FF FF FF FF 
7348   5FF7 FF FF FF FF 
7348   5FFB FF FF FF FF 
7348   5FFF FF FF FF FF 
7348   6003 FF FF FF FF 
7348   6007 FF FF FF FF 
7348   600B FF FF FF FF 
7348   600F FF FF FF FF 
7348   6013 FF FF FF FF 
7348   6017 FF FF FF FF 
7348   601B FF FF FF FF 
7348   601F FF FF FF FF 
7348   6023 FF FF FF FF 
7348   6027 FF FF FF FF 
7348   602B FF FF FF FF 
7348   602F FF FF FF FF 
7348   6033 FF FF FF FF 
7348   6037 FF FF FF FF 
7348   603B FF FF FF FF 
7348   603F FF FF FF FF 
7348   6043 FF FF FF FF 
7348   6047 FF FF FF FF 
7348   604B FF FF FF FF 
7348   604F FF FF FF FF 
7348   6053 FF FF FF FF 
7348   6057 FF FF FF FF 
7348   605B FF FF FF FF 
7348   605F FF FF FF FF 
7348   6063 FF FF FF FF 
7348   6067 FF FF FF FF 
7348   606B FF FF FF FF 
7348   606F FF FF FF FF 
7348   6073 FF FF FF FF 
7348   6077 FF FF FF FF 
7348   607B FF FF FF FF 
7348   607F FF FF FF FF 
7348   6083 FF FF FF FF 
7348   6087 FF FF FF FF 
7348   608B FF FF FF FF 
7348   608F FF FF FF FF 
7348   6093 FF FF FF FF 
7348   6097 FF FF FF FF 
7348   609B FF FF FF FF 
7348   609F FF FF FF FF 
7348   60A3 FF FF FF FF 
7348   60A7 FF FF FF FF 
7348   60AB FF FF FF FF 
7348   60AF FF FF FF FF 
7348   60B3 FF FF FF FF 
7348   60B7 FF FF FF FF 
7348   60BB FF FF FF FF 
7348   60BF FF FF FF FF 
7348   60C3 FF FF FF FF 
7348   60C7 FF FF FF FF 
7348   60CB FF FF FF FF 
7348   60CF FF FF FF FF 
7348   60D3 FF FF FF FF 
7348   60D7 FF FF FF FF 
7348   60DB FF FF FF FF 
7348   60DF FF FF FF FF 
7348   60E3 FF FF FF FF 
7348   60E7 FF FF FF FF 
7348   60EB FF FF FF FF 
7348   60EF FF FF FF FF 
7348   60F3 FF FF FF FF 
7348   60F7 FF FF FF FF 
7348   60FB FF FF FF FF 
7348   60FF FF FF FF FF 
7348   6103 FF FF FF FF 
7348   6107 FF FF FF FF 
7348   610B FF FF FF FF 
7348   610F FF FF FF FF 
7348   6113 FF FF FF FF 
7348   6117 FF FF FF FF 
7348   611B FF FF FF FF 
7348   611F FF FF FF FF 
7348   6123 FF FF FF FF 
7348   6127 FF FF FF FF 
7348   612B FF FF FF FF 
7348   612F FF FF FF FF 
7348   6133 FF FF FF FF 
7348   6137 FF FF FF FF 
7348   613B FF FF FF FF 
7348   613F FF FF FF FF 
7348   6143 FF FF FF FF 
7348   6147 FF FF FF FF 
7348   614B FF FF FF FF 
7348   614F FF FF FF FF 
7348   6153 FF FF FF FF 
7348   6157 FF FF FF FF 
7348   615B FF FF FF FF 
7348   615F FF FF FF FF 
7348   6163 FF FF FF FF 
7348   6167 FF FF FF FF 
7348   616B FF FF FF FF 
7348   616F FF FF FF FF 
7348   6173 FF FF FF FF 
7348   6177 FF FF FF FF 
7348   617B FF FF FF FF 
7348   617F FF FF FF FF 
7348   6183 FF FF FF FF 
7348   6187 FF FF FF FF 
7348   618B FF FF FF FF 
7348   618F FF FF FF FF 
7348   6193 FF FF FF FF 
7348   6197 FF FF FF FF 
7348   619B FF FF FF FF 
7348   619F FF FF FF FF 
7348   61A3 FF FF FF FF 
7348   61A7 FF FF FF FF 
7348   61AB FF FF FF FF 
7348   61AF FF FF FF FF 
7348   61B3 FF FF FF FF 
7348   61B7 FF FF FF FF 
7348   61BB FF FF FF FF 
7348   61BF FF FF FF FF 
7348   61C3 FF FF FF FF 
7348   61C7 FF FF FF FF 
7348   61CB FF FF FF FF 
7348   61CF FF FF FF FF 
7348   61D3 FF FF FF FF 
7348   61D7 FF FF FF FF 
7348   61DB FF FF FF FF 
7348   61DF FF FF FF FF 
7348   61E3 FF FF FF FF 
7348   61E7 FF FF FF FF 
7348   61EB FF FF FF FF 
7348   61EF FF FF FF FF 
7348   61F3 FF FF FF FF 
7348   61F7 FF FF FF FF 
7348   61FB FF FF FF FF 
7348   61FF FF FF FF FF 
7348   6203 FF FF FF FF 
7348   6207 FF FF FF FF 
7348   620B FF FF FF FF 
7348   620F FF FF FF FF 
7348   6213 FF FF FF FF 
7348   6217 FF FF FF FF 
7348   621B FF FF FF FF 
7348   621F FF FF FF FF 
7348   6223 FF FF FF FF 
7348   6227 FF FF FF FF 
7348   622B FF FF FF FF 
7348   622F FF FF FF FF 
7348   6233 FF FF FF FF 
7348   6237 FF FF FF FF 
7348   623B FF FF FF FF 
7348   623F FF FF FF FF 
7348   6243 FF FF FF FF 
7348   6247 FF FF FF FF 
7348   624B FF FF FF FF 
7348   624F FF FF FF FF 
7348   6253 FF FF FF FF 
7348   6257 FF FF FF FF 
7348   625B FF FF FF FF 
7348   625F FF FF FF FF 
7348   6263 FF FF FF FF 
7348   6267 FF FF FF FF 
7348   626B FF FF FF FF 
7348   626F FF FF FF FF 
7348   6273 FF FF FF FF 
7348   6277 FF FF FF FF 
7348   627B FF FF FF FF 
7348   627F FF FF FF FF 
7348   6283 FF FF FF FF 
7348   6287 FF FF FF FF 
7348   628B FF FF FF FF 
7348   628F FF FF FF FF 
7348   6293 FF FF FF FF 
7348   6297 FF FF FF FF 
7348   629B FF FF FF FF 
7348   629F FF FF FF FF 
7348   62A3 FF FF FF FF 
7348   62A7 FF FF FF FF 
7348   62AB FF FF FF FF 
7348   62AF FF FF FF FF 
7348   62B3 FF FF FF FF 
7348   62B7 FF FF FF FF 
7348   62BB FF FF FF FF 
7348   62BF FF FF FF FF 
7348   62C3 FF FF FF FF 
7348   62C7 FF FF FF FF 
7348   62CB FF FF FF FF 
7348   62CF FF FF FF FF 
7348   62D3 FF FF FF FF 
7348   62D7 FF FF FF FF 
7348   62DB FF FF FF FF 
7348   62DF FF FF FF FF 
7348   62E3 FF FF FF FF 
7348   62E7 FF FF FF FF 
7348   62EB FF FF FF FF 
7348   62EF FF FF FF FF 
7348   62F3 FF FF FF FF 
7348   62F7 FF FF FF FF 
7348   62FB FF FF FF FF 
7348   62FF FF FF FF FF 
7348   6303 FF FF FF FF 
7348   6307 FF FF FF FF 
7348   630B FF FF FF FF 
7348   630F FF FF FF FF 
7348   6313 FF FF FF FF 
7348   6317 FF FF FF FF 
7348   631B FF FF FF FF 
7348   631F FF FF FF FF 
7348   6323 FF FF FF FF 
7348   6327 FF FF FF FF 
7348   632B FF FF FF FF 
7348   632F FF FF FF FF 
7348   6333 FF FF FF FF 
7348   6337 FF FF FF FF 
7348   633B FF FF FF FF 
7348   633F FF FF FF FF 
7348   6343 FF FF FF FF 
7348   6347 FF FF FF FF 
7348   634B FF FF FF FF 
7348   634F FF FF FF FF 
7348   6353 FF FF FF FF 
7348   6357 FF FF FF FF 
7348   635B FF FF FF FF 
7348   635F FF FF FF FF 
7348   6363 FF FF FF FF 
7348   6367 FF FF FF FF 
7348   636B FF FF FF FF 
7348   636F FF FF FF FF 
7348   6373 FF FF FF FF 
7348   6377 FF FF FF FF 
7348   637B FF FF FF FF 
7348   637F FF FF FF FF 
7348   6383 FF FF FF FF 
7348   6387 FF FF FF FF 
7348   638B FF FF FF FF 
7348   638F FF FF FF FF 
7348   6393 FF FF FF FF 
7348   6397 FF FF FF FF 
7348   639B FF FF FF FF 
7348   639F FF FF FF FF 
7348   63A3 FF FF FF FF 
7348   63A7 FF FF FF FF 
7348   63AB FF FF FF FF 
7348   63AF FF FF FF FF 
7348   63B3 FF FF FF FF 
7348   63B7 FF FF FF FF 
7348   63BB FF FF FF FF 
7348   63BF FF FF FF FF 
7348   63C3 FF FF FF FF 
7348   63C7 FF FF FF FF 
7348   63CB FF FF FF FF 
7348   63CF FF FF FF FF 
7348   63D3 FF FF FF FF 
7348   63D7 FF FF FF FF 
7348   63DB FF FF FF FF 
7348   63DF FF FF FF FF 
7348   63E3 FF FF FF FF 
7348   63E7 FF FF FF FF 
7348   63EB FF FF FF FF 
7348   63EF FF FF FF FF 
7348   63F3 FF FF FF FF 
7348   63F7 FF FF FF FF 
7348   63FB FF FF FF FF 
7348   63FF FF FF FF FF 
7348   6403 FF FF FF FF 
7348   6407 FF FF FF FF 
7348   640B FF FF FF FF 
7348   640F FF FF FF FF 
7348   6413 FF FF FF FF 
7348   6417 FF FF FF FF 
7348   641B FF FF FF FF 
7348   641F FF FF FF FF 
7348   6423 FF FF FF FF 
7348   6427 FF FF FF FF 
7348   642B FF FF FF FF 
7348   642F FF FF FF FF 
7348   6433 FF FF FF FF 
7348   6437 FF FF FF FF 
7348   643B FF FF FF FF 
7348   643F FF FF FF FF 
7348   6443 FF FF FF FF 
7348   6447 FF FF FF FF 
7348   644B FF FF FF FF 
7348   644F FF FF FF FF 
7348   6453 FF FF FF FF 
7348   6457 FF FF FF FF 
7348   645B FF FF FF FF 
7348   645F FF FF FF FF 
7348   6463 FF FF FF FF 
7348   6467 FF FF FF FF 
7348   646B FF FF FF FF 
7348   646F FF FF FF FF 
7348   6473 FF FF FF FF 
7348   6477 FF FF FF FF 
7348   647B FF FF FF FF 
7348   647F FF FF FF FF 
7348   6483 FF FF FF FF 
7348   6487 FF FF FF FF 
7348   648B FF FF FF FF 
7348   648F FF FF FF FF 
7348   6493 FF FF FF FF 
7348   6497 FF FF FF FF 
7348   649B FF FF FF FF 
7348   649F FF FF FF FF 
7348   64A3 FF FF FF FF 
7348   64A7 FF FF FF FF 
7348   64AB FF FF FF FF 
7348   64AF FF FF FF FF 
7348   64B3 FF FF FF FF 
7348   64B7 FF FF FF FF 
7348   64BB FF FF FF FF 
7348   64BF FF FF FF FF 
7348   64C3 FF FF FF FF 
7348   64C7 FF FF FF FF 
7348   64CB FF FF FF FF 
7348   64CF FF FF FF FF 
7348   64D3 FF FF FF FF 
7348   64D7 FF FF FF FF 
7348   64DB FF FF FF FF 
7348   64DF FF FF FF FF 
7348   64E3 FF FF FF FF 
7348   64E7 FF FF FF FF 
7348   64EB FF FF FF FF 
7348   64EF FF FF FF FF 
7348   64F3 FF FF FF FF 
7348   64F7 FF FF FF FF 
7348   64FB FF FF FF FF 
7348   64FF FF FF FF FF 
7348   6503 FF FF FF FF 
7348   6507 FF FF FF FF 
7348   650B FF FF FF FF 
7348   650F FF FF FF FF 
7348   6513 FF FF FF FF 
7348   6517 FF FF FF FF 
7348   651B FF FF FF FF 
7348   651F FF FF FF FF 
7348   6523 FF FF FF FF 
7348   6527 FF FF FF FF 
7348   652B FF FF FF FF 
7348   652F FF FF FF FF 
7348   6533 FF FF FF FF 
7348   6537 FF FF FF FF 
7348   653B FF FF FF FF 
7348   653F FF FF FF FF 
7348   6543 FF FF FF FF 
7348   6547 FF FF FF FF 
7348   654B FF FF FF FF 
7348   654F FF FF FF FF 
7348   6553 FF FF FF FF 
7348   6557 FF FF FF FF 
7348   655B FF FF FF FF 
7348   655F FF FF FF FF 
7348   6563 FF FF FF FF 
7348   6567 FF FF FF FF 
7348   656B FF FF FF FF 
7348   656F FF FF FF FF 
7348   6573 FF FF FF FF 
7348   6577 FF FF FF FF 
7348   657B FF FF FF FF 
7348   657F FF FF FF FF 
7348   6583 FF FF FF FF 
7348   6587 FF FF FF FF 
7348   658B FF FF FF FF 
7348   658F FF FF FF FF 
7348   6593 FF FF FF FF 
7348   6597 FF FF FF FF 
7348   659B FF FF FF FF 
7348   659F FF FF FF FF 
7348   65A3 FF FF FF FF 
7348   65A7 FF FF FF FF 
7348   65AB FF FF FF FF 
7348   65AF FF FF FF FF 
7348   65B3 FF FF FF FF 
7348   65B7 FF FF FF FF 
7348   65BB FF FF FF FF 
7348   65BF FF FF FF FF 
7348   65C3 FF FF FF FF 
7348   65C7 FF FF FF FF 
7348   65CB FF FF FF FF 
7348   65CF FF FF FF FF 
7348   65D3 FF FF FF FF 
7348   65D7 FF FF FF FF 
7348   65DB FF FF FF FF 
7348   65DF FF FF FF FF 
7348   65E3 FF FF FF FF 
7348   65E7 FF FF FF FF 
7348   65EB FF FF FF FF 
7348   65EF FF FF FF FF 
7348   65F3 FF FF FF FF 
7348   65F7 FF FF FF FF 
7348   65FB FF FF FF FF 
7348   65FF FF FF FF FF 
7348   6603 FF FF FF FF 
7348   6607 FF FF FF FF 
7348   660B FF FF FF FF 
7348   660F FF FF FF FF 
7348   6613 FF FF FF FF 
7348   6617 FF FF FF FF 
7348   661B FF FF FF FF 
7348   661F FF FF FF FF 
7348   6623 FF FF FF FF 
7348   6627 FF FF FF FF 
7348   662B FF FF FF FF 
7348   662F FF FF FF FF 
7348   6633 FF FF FF FF 
7348   6637 FF FF FF FF 
7348   663B FF FF FF FF 
7348   663F FF FF FF FF 
7348   6643 FF FF FF FF 
7348   6647 FF FF FF FF 
7348   664B FF FF FF FF 
7348   664F FF FF FF FF 
7348   6653 FF FF FF FF 
7348   6657 FF FF FF FF 
7348   665B FF FF FF FF 
7348   665F FF FF FF FF 
7348   6663 FF FF FF FF 
7348   6667 FF FF FF FF 
7348   666B FF FF FF FF 
7348   666F FF FF FF FF 
7348   6673 FF FF FF FF 
7348   6677 FF FF FF FF 
7348   667B FF FF FF FF 
7348   667F FF FF FF FF 
7348   6683 FF FF FF FF 
7348   6687 FF FF FF FF 
7348   668B FF FF FF FF 
7348   668F FF FF FF FF 
7348   6693 FF FF FF FF 
7348   6697 FF FF FF FF 
7348   669B FF FF FF FF 
7348   669F FF FF FF FF 
7348   66A3 FF FF FF FF 
7348   66A7 FF FF FF FF 
7348   66AB FF FF FF FF 
7348   66AF FF FF FF FF 
7348   66B3 FF FF FF FF 
7348   66B7 FF FF FF FF 
7348   66BB FF FF FF FF 
7348   66BF FF FF FF FF 
7348   66C3 FF FF FF FF 
7348   66C7 FF FF FF FF 
7348   66CB FF FF FF FF 
7348   66CF FF FF FF FF 
7348   66D3 FF FF FF FF 
7348   66D7 FF FF FF FF 
7348   66DB FF FF FF FF 
7348   66DF FF FF FF FF 
7348   66E3 FF FF FF FF 
7348   66E7 FF FF FF FF 
7348   66EB FF FF FF FF 
7348   66EF FF FF FF FF 
7348   66F3 FF FF FF FF 
7348   66F7 FF FF FF FF 
7348   66FB FF FF FF FF 
7348   66FF FF FF FF FF 
7348   6703 FF FF FF FF 
7348   6707 FF FF FF FF 
7348   670B FF FF FF FF 
7348   670F FF FF FF FF 
7348   6713 FF FF FF FF 
7348   6717 FF FF FF FF 
7348   671B FF FF FF FF 
7348   671F FF FF FF FF 
7348   6723 FF FF FF FF 
7348   6727 FF FF FF FF 
7348   672B FF FF FF FF 
7348   672F FF FF FF FF 
7348   6733 FF FF FF FF 
7348   6737 FF FF FF FF 
7348   673B FF FF FF FF 
7348   673F FF FF FF FF 
7348   6743 FF FF FF FF 
7348   6747 FF FF FF FF 
7348   674B FF FF FF FF 
7348   674F FF FF FF FF 
7348   6753 FF FF FF FF 
7348   6757 FF FF FF FF 
7348   675B FF FF FF FF 
7348   675F FF FF FF FF 
7348   6763 FF FF FF FF 
7348   6767 FF FF FF FF 
7348   676B FF FF FF FF 
7348   676F FF FF FF FF 
7348   6773 FF FF FF FF 
7348   6777 FF FF FF FF 
7348   677B FF FF FF FF 
7348   677F FF FF FF FF 
7348   6783 FF FF FF FF 
7348   6787 FF FF FF FF 
7348   678B FF FF FF FF 
7348   678F FF FF FF FF 
7348   6793 FF FF FF FF 
7348   6797 FF FF FF FF 
7348   679B FF FF FF FF 
7348   679F FF FF FF FF 
7348   67A3 FF FF FF FF 
7348   67A7 FF FF FF FF 
7348   67AB FF FF FF FF 
7348   67AF FF FF FF FF 
7348   67B3 FF FF FF FF 
7348   67B7 FF FF FF FF 
7348   67BB FF FF FF FF 
7348   67BF FF FF FF FF 
7348   67C3 FF FF FF FF 
7348   67C7 FF FF FF FF 
7348   67CB FF FF FF FF 
7348   67CF FF FF FF FF 
7348   67D3 FF FF FF FF 
7348   67D7 FF FF FF FF 
7348   67DB FF FF FF FF 
7348   67DF FF FF FF FF 
7348   67E3 FF FF FF FF 
7348   67E7 FF FF FF FF 
7348   67EB FF FF FF FF 
7348   67EF FF FF FF FF 
7348   67F3 FF FF FF FF 
7348   67F7 FF FF FF FF 
7348   67FB FF FF FF FF 
7348   67FF FF FF FF FF 
7348   6803 FF FF FF FF 
7348   6807 FF FF FF FF 
7348   680B FF FF FF FF 
7348   680F FF FF FF FF 
7348   6813 FF FF FF FF 
7348   6817 FF FF FF FF 
7348   681B FF FF FF FF 
7348   681F FF FF FF FF 
7348   6823 FF FF FF FF 
7348   6827 FF FF FF FF 
7348   682B FF FF FF FF 
7348   682F FF FF FF FF 
7348   6833 FF FF FF FF 
7348   6837 FF FF FF FF 
7348   683B FF FF FF FF 
7348   683F FF FF FF FF 
7348   6843 FF FF FF FF 
7348   6847 FF FF FF FF 
7348   684B FF FF FF FF 
7348   684F FF FF FF FF 
7348   6853 FF FF FF FF 
7348   6857 FF FF FF FF 
7348   685B FF FF FF FF 
7348   685F FF FF FF FF 
7348   6863 FF FF FF FF 
7348   6867 FF FF FF FF 
7348   686B FF FF FF FF 
7348   686F FF FF FF FF 
7348   6873 FF FF FF FF 
7348   6877 FF FF FF FF 
7348   687B FF FF FF FF 
7348   687F FF FF FF FF 
7348   6883 FF FF FF FF 
7348   6887 FF FF FF FF 
7348   688B FF FF FF FF 
7348   688F FF FF FF FF 
7348   6893 FF FF FF FF 
7348   6897 FF FF FF FF 
7348   689B FF FF FF FF 
7348   689F FF FF FF FF 
7348   68A3 FF FF FF FF 
7348   68A7 FF FF FF FF 
7348   68AB FF FF FF FF 
7348   68AF FF FF FF FF 
7348   68B3 FF FF FF FF 
7348   68B7 FF FF FF FF 
7348   68BB FF FF FF FF 
7348   68BF FF FF FF FF 
7348   68C3 FF FF FF FF 
7348   68C7 FF FF FF FF 
7348   68CB FF FF FF FF 
7348   68CF FF FF FF FF 
7348   68D3 FF FF FF FF 
7348   68D7 FF FF FF FF 
7348   68DB FF FF FF FF 
7348   68DF FF FF FF FF 
7348   68E3 FF FF FF FF 
7348   68E7 FF FF FF FF 
7348   68EB FF FF FF FF 
7348   68EF FF FF FF FF 
7348   68F3 FF FF FF FF 
7348   68F7 FF FF FF FF 
7348   68FB FF FF FF FF 
7348   68FF FF FF FF FF 
7348   6903 FF FF FF FF 
7348   6907 FF FF FF FF 
7348   690B FF FF FF FF 
7348   690F FF FF FF FF 
7348   6913 FF FF FF FF 
7348   6917 FF FF FF FF 
7348   691B FF FF FF FF 
7348   691F FF FF FF FF 
7348   6923 FF FF FF FF 
7348   6927 FF FF FF FF 
7348   692B FF FF FF FF 
7348   692F FF FF FF FF 
7348   6933 FF FF FF FF 
7348   6937 FF FF FF FF 
7348   693B FF FF FF FF 
7348   693F FF FF FF FF 
7348   6943 FF FF FF FF 
7348   6947 FF FF FF FF 
7348   694B FF FF FF FF 
7348   694F FF FF FF FF 
7348   6953 FF FF FF FF 
7348   6957 FF FF FF FF 
7348   695B FF FF FF FF 
7348   695F FF FF FF FF 
7348   6963 FF FF FF FF 
7348   6967 FF FF FF FF 
7348   696B FF FF FF FF 
7348   696F FF FF FF FF 
7348   6973 FF FF FF FF 
7348   6977 FF FF FF FF 
7348   697B FF FF FF FF 
7348   697F FF FF FF FF 
7348   6983 FF FF FF FF 
7348   6987 FF FF FF FF 
7348   698B FF FF FF FF 
7348   698F FF FF FF FF 
7348   6993 FF FF FF FF 
7348   6997 FF FF FF FF 
7348   699B FF FF FF FF 
7348   699F FF FF FF FF 
7348   69A3 FF FF FF FF 
7348   69A7 FF FF FF FF 
7348   69AB FF FF FF FF 
7348   69AF FF FF FF FF 
7348   69B3 FF FF FF FF 
7348   69B7 FF FF FF FF 
7348   69BB FF FF FF FF 
7348   69BF FF FF FF FF 
7348   69C3 FF FF FF FF 
7348   69C7 FF FF FF FF 
7348   69CB FF FF FF FF 
7348   69CF FF FF FF FF 
7348   69D3 FF FF FF FF 
7348   69D7 FF FF FF FF 
7348   69DB FF FF FF FF 
7348   69DF FF FF FF FF 
7348   69E3 FF FF FF FF 
7348   69E7 FF FF FF FF 
7348   69EB FF FF FF FF 
7348   69EF FF FF FF FF 
7348   69F3 FF FF FF FF 
7348   69F7 FF FF FF FF 
7348   69FB FF FF FF FF 
7348   69FF FF FF FF FF 
7348   6A03 FF FF FF FF 
7348   6A07 FF FF FF FF 
7348   6A0B FF FF FF FF 
7348   6A0F FF FF FF FF 
7348   6A13 FF FF FF FF 
7348   6A17 FF FF FF FF 
7348   6A1B FF FF FF FF 
7348   6A1F FF FF FF FF 
7348   6A23 FF FF FF FF 
7348   6A27 FF FF FF FF 
7348   6A2B FF FF FF FF 
7348   6A2F FF FF FF FF 
7348   6A33 FF FF FF FF 
7348   6A37 FF FF FF FF 
7348   6A3B FF FF FF FF 
7348   6A3F FF FF FF FF 
7348   6A43 FF FF FF FF 
7348   6A47 FF FF FF FF 
7348   6A4B FF FF FF FF 
7348   6A4F FF FF FF FF 
7348   6A53 FF FF FF FF 
7348   6A57 FF FF FF FF 
7348   6A5B FF FF FF FF 
7348   6A5F FF FF FF FF 
7348   6A63 FF FF FF FF 
7348   6A67 FF FF FF FF 
7348   6A6B FF FF FF FF 
7348   6A6F FF FF FF FF 
7348   6A73 FF FF FF FF 
7348   6A77 FF FF FF FF 
7348   6A7B FF FF FF FF 
7348   6A7F FF FF FF FF 
7348   6A83 FF FF FF FF 
7348   6A87 FF FF FF FF 
7348   6A8B FF FF FF FF 
7348   6A8F FF FF FF FF 
7348   6A93 FF FF FF FF 
7348   6A97 FF FF FF FF 
7348   6A9B FF FF FF FF 
7348   6A9F FF FF FF FF 
7348   6AA3 FF FF FF FF 
7348   6AA7 FF FF FF FF 
7348   6AAB FF FF FF FF 
7348   6AAF FF FF FF FF 
7348   6AB3 FF FF FF FF 
7348   6AB7 FF FF FF FF 
7348   6ABB FF FF FF FF 
7348   6ABF FF FF FF FF 
7348   6AC3 FF FF FF FF 
7348   6AC7 FF FF FF FF 
7348   6ACB FF FF FF FF 
7348   6ACF FF FF FF FF 
7348   6AD3 FF FF FF FF 
7348   6AD7 FF FF FF FF 
7348   6ADB FF FF FF FF 
7348   6ADF FF FF FF FF 
7348   6AE3 FF FF FF FF 
7348   6AE7 FF FF FF FF 
7348   6AEB FF FF FF FF 
7348   6AEF FF FF FF FF 
7348   6AF3 FF FF FF FF 
7348   6AF7 FF FF FF FF 
7348   6AFB FF FF FF FF 
7348   6AFF FF FF FF FF 
7348   6B03 FF FF FF FF 
7348   6B07 FF FF FF FF 
7348   6B0B FF FF FF FF 
7348   6B0F FF FF FF FF 
7348   6B13 FF FF FF FF 
7348   6B17 FF FF FF FF 
7348   6B1B FF FF FF FF 
7348   6B1F FF FF FF FF 
7348   6B23 FF FF FF FF 
7348   6B27 FF FF FF FF 
7348   6B2B FF FF FF FF 
7348   6B2F FF FF FF FF 
7348   6B33 FF FF FF FF 
7348   6B37 FF FF FF FF 
7348   6B3B FF FF FF FF 
7348   6B3F FF FF FF FF 
7348   6B43 FF FF FF FF 
7348   6B47 FF FF FF FF 
7348   6B4B FF FF FF FF 
7348   6B4F FF FF FF FF 
7348   6B53 FF FF FF FF 
7348   6B57 FF FF FF FF 
7348   6B5B FF FF FF FF 
7348   6B5F FF FF FF FF 
7348   6B63 FF FF FF FF 
7348   6B67 FF FF FF FF 
7348   6B6B FF FF FF FF 
7348   6B6F FF FF FF FF 
7348   6B73 FF FF FF FF 
7348   6B77 FF FF FF FF 
7348   6B7B FF FF FF FF 
7348   6B7F FF FF FF FF 
7348   6B83 FF FF FF FF 
7348   6B87 FF FF FF FF 
7348   6B8B FF FF FF FF 
7348   6B8F FF FF FF FF 
7348   6B93 FF FF FF FF 
7348   6B97 FF FF FF FF 
7348   6B9B FF FF FF FF 
7348   6B9F FF FF FF FF 
7348   6BA3 FF FF FF FF 
7348   6BA7 FF FF FF FF 
7348   6BAB FF FF FF FF 
7348   6BAF FF FF FF FF 
7348   6BB3 FF FF FF FF 
7348   6BB7 FF FF FF FF 
7348   6BBB FF FF FF FF 
7348   6BBF FF FF FF FF 
7348   6BC3 FF FF FF FF 
7348   6BC7 FF FF FF FF 
7348   6BCB FF FF FF FF 
7348   6BCF FF FF FF FF 
7348   6BD3 FF FF FF FF 
7348   6BD7 FF FF FF FF 
7348   6BDB FF FF FF FF 
7348   6BDF FF FF FF FF 
7348   6BE3 FF FF FF FF 
7348   6BE7 FF FF FF FF 
7348   6BEB FF FF FF FF 
7348   6BEF FF FF FF FF 
7348   6BF3 FF FF FF FF 
7348   6BF7 FF FF FF FF 
7348   6BFB FF FF FF FF 
7348   6BFF FF FF FF FF 
7348   6C03 FF FF FF FF 
7348   6C07 FF FF FF FF 
7348   6C0B FF FF FF FF 
7348   6C0F FF FF FF FF 
7348   6C13 FF FF FF FF 
7348   6C17 FF FF FF FF 
7348   6C1B FF FF FF FF 
7348   6C1F FF FF FF FF 
7348   6C23 FF FF FF FF 
7348   6C27 FF FF FF FF 
7348   6C2B FF FF FF FF 
7348   6C2F FF FF FF FF 
7348   6C33 FF FF FF FF 
7348   6C37 FF FF FF FF 
7348   6C3B FF FF FF FF 
7348   6C3F FF FF FF FF 
7348   6C43 FF FF FF FF 
7348   6C47 FF FF FF FF 
7348   6C4B FF FF FF FF 
7348   6C4F FF FF FF FF 
7348   6C53 FF FF FF FF 
7348   6C57 FF FF FF FF 
7348   6C5B FF FF FF FF 
7348   6C5F FF FF FF FF 
7348   6C63 FF FF FF FF 
7348   6C67 FF FF FF FF 
7348   6C6B FF FF FF FF 
7348   6C6F FF FF FF FF 
7348   6C73 FF FF FF FF 
7348   6C77 FF FF FF FF 
7348   6C7B FF FF FF FF 
7348   6C7F FF FF FF FF 
7348   6C83 FF FF FF FF 
7348   6C87 FF FF FF FF 
7348   6C8B FF FF FF FF 
7348   6C8F FF FF FF FF 
7348   6C93 FF FF FF FF 
7348   6C97 FF FF FF FF 
7348   6C9B FF FF FF FF 
7348   6C9F FF FF FF FF 
7348   6CA3 FF FF FF FF 
7348   6CA7 FF FF FF FF 
7348   6CAB FF FF FF FF 
7348   6CAF FF FF FF FF 
7348   6CB3 FF FF FF FF 
7348   6CB7 FF FF FF FF 
7348   6CBB FF FF FF FF 
7348   6CBF FF FF FF FF 
7348   6CC3 FF FF FF FF 
7348   6CC7 FF FF FF FF 
7348   6CCB FF FF FF FF 
7348   6CCF FF FF FF FF 
7348   6CD3 FF FF FF FF 
7348   6CD7 FF FF FF FF 
7348   6CDB FF FF FF FF 
7348   6CDF FF FF FF FF 
7348   6CE3 FF FF FF FF 
7348   6CE7 FF FF FF FF 
7348   6CEB FF FF FF FF 
7348   6CEF FF FF FF FF 
7348   6CF3 FF FF FF FF 
7348   6CF7 FF FF FF FF 
7348   6CFB FF FF FF FF 
7348   6CFF FF FF FF FF 
7348   6D03 FF FF FF FF 
7348   6D07 FF FF FF FF 
7348   6D0B FF FF FF FF 
7348   6D0F FF FF FF FF 
7348   6D13 FF FF FF FF 
7348   6D17 FF FF FF FF 
7348   6D1B FF FF FF FF 
7348   6D1F FF FF FF FF 
7348   6D23 FF FF FF FF 
7348   6D27 FF FF FF FF 
7348   6D2B FF FF FF FF 
7348   6D2F FF FF FF FF 
7348   6D33 FF FF FF FF 
7348   6D37 FF FF FF FF 
7348   6D3B FF FF FF FF 
7348   6D3F FF FF FF FF 
7348   6D43 FF FF FF FF 
7348   6D47 FF FF FF FF 
7348   6D4B FF FF FF FF 
7348   6D4F FF FF FF FF 
7348   6D53 FF FF FF FF 
7348   6D57 FF FF FF FF 
7348   6D5B FF FF FF FF 
7348   6D5F FF FF FF FF 
7348   6D63 FF FF FF FF 
7348   6D67 FF FF FF FF 
7348   6D6B FF FF FF FF 
7348   6D6F FF FF FF FF 
7348   6D73 FF FF FF FF 
7348   6D77 FF FF FF FF 
7348   6D7B FF FF FF FF 
7348   6D7F FF FF FF FF 
7348   6D83 FF FF FF FF 
7348   6D87 FF FF FF FF 
7348   6D8B FF FF FF FF 
7348   6D8F FF FF FF FF 
7348   6D93 FF FF FF FF 
7348   6D97 FF FF FF FF 
7348   6D9B FF FF FF FF 
7348   6D9F FF FF FF FF 
7348   6DA3 FF FF FF FF 
7348   6DA7 FF FF FF FF 
7348   6DAB FF FF FF FF 
7348   6DAF FF FF FF FF 
7348   6DB3 FF FF FF FF 
7348   6DB7 FF FF FF FF 
7348   6DBB FF FF FF FF 
7348   6DBF FF FF FF FF 
7348   6DC3 FF FF FF FF 
7348   6DC7 FF FF FF FF 
7348   6DCB FF FF FF FF 
7348   6DCF FF FF FF FF 
7348   6DD3 FF FF FF FF 
7348   6DD7 FF FF FF FF 
7348   6DDB FF FF FF FF 
7348   6DDF FF FF FF FF 
7348   6DE3 FF FF FF FF 
7348   6DE7 FF FF FF FF 
7348   6DEB FF FF FF FF 
7348   6DEF FF FF FF FF 
7348   6DF3 FF FF FF FF 
7348   6DF7 FF FF FF FF 
7348   6DFB FF FF FF FF 
7348   6DFF FF FF FF FF 
7348   6E03 FF FF FF FF 
7348   6E07 FF FF FF FF 
7348   6E0B FF FF FF FF 
7348   6E0F FF FF FF FF 
7348   6E13 FF FF FF FF 
7348   6E17 FF FF FF FF 
7348   6E1B FF FF FF FF 
7348   6E1F FF FF FF FF 
7348   6E23 FF FF FF FF 
7348   6E27 FF FF FF FF 
7348   6E2B FF FF FF FF 
7348   6E2F FF FF FF FF 
7348   6E33 FF FF FF FF 
7348   6E37 FF FF FF FF 
7348   6E3B FF FF FF FF 
7348   6E3F FF FF FF FF 
7348   6E43 FF FF FF FF 
7348   6E47 FF FF FF FF 
7348   6E4B FF FF FF FF 
7348   6E4F FF FF FF FF 
7348   6E53 FF FF FF FF 
7348   6E57 FF FF FF FF 
7348   6E5B FF FF FF FF 
7348   6E5F FF FF FF FF 
7348   6E63 FF FF FF FF 
7348   6E67 FF FF FF FF 
7348   6E6B FF FF FF FF 
7348   6E6F FF FF FF FF 
7348   6E73 FF FF FF FF 
7348   6E77 FF FF FF FF 
7348   6E7B FF FF FF FF 
7348   6E7F FF FF FF FF 
7348   6E83 FF FF FF FF 
7348   6E87 FF FF FF FF 
7348   6E8B FF FF FF FF 
7348   6E8F FF FF FF FF 
7348   6E93 FF FF FF FF 
7348   6E97 FF FF FF FF 
7348   6E9B FF FF FF FF 
7348   6E9F FF FF FF FF 
7348   6EA3 FF FF FF FF 
7348   6EA7 FF FF FF FF 
7348   6EAB FF FF FF FF 
7348   6EAF FF FF FF FF 
7348   6EB3 FF FF FF FF 
7348   6EB7 FF FF FF FF 
7348   6EBB FF FF FF FF 
7348   6EBF FF FF FF FF 
7348   6EC3 FF FF FF FF 
7348   6EC7 FF FF FF FF 
7348   6ECB FF FF FF FF 
7348   6ECF FF FF FF FF 
7348   6ED3 FF FF FF FF 
7348   6ED7 FF FF FF FF 
7348   6EDB FF FF FF FF 
7348   6EDF FF FF FF FF 
7348   6EE3 FF FF FF FF 
7348   6EE7 FF FF FF FF 
7348   6EEB FF FF FF FF 
7348   6EEF FF FF FF FF 
7348   6EF3 FF FF FF FF 
7348   6EF7 FF FF FF FF 
7348   6EFB FF FF FF FF 
7348   6EFF FF FF FF FF 
7348   6F03 FF FF FF FF 
7348   6F07 FF FF FF FF 
7348   6F0B FF FF FF FF 
7348   6F0F FF FF FF FF 
7348   6F13 FF FF FF FF 
7348   6F17 FF FF FF FF 
7348   6F1B FF FF FF FF 
7348   6F1F FF FF FF FF 
7348   6F23 FF FF FF FF 
7348   6F27 FF FF FF FF 
7348   6F2B FF FF FF FF 
7348   6F2F FF FF FF FF 
7348   6F33 FF FF FF FF 
7348   6F37 FF FF FF FF 
7348   6F3B FF FF FF FF 
7348   6F3F FF FF FF FF 
7348   6F43 FF FF FF FF 
7348   6F47 FF FF FF FF 
7348   6F4B FF FF FF FF 
7348   6F4F FF FF FF FF 
7348   6F53 FF FF FF FF 
7348   6F57 FF FF FF FF 
7348   6F5B FF FF FF FF 
7348   6F5F FF FF FF FF 
7348   6F63 FF FF FF FF 
7348   6F67 FF FF FF FF 
7348   6F6B FF FF FF FF 
7348   6F6F FF FF FF FF 
7348   6F73 FF FF FF FF 
7348   6F77 FF FF FF FF 
7348   6F7B FF FF FF FF 
7348   6F7F FF FF FF FF 
7348   6F83 FF FF FF FF 
7348   6F87 FF FF FF FF 
7348   6F8B FF FF FF FF 
7348   6F8F FF FF FF FF 
7348   6F93 FF FF FF FF 
7348   6F97 FF FF FF FF 
7348   6F9B FF FF FF FF 
7348   6F9F FF FF FF FF 
7348   6FA3 FF FF FF FF 
7348   6FA7 FF FF FF FF 
7348   6FAB FF FF FF FF 
7348   6FAF FF FF FF FF 
7348   6FB3 FF FF FF FF 
7348   6FB7 FF FF FF FF 
7348   6FBB FF FF FF FF 
7348   6FBF FF FF FF FF 
7348   6FC3 FF FF FF FF 
7348   6FC7 FF FF FF FF 
7348   6FCB FF FF FF FF 
7348   6FCF FF FF FF FF 
7348   6FD3 FF FF FF FF 
7348   6FD7 FF FF FF FF 
7348   6FDB FF FF FF FF 
7348   6FDF FF FF FF FF 
7348   6FE3 FF FF FF FF 
7348   6FE7 FF FF FF FF 
7348   6FEB FF FF FF FF 
7348   6FEF FF FF FF FF 
7348   6FF3 FF FF FF FF 
7348   6FF7 FF FF FF FF 
7348   6FFB FF FF FF FF 
7348   6FFF FF FF FF FF 
7348   7003 FF FF FF FF 
7348   7007 FF FF FF FF 
7348   700B FF FF FF FF 
7348   700F FF FF FF FF 
7348   7013 FF FF FF FF 
7348   7017 FF FF FF FF 
7348   701B FF FF FF FF 
7348   701F FF FF FF FF 
7348   7023 FF FF FF FF 
7348   7027 FF FF FF FF 
7348   702B FF FF FF FF 
7348   702F FF FF FF FF 
7348   7033 FF FF FF FF 
7348   7037 FF FF FF FF 
7348   703B FF FF FF FF 
7348   703F FF FF FF FF 
7348   7043 FF FF FF FF 
7348   7047 FF FF FF FF 
7348   704B FF FF FF FF 
7348   704F FF FF FF FF 
7348   7053 FF FF FF FF 
7348   7057 FF FF FF FF 
7348   705B FF FF FF FF 
7348   705F FF FF FF FF 
7348   7063 FF FF FF FF 
7348   7067 FF FF FF FF 
7348   706B FF FF FF FF 
7348   706F FF FF FF FF 
7348   7073 FF FF FF FF 
7348   7077 FF FF FF FF 
7348   707B FF FF FF FF 
7348   707F FF FF FF FF 
7348   7083 FF FF FF FF 
7348   7087 FF FF FF FF 
7348   708B FF FF FF FF 
7348   708F FF FF FF FF 
7348   7093 FF FF FF FF 
7348   7097 FF FF FF FF 
7348   709B FF FF FF FF 
7348   709F FF FF FF FF 
7348   70A3 FF FF FF FF 
7348   70A7 FF FF FF FF 
7348   70AB FF FF FF FF 
7348   70AF FF FF FF FF 
7348   70B3 FF FF FF FF 
7348   70B7 FF FF FF FF 
7348   70BB FF FF FF FF 
7348   70BF FF FF FF FF 
7348   70C3 FF FF FF FF 
7348   70C7 FF FF FF FF 
7348   70CB FF FF FF FF 
7348   70CF FF FF FF FF 
7348   70D3 FF FF FF FF 
7348   70D7 FF FF FF FF 
7348   70DB FF FF FF FF 
7348   70DF FF FF FF FF 
7348   70E3 FF FF FF FF 
7348   70E7 FF FF FF FF 
7348   70EB FF FF FF FF 
7348   70EF FF FF FF FF 
7348   70F3 FF FF FF FF 
7348   70F7 FF FF FF FF 
7348   70FB FF FF FF FF 
7348   70FF FF FF FF FF 
7348   7103 FF FF FF FF 
7348   7107 FF FF FF FF 
7348   710B FF FF FF FF 
7348   710F FF FF FF FF 
7348   7113 FF FF FF FF 
7348   7117 FF FF FF FF 
7348   711B FF FF FF FF 
7348   711F FF FF FF FF 
7348   7123 FF FF FF FF 
7348   7127 FF FF FF FF 
7348   712B FF FF FF FF 
7348   712F FF FF FF FF 
7348   7133 FF FF FF FF 
7348   7137 FF FF FF FF 
7348   713B FF FF FF FF 
7348   713F FF FF FF FF 
7348   7143 FF FF FF FF 
7348   7147 FF FF FF FF 
7348   714B FF FF FF FF 
7348   714F FF FF FF FF 
7348   7153 FF FF FF FF 
7348   7157 FF FF FF FF 
7348   715B FF FF FF FF 
7348   715F FF FF FF FF 
7348   7163 FF FF FF FF 
7348   7167 FF FF FF FF 
7348   716B FF FF FF FF 
7348   716F FF FF FF FF 
7348   7173 FF FF FF FF 
7348   7177 FF FF FF FF 
7348   717B FF FF FF FF 
7348   717F FF FF FF FF 
7348   7183 FF FF FF FF 
7348   7187 FF FF FF FF 
7348   718B FF FF FF FF 
7348   718F FF FF FF FF 
7348   7193 FF FF FF FF 
7348   7197 FF FF FF FF 
7348   719B FF FF FF FF 
7348   719F FF FF FF FF 
7348   71A3 FF FF FF FF 
7348   71A7 FF FF FF FF 
7348   71AB FF FF FF FF 
7348   71AF FF FF FF FF 
7348   71B3 FF FF FF FF 
7348   71B7 FF FF FF FF 
7348   71BB FF FF FF FF 
7348   71BF FF FF FF FF 
7348   71C3 FF FF FF FF 
7348   71C7 FF FF FF FF 
7348   71CB FF FF FF FF 
7348   71CF FF FF FF FF 
7348   71D3 FF FF FF FF 
7348   71D7 FF FF FF FF 
7348   71DB FF FF FF FF 
7348   71DF FF FF FF FF 
7348   71E3 FF FF FF FF 
7348   71E7 FF FF FF FF 
7348   71EB FF FF FF FF 
7348   71EF FF FF FF FF 
7348   71F3 FF FF FF FF 
7348   71F7 FF FF FF FF 
7348   71FB FF FF FF FF 
7348   71FF FF FF FF FF 
7348   7203 FF FF FF FF 
7348   7207 FF FF FF FF 
7348   720B FF FF FF FF 
7348   720F FF FF FF FF 
7348   7213 FF FF FF FF 
7348   7217 FF FF FF FF 
7348   721B FF FF FF FF 
7348   721F FF FF FF FF 
7348   7223 FF FF FF FF 
7348   7227 FF FF FF FF 
7348   722B FF FF FF FF 
7348   722F FF FF FF FF 
7348   7233 FF FF FF FF 
7348   7237 FF FF FF FF 
7348   723B FF FF FF FF 
7348   723F FF FF FF FF 
7348   7243 FF FF FF FF 
7348   7247 FF FF FF FF 
7348   724B FF FF FF FF 
7348   724F FF FF FF FF 
7348   7253 FF FF FF FF 
7348   7257 FF FF FF FF 
7348   725B FF FF FF FF 
7348   725F FF FF FF FF 
7348   7263 FF FF FF FF 
7348   7267 FF FF FF FF 
7348   726B FF FF FF FF 
7348   726F FF FF FF FF 
7348   7273 FF FF FF FF 
7348   7277 FF FF FF FF 
7348   727B FF FF FF FF 
7348   727F FF FF FF FF 
7348   7283 FF FF FF FF 
7348   7287 FF FF FF FF 
7348   728B FF FF FF FF 
7348   728F FF FF FF FF 
7348   7293 FF FF FF FF 
7348   7297 FF FF FF FF 
7348   729B FF FF FF FF 
7348   729F FF FF FF FF 
7348   72A3 FF FF FF FF 
7348   72A7 FF FF FF FF 
7348   72AB FF FF FF FF 
7348   72AF FF FF FF FF 
7348   72B3 FF FF FF FF 
7348   72B7 FF FF FF FF 
7348   72BB FF FF FF FF 
7348   72BF FF FF FF FF 
7348   72C3 FF FF FF FF 
7348   72C7 FF FF FF FF 
7348   72CB FF FF FF FF 
7348   72CF FF FF FF FF 
7348   72D3 FF FF FF FF 
7348   72D7 FF FF FF FF 
7348   72DB FF FF FF FF 
7348   72DF FF FF FF FF 
7348   72E3 FF FF FF FF 
7348   72E7 FF FF FF FF 
7348   72EB FF FF FF FF 
7348   72EF FF FF FF FF 
7348   72F3 FF FF FF FF 
7348   72F7 FF FF FF FF 
7348   72FB FF FF FF FF 
7348   72FF FF FF FF FF 
7348   7303 FF FF FF FF 
7348   7307 FF FF FF FF 
7348   730B FF FF FF FF 
7348   730F FF FF FF FF 
7348   7313 FF FF FF FF 
7348   7317 FF FF FF FF 
7348   731B FF FF FF FF 
7348   731F FF FF FF FF 
7348   7323 FF FF FF FF 
7348   7327 FF FF FF FF 
7348   732B FF FF FF FF 
7348   732F FF FF FF FF 
7348   7333 FF FF FF FF 
7348   7337 FF FF FF FF 
7348   733B FF FF FF FF 
7348   733F FF FF FF FF 
7348   7343 FF FF FF FF 
7348   7347 FF FF FF FF 
7348   734B FF FF FF FF 
7348   734F FF FF FF FF 
7348   7353 FF FF FF FF 
7348   7357 FF FF FF FF 
7348   735B FF FF FF FF 
7348   735F FF FF FF FF 
7348   7363 FF FF FF FF 
7348   7367 FF FF FF FF 
7348   736B FF FF FF FF 
7348   736F FF FF FF FF 
7348   7373 FF FF FF FF 
7348   7377 FF FF FF FF 
7348   737B FF FF FF FF 
7348   737F FF FF FF FF 
7348   7383 FF FF FF FF 
7348   7387 FF FF FF FF 
7348   738B FF FF FF FF 
7348   738F FF FF FF FF 
7348   7393 FF FF FF FF 
7348   7397 FF FF FF FF 
7348   739B FF FF FF FF 
7348   739F FF FF FF FF 
7348   73A3 FF FF FF FF 
7348   73A7 FF FF FF FF 
7348   73AB FF FF FF FF 
7348   73AF FF FF FF FF 
7348   73B3 FF FF FF FF 
7348   73B7 FF FF FF FF 
7348   73BB FF FF FF FF 
7348   73BF FF FF FF FF 
7348   73C3 FF FF FF FF 
7348   73C7 FF FF FF FF 
7348   73CB FF FF FF FF 
7348   73CF FF FF FF FF 
7348   73D3 FF FF FF FF 
7348   73D7 FF FF FF FF 
7348   73DB FF FF FF FF 
7348   73DF FF FF FF FF 
7348   73E3 FF FF FF FF 
7348   73E7 FF FF FF FF 
7348   73EB FF FF FF FF 
7348   73EF FF FF FF FF 
7348   73F3 FF FF FF FF 
7348   73F7 FF FF FF FF 
7348   73FB FF FF FF FF 
7348   73FF FF FF FF FF 
7348   7403 FF FF FF FF 
7348   7407 FF FF FF FF 
7348   740B FF FF FF FF 
7348   740F FF FF FF FF 
7348   7413 FF FF FF FF 
7348   7417 FF FF FF FF 
7348   741B FF FF FF FF 
7348   741F FF FF FF FF 
7348   7423 FF FF FF FF 
7348   7427 FF FF FF FF 
7348   742B FF FF FF FF 
7348   742F FF FF FF FF 
7348   7433 FF FF FF FF 
7348   7437 FF FF FF FF 
7348   743B FF FF FF FF 
7348   743F FF FF FF FF 
7348   7443 FF FF FF FF 
7348   7447 FF FF FF FF 
7348   744B FF FF FF FF 
7348   744F FF FF FF FF 
7348   7453 FF FF FF FF 
7348   7457 FF FF FF FF 
7348   745B FF FF FF FF 
7348   745F FF FF FF FF 
7348   7463 FF FF FF FF 
7348   7467 FF FF FF FF 
7348   746B FF FF FF FF 
7348   746F FF FF FF FF 
7348   7473 FF FF FF FF 
7348   7477 FF FF FF FF 
7348   747B FF FF FF FF 
7348   747F FF FF FF FF 
7348   7483 FF FF FF FF 
7348   7487 FF FF FF FF 
7348   748B FF FF FF FF 
7348   748F FF FF FF FF 
7348   7493 FF FF FF FF 
7348   7497 FF FF FF FF 
7348   749B FF FF FF FF 
7348   749F FF FF FF FF 
7348   74A3 FF FF FF FF 
7348   74A7 FF FF FF FF 
7348   74AB FF FF FF FF 
7348   74AF FF FF FF FF 
7348   74B3 FF FF FF FF 
7348   74B7 FF FF FF FF 
7348   74BB FF FF FF FF 
7348   74BF FF FF FF FF 
7348   74C3 FF FF FF FF 
7348   74C7 FF FF FF FF 
7348   74CB FF FF FF FF 
7348   74CF FF FF FF FF 
7348   74D3 FF FF FF FF 
7348   74D7 FF FF FF FF 
7348   74DB FF FF FF FF 
7348   74DF FF FF FF FF 
7348   74E3 FF FF FF FF 
7348   74E7 FF FF FF FF 
7348   74EB FF FF FF FF 
7348   74EF FF FF FF FF 
7348   74F3 FF FF FF FF 
7348   74F7 FF FF FF FF 
7348   74FB FF FF FF FF 
7348   74FF FF FF FF FF 
7348   7503 FF FF FF FF 
7348   7507 FF FF FF FF 
7348   750B FF FF FF FF 
7348   750F FF FF FF FF 
7348   7513 FF FF FF FF 
7348   7517 FF FF FF FF 
7348   751B FF FF FF FF 
7348   751F FF FF FF FF 
7348   7523 FF FF FF FF 
7348   7527 FF FF FF FF 
7348   752B FF FF FF FF 
7348   752F FF FF FF FF 
7348   7533 FF FF FF FF 
7348   7537 FF FF FF FF 
7348   753B FF FF FF FF 
7348   753F FF FF FF FF 
7348   7543 FF FF FF FF 
7348   7547 FF FF FF FF 
7348   754B FF FF FF FF 
7348   754F FF FF FF FF 
7348   7553 FF FF FF FF 
7348   7557 FF FF FF FF 
7348   755B FF FF FF FF 
7348   755F FF FF FF FF 
7348   7563 FF FF FF FF 
7348   7567 FF FF FF FF 
7348   756B FF FF FF FF 
7348   756F FF FF FF FF 
7348   7573 FF FF FF FF 
7348   7577 FF FF FF FF 
7348   757B FF FF FF FF 
7348   757F FF FF FF FF 
7348   7583 FF FF FF FF 
7348   7587 FF FF FF FF 
7348   758B FF FF FF FF 
7348   758F FF FF FF FF 
7348   7593 FF FF FF FF 
7348   7597 FF FF FF FF 
7348   759B FF FF FF FF 
7348   759F FF FF FF FF 
7348   75A3 FF FF FF FF 
7348   75A7 FF FF FF FF 
7348   75AB FF FF FF FF 
7348   75AF FF FF FF FF 
7348   75B3 FF FF FF FF 
7348   75B7 FF FF FF FF 
7348   75BB FF FF FF FF 
7348   75BF FF FF FF FF 
7348   75C3 FF FF FF FF 
7348   75C7 FF FF FF FF 
7348   75CB FF FF FF FF 
7348   75CF FF FF FF FF 
7348   75D3 FF FF FF FF 
7348   75D7 FF FF FF FF 
7348   75DB FF FF FF FF 
7348   75DF FF FF FF FF 
7348   75E3 FF FF FF FF 
7348   75E7 FF FF FF FF 
7348   75EB FF FF FF FF 
7348   75EF FF FF FF FF 
7348   75F3 FF FF FF FF 
7348   75F7 FF FF FF FF 
7348   75FB FF FF FF FF 
7348   75FF FF FF FF FF 
7348   7603 FF FF FF FF 
7348   7607 FF FF FF FF 
7348   760B FF FF FF FF 
7348   760F FF FF FF FF 
7348   7613 FF FF FF FF 
7348   7617 FF FF FF FF 
7348   761B FF FF FF FF 
7348   761F FF FF FF FF 
7348   7623 FF FF FF FF 
7348   7627 FF FF FF FF 
7348   762B FF FF FF FF 
7348   762F FF FF FF FF 
7348   7633 FF FF FF FF 
7348   7637 FF FF FF FF 
7348   763B FF FF FF FF 
7348   763F FF FF FF FF 
7348   7643 FF FF FF FF 
7348   7647 FF FF FF FF 
7348   764B FF FF FF FF 
7348   764F FF FF FF FF 
7348   7653 FF FF FF FF 
7348   7657 FF FF FF FF 
7348   765B FF FF FF FF 
7348   765F FF FF FF FF 
7348   7663 FF FF FF FF 
7348   7667 FF FF FF FF 
7348   766B FF FF FF FF 
7348   766F FF FF FF FF 
7348   7673 FF FF FF FF 
7348   7677 FF FF FF FF 
7348   767B FF FF FF FF 
7348   767F FF FF FF FF 
7348   7683 FF FF FF FF 
7348   7687 FF FF FF FF 
7348   768B FF FF FF FF 
7348   768F FF FF FF FF 
7348   7693 FF FF FF FF 
7348   7697 FF FF FF FF 
7348   769B FF FF FF FF 
7348   769F FF FF FF FF 
7348   76A3 FF FF FF FF 
7348   76A7 FF FF FF FF 
7348   76AB FF FF FF FF 
7348   76AF FF FF FF FF 
7348   76B3 FF FF FF FF 
7348   76B7 FF FF FF FF 
7348   76BB FF FF FF FF 
7348   76BF FF FF FF FF 
7348   76C3 FF FF FF FF 
7348   76C7 FF FF FF FF 
7348   76CB FF FF FF FF 
7348   76CF FF FF FF FF 
7348   76D3 FF FF FF FF 
7348   76D7 FF FF FF FF 
7348   76DB FF FF FF FF 
7348   76DF FF FF FF FF 
7348   76E3 FF FF FF FF 
7348   76E7 FF FF FF FF 
7348   76EB FF FF FF FF 
7348   76EF FF FF FF FF 
7348   76F3 FF FF FF FF 
7348   76F7 FF FF FF FF 
7348   76FB FF FF FF FF 
7348   76FF FF FF FF FF 
7348   7703 FF FF FF FF 
7348   7707 FF FF FF FF 
7348   770B FF FF FF FF 
7348   770F FF FF FF FF 
7348   7713 FF FF FF FF 
7348   7717 FF FF FF FF 
7348   771B FF FF FF FF 
7348   771F FF FF FF FF 
7348   7723 FF FF FF FF 
7348   7727 FF FF FF FF 
7348   772B FF FF FF FF 
7348   772F FF FF FF FF 
7348   7733 FF FF FF FF 
7348   7737 FF FF FF FF 
7348   773B FF FF FF FF 
7348   773F FF FF FF FF 
7348   7743 FF FF FF FF 
7348   7747 FF FF FF FF 
7348   774B FF FF FF FF 
7348   774F FF FF FF FF 
7348   7753 FF FF FF FF 
7348   7757 FF FF FF FF 
7348   775B FF FF FF FF 
7348   775F FF FF FF FF 
7348   7763 FF FF FF FF 
7348   7767 FF FF FF FF 
7348   776B FF FF FF FF 
7348   776F FF FF FF FF 
7348   7773 FF FF FF FF 
7348   7777 FF FF FF FF 
7348   777B FF FF FF FF 
7348   777F FF FF FF FF 
7348   7783 FF FF FF FF 
7348   7787 FF FF FF FF 
7348   778B FF FF FF FF 
7348   778F FF FF FF FF 
7348   7793 FF FF FF FF 
7348   7797 FF FF FF FF 
7348   779B FF FF FF FF 
7348   779F FF FF FF FF 
7348   77A3 FF FF FF FF 
7348   77A7 FF FF FF FF 
7348   77AB FF FF FF FF 
7348   77AF FF FF FF FF 
7348   77B3 FF FF FF FF 
7348   77B7 FF FF FF FF 
7348   77BB FF FF FF FF 
7348   77BF FF FF FF FF 
7348   77C3 FF FF FF FF 
7348   77C7 FF FF FF FF 
7348   77CB FF FF FF FF 
7348   77CF FF FF FF FF 
7348   77D3 FF FF FF FF 
7348   77D7 FF FF FF FF 
7348   77DB FF FF FF FF 
7348   77DF FF FF FF FF 
7348   77E3 FF FF FF FF 
7348   77E7 FF FF FF FF 
7348   77EB FF FF FF FF 
7348   77EF FF FF FF FF 
7348   77F3 FF FF FF FF 
7348   77F7 FF FF FF FF 
7348   77FB FF FF FF FF 
7348   77FF FF FF FF FF 
7348   7803 FF FF FF FF 
7348   7807 FF FF FF FF 
7348   780B FF FF FF FF 
7348   780F FF FF FF FF 
7348   7813 FF FF FF FF 
7348   7817 FF FF FF FF 
7348   781B FF FF FF FF 
7348   781F FF FF FF FF 
7348   7823 FF FF FF FF 
7348   7827 FF FF FF FF 
7348   782B FF FF FF FF 
7348   782F FF FF FF FF 
7348   7833 FF FF FF FF 
7348   7837 FF FF FF FF 
7348   783B FF FF FF FF 
7348   783F FF FF FF FF 
7348   7843 FF FF FF FF 
7348   7847 FF FF FF FF 
7348   784B FF FF FF FF 
7348   784F FF FF FF FF 
7348   7853 FF FF FF FF 
7348   7857 FF FF FF FF 
7348   785B FF FF FF FF 
7348   785F FF FF FF FF 
7348   7863 FF FF FF FF 
7348   7867 FF FF FF FF 
7348   786B FF FF FF FF 
7348   786F FF FF FF FF 
7348   7873 FF FF FF FF 
7348   7877 FF FF FF FF 
7348   787B FF FF FF FF 
7348   787F FF FF FF FF 
7348   7883 FF FF FF FF 
7348   7887 FF FF FF FF 
7348   788B FF FF FF FF 
7348   788F FF FF FF FF 
7348   7893 FF FF FF FF 
7348   7897 FF FF FF FF 
7348   789B FF FF FF FF 
7348   789F FF FF FF FF 
7348   78A3 FF FF FF FF 
7348   78A7 FF FF FF FF 
7348   78AB FF FF FF FF 
7348   78AF FF FF FF FF 
7348   78B3 FF FF FF FF 
7348   78B7 FF FF FF FF 
7348   78BB FF FF FF FF 
7348   78BF FF FF FF FF 
7348   78C3 FF FF FF FF 
7348   78C7 FF FF FF FF 
7348   78CB FF FF FF FF 
7348   78CF FF FF FF FF 
7348   78D3 FF FF FF FF 
7348   78D7 FF FF FF FF 
7348   78DB FF FF FF FF 
7348   78DF FF FF FF FF 
7348   78E3 FF FF FF FF 
7348   78E7 FF FF FF FF 
7348   78EB FF FF FF FF 
7348   78EF FF FF FF FF 
7348   78F3 FF FF FF FF 
7348   78F7 FF FF FF FF 
7348   78FB FF FF FF FF 
7348   78FF FF FF FF FF 
7348   7903 FF FF FF FF 
7348   7907 FF FF FF FF 
7348   790B FF FF FF FF 
7348   790F FF FF FF FF 
7348   7913 FF FF FF FF 
7348   7917 FF FF FF FF 
7348   791B FF FF FF FF 
7348   791F FF FF FF FF 
7348   7923 FF FF FF FF 
7348   7927 FF FF FF FF 
7348   792B FF FF FF FF 
7348   792F FF FF FF FF 
7348   7933 FF FF FF FF 
7348   7937 FF FF FF FF 
7348   793B FF FF FF FF 
7348   793F FF FF FF FF 
7348   7943 FF FF FF FF 
7348   7947 FF FF FF FF 
7348   794B FF FF FF FF 
7348   794F FF FF FF FF 
7348   7953 FF FF FF FF 
7348   7957 FF FF FF FF 
7348   795B FF FF FF FF 
7348   795F FF FF FF FF 
7348   7963 FF FF FF FF 
7348   7967 FF FF FF FF 
7348   796B FF FF FF FF 
7348   796F FF FF FF FF 
7348   7973 FF FF FF FF 
7348   7977 FF FF FF FF 
7348   797B FF FF FF FF 
7348   797F FF FF FF FF 
7348   7983 FF FF FF FF 
7348   7987 FF FF FF FF 
7348   798B FF FF FF FF 
7348   798F FF FF FF FF 
7348   7993 FF FF FF FF 
7348   7997 FF FF FF FF 
7348   799B FF FF FF FF 
7348   799F FF FF FF FF 
7348   79A3 FF FF FF FF 
7348   79A7 FF FF FF FF 
7348   79AB FF FF FF FF 
7348   79AF FF FF FF FF 
7348   79B3 FF FF FF FF 
7348   79B7 FF FF FF FF 
7348   79BB FF FF FF FF 
7348   79BF FF FF FF FF 
7348   79C3 FF FF FF FF 
7348   79C7 FF FF FF FF 
7348   79CB FF FF FF FF 
7348   79CF FF FF FF FF 
7348   79D3 FF FF FF FF 
7348   79D7 FF FF FF FF 
7348   79DB FF FF FF FF 
7348   79DF FF FF FF FF 
7348   79E3 FF FF FF FF 
7348   79E7 FF FF FF FF 
7348   79EB FF FF FF FF 
7348   79EF FF FF FF FF 
7348   79F3 FF FF FF FF 
7348   79F7 FF FF FF FF 
7348   79FB FF FF FF FF 
7348   79FF FF FF FF FF 
7348   7A03 FF FF FF FF 
7348   7A07 FF FF FF FF 
7348   7A0B FF FF FF FF 
7348   7A0F FF FF FF FF 
7348   7A13 FF FF FF FF 
7348   7A17 FF FF FF FF 
7348   7A1B FF FF FF FF 
7348   7A1F FF FF FF FF 
7348   7A23 FF FF FF FF 
7348   7A27 FF FF FF FF 
7348   7A2B FF FF FF FF 
7348   7A2F FF FF FF FF 
7348   7A33 FF FF FF FF 
7348   7A37 FF FF FF FF 
7348   7A3B FF FF FF FF 
7348   7A3F FF FF FF FF 
7348   7A43 FF FF FF FF 
7348   7A47 FF FF FF FF 
7348   7A4B FF FF FF FF 
7348   7A4F FF FF FF FF 
7348   7A53 FF FF FF FF 
7348   7A57 FF FF FF FF 
7348   7A5B FF FF FF FF 
7348   7A5F FF FF FF FF 
7348   7A63 FF FF FF FF 
7348   7A67 FF FF FF FF 
7348   7A6B FF FF FF FF 
7348   7A6F FF FF FF FF 
7348   7A73 FF FF FF FF 
7348   7A77 FF FF FF FF 
7348   7A7B FF FF FF FF 
7348   7A7F FF FF FF FF 
7348   7A83 FF FF FF FF 
7348   7A87 FF FF FF FF 
7348   7A8B FF FF FF FF 
7348   7A8F FF FF FF FF 
7348   7A93 FF FF FF FF 
7348   7A97 FF FF FF FF 
7348   7A9B FF FF FF FF 
7348   7A9F FF FF FF FF 
7348   7AA3 FF FF FF FF 
7348   7AA7 FF FF FF FF 
7348   7AAB FF FF FF FF 
7348   7AAF FF FF FF FF 
7348   7AB3 FF FF FF FF 
7348   7AB7 FF FF FF FF 
7348   7ABB FF FF FF FF 
7348   7ABF FF FF FF FF 
7348   7AC3 FF FF FF FF 
7348   7AC7 FF FF FF FF 
7348   7ACB FF FF FF FF 
7348   7ACF FF FF FF FF 
7348   7AD3 FF FF FF FF 
7348   7AD7 FF FF FF FF 
7348   7ADB FF FF FF FF 
7348   7ADF FF FF FF FF 
7348   7AE3 FF FF FF FF 
7348   7AE7 FF FF FF FF 
7348   7AEB FF FF FF FF 
7348   7AEF FF FF FF FF 
7348   7AF3 FF FF FF FF 
7348   7AF7 FF FF FF FF 
7348   7AFB FF FF FF FF 
7348   7AFF FF FF FF FF 
7348   7B03 FF FF FF FF 
7348   7B07 FF FF FF FF 
7348   7B0B FF FF FF FF 
7348   7B0F FF FF FF FF 
7348   7B13 FF FF FF FF 
7348   7B17 FF FF FF FF 
7348   7B1B FF FF FF FF 
7348   7B1F FF FF FF FF 
7348   7B23 FF FF FF FF 
7348   7B27 FF FF FF FF 
7348   7B2B FF FF FF FF 
7348   7B2F FF FF FF FF 
7348   7B33 FF FF FF FF 
7348   7B37 FF FF FF FF 
7348   7B3B FF FF FF FF 
7348   7B3F FF FF FF FF 
7348   7B43 FF FF FF FF 
7348   7B47 FF FF FF FF 
7348   7B4B FF FF FF FF 
7348   7B4F FF FF FF FF 
7348   7B53 FF FF FF FF 
7348   7B57 FF FF FF FF 
7348   7B5B FF FF FF FF 
7348   7B5F FF FF FF FF 
7348   7B63 FF FF FF FF 
7348   7B67 FF FF FF FF 
7348   7B6B FF FF FF FF 
7348   7B6F FF FF FF FF 
7348   7B73 FF FF FF FF 
7348   7B77 FF FF FF FF 
7348   7B7B FF FF FF FF 
7348   7B7F FF FF FF FF 
7348   7B83 FF FF FF FF 
7348   7B87 FF FF FF FF 
7348   7B8B FF FF FF FF 
7348   7B8F FF FF FF FF 
7348   7B93 FF FF FF FF 
7348   7B97 FF FF FF FF 
7348   7B9B FF FF FF FF 
7348   7B9F FF FF FF FF 
7348   7BA3 FF FF FF FF 
7348   7BA7 FF FF FF FF 
7348   7BAB FF FF FF FF 
7348   7BAF FF FF FF FF 
7348   7BB3 FF FF FF FF 
7348   7BB7 FF FF FF FF 
7348   7BBB FF FF FF FF 
7348   7BBF FF FF FF FF 
7348   7BC3 FF FF FF FF 
7348   7BC7 FF FF FF FF 
7348   7BCB FF FF FF FF 
7348   7BCF FF FF FF FF 
7348   7BD3 FF FF FF FF 
7348   7BD7 FF FF FF FF 
7348   7BDB FF FF FF FF 
7348   7BDF FF FF FF FF 
7348   7BE3 FF FF FF FF 
7348   7BE7 FF FF FF FF 
7348   7BEB FF FF FF FF 
7348   7BEF FF FF FF FF 
7348   7BF3 FF FF FF FF 
7348   7BF7 FF FF FF FF 
7348   7BFB FF FF FF FF 
7348   7BFF FF FF FF FF 
7348   7C03 FF FF FF FF 
7348   7C07 FF FF FF FF 
7348   7C0B FF FF FF FF 
7348   7C0F FF FF FF FF 
7348   7C13 FF FF FF FF 
7348   7C17 FF FF FF FF 
7348   7C1B FF FF FF FF 
7348   7C1F FF FF FF FF 
7348   7C23 FF FF FF FF 
7348   7C27 FF FF FF FF 
7348   7C2B FF FF FF FF 
7348   7C2F FF FF FF FF 
7348   7C33 FF FF FF FF 
7348   7C37 FF FF FF FF 
7348   7C3B FF FF FF FF 
7348   7C3F FF FF FF FF 
7348   7C43 FF FF FF FF 
7348   7C47 FF FF FF FF 
7348   7C4B FF FF FF FF 
7348   7C4F FF FF FF FF 
7348   7C53 FF FF FF FF 
7348   7C57 FF FF FF FF 
7348   7C5B FF FF FF FF 
7348   7C5F FF FF FF FF 
7348   7C63 FF FF FF FF 
7348   7C67 FF FF FF FF 
7348   7C6B FF FF FF FF 
7348   7C6F FF FF FF FF 
7348   7C73 FF FF FF FF 
7348   7C77 FF FF FF FF 
7348   7C7B FF FF FF FF 
7348   7C7F FF FF FF FF 
7348   7C83 FF FF FF FF 
7348   7C87 FF FF FF FF 
7348   7C8B FF FF FF FF 
7348   7C8F FF FF FF FF 
7348   7C93 FF FF FF FF 
7348   7C97 FF FF FF FF 
7348   7C9B FF FF FF FF 
7348   7C9F FF FF FF FF 
7348   7CA3 FF FF FF FF 
7348   7CA7 FF FF FF FF 
7348   7CAB FF FF FF FF 
7348   7CAF FF FF FF FF 
7348   7CB3 FF FF FF FF 
7348   7CB7 FF FF FF FF 
7348   7CBB FF FF FF FF 
7348   7CBF FF FF FF FF 
7348   7CC3 FF FF FF FF 
7348   7CC7 FF FF FF FF 
7348   7CCB FF FF FF FF 
7348   7CCF FF FF FF FF 
7348   7CD3 FF FF FF FF 
7348   7CD7 FF FF FF FF 
7348   7CDB FF FF FF FF 
7348   7CDF FF FF FF FF 
7348   7CE3 FF FF FF FF 
7348   7CE7 FF FF FF FF 
7348   7CEB FF FF FF FF 
7348   7CEF FF FF FF FF 
7348   7CF3 FF FF FF FF 
7348   7CF7 FF FF FF FF 
7348   7CFB FF FF FF FF 
7348   7CFF FF FF FF FF 
7348   7D03 FF FF FF FF 
7348   7D07 FF FF FF FF 
7348   7D0B FF FF FF FF 
7348   7D0F FF FF FF FF 
7348   7D13 FF FF FF FF 
7348   7D17 FF FF FF FF 
7348   7D1B FF FF FF FF 
7348   7D1F FF FF FF FF 
7348   7D23 FF FF FF FF 
7348   7D27 FF FF FF FF 
7348   7D2B FF FF FF FF 
7348   7D2F FF FF FF FF 
7348   7D33 FF FF FF FF 
7348   7D37 FF FF FF FF 
7348   7D3B FF FF FF FF 
7348   7D3F FF FF FF FF 
7348   7D43 FF FF FF FF 
7348   7D47 FF FF FF FF 
7348   7D4B FF FF FF FF 
7348   7D4F FF FF FF FF 
7348   7D53 FF FF FF FF 
7348   7D57 FF FF FF FF 
7348   7D5B FF FF FF FF 
7348   7D5F FF FF FF FF 
7348   7D63 FF FF FF FF 
7348   7D67 FF FF FF FF 
7348   7D6B FF FF FF FF 
7348   7D6F FF FF FF FF 
7348   7D73 FF FF FF FF 
7348   7D77 FF FF FF FF 
7348   7D7B FF FF FF FF 
7348   7D7F FF FF FF FF 
7348   7D83 FF FF FF FF 
7348   7D87 FF FF FF FF 
7348   7D8B FF FF FF FF 
7348   7D8F FF FF FF FF 
7348   7D93 FF FF FF FF 
7348   7D97 FF FF FF FF 
7348   7D9B FF FF FF FF 
7348   7D9F FF FF FF FF 
7348   7DA3 FF FF FF FF 
7348   7DA7 FF FF FF FF 
7348   7DAB FF FF FF FF 
7348   7DAF FF FF FF FF 
7348   7DB3 FF FF FF FF 
7348   7DB7 FF FF FF FF 
7348   7DBB FF FF FF FF 
7348   7DBF FF FF FF FF 
7348   7DC3 FF FF FF FF 
7348   7DC7 FF FF FF FF 
7348   7DCB FF FF FF FF 
7348   7DCF FF FF FF FF 
7348   7DD3 FF FF FF FF 
7348   7DD7 FF FF FF FF 
7348   7DDB FF FF FF FF 
7348   7DDF FF FF FF FF 
7348   7DE3 FF FF FF FF 
7348   7DE7 FF FF FF FF 
7348   7DEB FF FF FF FF 
7348   7DEF FF FF FF FF 
7348   7DF3 FF FF FF FF 
7348   7DF7 FF FF FF FF 
7348   7DFB FF FF FF FF 
7348   7DFF FF FF FF FF 
7348   7E03 FF FF FF FF 
7348   7E07 FF FF FF FF 
7348   7E0B FF FF FF FF 
7348   7E0F FF FF FF FF 
7348   7E13 FF FF FF FF 
7348   7E17 FF FF FF FF 
7348   7E1B FF FF FF FF 
7348   7E1F FF FF FF FF 
7348   7E23 FF FF FF FF 
7348   7E27 FF FF FF FF 
7348   7E2B FF FF FF FF 
7348   7E2F FF FF FF FF 
7348   7E33 FF FF FF FF 
7348   7E37 FF FF FF FF 
7348   7E3B FF FF FF FF 
7348   7E3F FF FF FF FF 
7348   7E43 FF FF FF FF 
7348   7E47 FF FF FF FF 
7348   7E4B FF FF FF FF 
7348   7E4F FF FF FF FF 
7348   7E53 FF FF FF FF 
7348   7E57 FF FF FF FF 
7348   7E5B FF FF FF FF 
7348   7E5F FF FF FF FF 
7348   7E63 FF FF FF FF 
7348   7E67 FF FF FF FF 
7348   7E6B FF FF FF FF 
7348   7E6F FF FF FF FF 
7348   7E73 FF FF FF FF 
7348   7E77 FF FF FF FF 
7348   7E7B FF FF FF FF 
7348   7E7F FF FF FF FF 
7348   7E83 FF FF FF FF 
7348   7E87 FF FF FF FF 
7348   7E8B FF FF FF FF 
7348   7E8F FF FF FF FF 
7348   7E93 FF FF FF FF 
7348   7E97 FF FF FF FF 
7348   7E9B FF FF FF FF 
7348   7E9F FF FF FF FF 
7348   7EA3 FF FF FF FF 
7348   7EA7 FF FF FF FF 
7348   7EAB FF FF FF FF 
7348   7EAF FF FF FF FF 
7348   7EB3 FF FF FF FF 
7348   7EB7 FF FF FF FF 
7348   7EBB FF FF FF FF 
7348   7EBF FF FF FF FF 
7348   7EC3 FF FF FF FF 
7348   7EC7 FF FF FF FF 
7348   7ECB FF FF FF FF 
7348   7ECF FF FF FF FF 
7348   7ED3 FF FF FF FF 
7348   7ED7 FF FF FF FF 
7348   7EDB FF FF FF FF 
7348   7EDF FF FF FF FF 
7348   7EE3 FF FF FF FF 
7348   7EE7 FF FF FF FF 
7348   7EEB FF FF FF FF 
7348   7EEF FF FF FF FF 
7348   7EF3 FF FF FF FF 
7348   7EF7 FF FF FF FF 
7348   7EFB FF FF FF FF 
7348   7EFF FF FF FF FF 
7348   7F03 FF FF FF FF 
7348   7F07 FF FF FF FF 
7348   7F0B FF FF FF FF 
7348   7F0F FF FF FF FF 
7348   7F13 FF FF FF FF 
7348   7F17 FF FF FF FF 
7348   7F1B FF FF FF FF 
7348   7F1F FF FF FF FF 
7348   7F23 FF FF FF FF 
7348   7F27 FF FF FF FF 
7348   7F2B FF FF FF FF 
7348   7F2F FF FF FF FF 
7348   7F33 FF FF FF FF 
7348   7F37 FF FF FF FF 
7348   7F3B FF FF FF FF 
7348   7F3F FF FF FF FF 
7348   7F43 FF FF FF FF 
7348   7F47 FF FF FF FF 
7348   7F4B FF FF FF FF 
7348   7F4F FF FF FF FF 
7348   7F53 FF FF FF FF 
7348   7F57 FF FF FF FF 
7348   7F5B FF FF FF FF 
7348   7F5F FF FF FF FF 
7348   7F63 FF FF FF FF 
7348   7F67 FF FF FF FF 
7348   7F6B FF FF FF FF 
7348   7F6F FF FF FF FF 
7348   7F73 FF FF FF FF 
7348   7F77 FF FF FF FF 
7348   7F7B FF FF FF FF 
7348   7F7F FF FF FF FF 
7348   7F83 FF FF FF FF 
7348   7F87 FF FF FF FF 
7348   7F8B FF FF FF FF 
7348   7F8F FF FF FF FF 
7348   7F93 FF FF FF FF 
7348   7F97 FF FF FF FF 
7348   7F9B FF FF FF FF 
7348   7F9F FF FF FF FF 
7348   7FA3 FF FF FF FF 
7348   7FA7 FF FF FF FF 
7348   7FAB FF FF FF FF 
7348   7FAF FF FF FF FF 
7348   7FB3 FF FF FF FF 
7348   7FB7 FF FF FF FF 
7348   7FBB FF FF FF FF 
7348   7FBF FF FF FF FF 
7348   7FC3 FF FF FF FF 
7348   7FC7 FF FF FF FF 
7348   7FCB FF FF FF FF 
7348   7FCF FF FF FF FF 
7348   7FD3 FF FF FF FF 
7348   7FD7 FF FF FF FF 
7348   7FDB FF FF FF FF 
7348   7FDF FF FF FF FF 
7348   7FE3 FF FF FF FF 
7348   7FE7 FF FF FF FF 
7348   7FEB FF FF FF FF 
7348   7FEF FF FF FF FF 
7348   7FF3 FF FF FF FF 
7348   7FF7 FF FF FF FF 
7348   7FFB FF FF FF FF 
7348   7FFF FF 
7349   8000               #ENDIF
7350   8000             #ENDIF
7351   8000             ;
7352   8000             		.END
tasm: Number of errors = 0
